{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"哈希表\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Programming/STL/STL-hash/",
            "url": "https://or0kit.github.io/Programming/STL/STL-hash/",
            "title": "STL-hash",
            "date_published": "2022-09-27T22:44:42.000Z",
            "content_html": "<h1 id=\"散列hash\"><a class=\"anchor\" href=\"#散列hash\">#</a> 散列（hash)</h1>\n<p>散列技术是一种查找技术，而且是一种 &quot;一步到位&quot; 的查找技术。用散列技术查找的时候，一开始存储元素就按照采用的散列函数 f 所对应的规律去存储元素，使得存进去的元素 <code>key</code>  的位置是 <code>f(key)</code> 。查找时直接通过函数 f 计算出要查找元素的位置 <code>index</code> 。散列技术既是一种查找技术也是一种存储技术。这里的函数 <code>f</code>  叫散列函数 (哈希函数), 采用散列技术所建立的元素存储空间就是散列表 (哈希表)，元素的存储位置就叫散列地址 (哈希地址)。</p>\n<p>优点：简化了比较过程，效率大大提高。</p>\n<p>缺点：</p>\n<p>1. 散列技术不适合集合中重复元素很多的情形，因为同样的 <code>key</code>  会对应很多 <code>index</code> ，比如用性别查找一个班的学生。<br />\n2. 散列技术不适合范围查找，也不适合查找最大值，最小值。<br />\n3. 散列函数需要很好的设计，应该保证简单、均匀、存储效率高。<br />\n4. 可能有不同的元素被映射到相同的位置 (即有相同的索引) 。因为元素个数大于 <code>array</code>  容量。这便是所谓的 “碰撞 (ollision)” 问题。解决碰撞问题的方法有许多种，包括线性探测 (linearprobing) 、二次探测 (quadratic probing) 、开链 (separate chaining) 等做法。每一种的效率各不相同 --- 与 <code>array</code>  的填满程度有关。</p>\n<p>散列函数应该满足什么样的特性呢？<br />\n 首先应该计算简单，避免每次查找时计算散列地址耗费太多时间<br />\n其次应该保证计算出来的哈希地址空间分布均匀，这样可以节省空间和为处理冲突而耗费的时间。</p>\n<p>关于散列冲突的处理有几种办法，比如线性探测法、二次探测法、随机探测法等。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjcyNjgxL2FydGljbGUvZGV0YWlscy8xMjA4MTA5MzM=\">https://blog.csdn.net/qq_44272681/article/details/120810933</span></p>\n",
            "tags": [
                "哈希表"
            ]
        }
    ]
}