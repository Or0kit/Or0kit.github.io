{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"cli指令\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Protect-Mode/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Protect-Mode/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/",
            "title": "保护模式-中断与异常",
            "date_published": "2021-09-03T14:43:18.000Z",
            "content_html": "<h1 id=\"什么是中断\"><a class=\"anchor\" href=\"#什么是中断\">#</a> 什么是中断</h1>\n<ol>\n<li>\n<p>中断通常是由 CPU 外部的输入输出设备 (硬件) 所触发的，供外部设备通知<br />\n CPU “有事情需要处理”，因此又叫中断请求 (Interrupt Request).</p>\n</li>\n<li>\n<p>中断请求的目的是希望 CPU 暂时停止执行当前正在执行的程序，转去执行<br />\n中断请求所对应的中断处理例程 (中断处理程序在哪有 IDT 表决定)</p>\n</li>\n<li>\n<p>80x86 有两条中断请求线：</p>\n<p>非屏蔽中断线，称为 NMI（NonMaskable Interrupt）</p>\n<p>可屏蔽中断线，称为 INTR（Interrupt Require）</p>\n</li>\n<li>\n<p>假设没有中断这种机制，当一个的程序的代码为死循环时，其他的程序就没有机会执行了。</p>\n</li>\n</ol>\n<p>中断的本质：改变 CPU 的执行路线</p>\n<h2 id=\"可屏蔽中断\"><a class=\"anchor\" href=\"#可屏蔽中断\">#</a> 可屏蔽中断</h2>\n<p><strong>描述：</strong></p>\n<p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器<br />\n它负责分配中断资源和管理各个中断源发出的中断请求<br />\n为了便于标识各个中断请求，中断管理器通常用 IRQ（Interrupt Request）后面加上数字来表示不同的中断<br />\n比如：在 Windows 中，时钟中断的 IRQ 编号为 0，也就是  <code>IRQ0</code></p>\n<h2 id=\"时钟中断\"><a class=\"anchor\" href=\"#时钟中断\">#</a> 时钟中断</h2>\n<p><strong>描述：</strong></p>\n<p>大多数操作系统时钟中断在 10-100MS 之间，Windows 系列为 10-20MS<br />\nWindows 时钟中断每隔 10~20MS 会向 CPU 发送一个请求，当 CPU 收到请求时，操作系统就会接管 CPU，指定 CPU 去执行一段代码，操作系统在这段代码里便有机会进行线程的切换。这样，即便一个程序进入死循环，操作系统依然有机会进行线程切换<br />\n当然，操作系统主要并不是通过时钟中断来进行线程切换，而只是有机会进行线程切换，这里只是举个例子。</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<h2 id=\"可屏蔽中断如何处理\"><a class=\"anchor\" href=\"#可屏蔽中断如何处理\">#</a> 可屏蔽中断如何处理？</h2>\n<p><strong>描述：</strong></p>\n<ol>\n<li><strong>时钟中断</strong>的 <strong>IRQ 编号为 0</strong> ，所在位置为<strong> IDT [0x30]</strong></li>\n<li><strong>IRQ1~IRQ15</strong> 分别对应<strong> IDT [0x31]~IDT [0x35]</strong></li>\n</ol>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p><strong>特别说明：</strong></p>\n<p>1、如果自己的程序执行时不希望 CPU 去处理这些中断，可以<br />\n用  <code>CLI</code>  指令清空 EFLAG 寄存器中的 IF 位<br />\n用  <code>STI</code>  指令设置 EFLAG 寄存器中的 IF 位</p>\n<p>2、硬件中断与 IDT 表中的对应关系并非固定不变的<br />\n参见：APIC（高级可编程中断控制器）</p>\n<h2 id=\"不可屏蔽中断如何处理\"><a class=\"anchor\" href=\"#不可屏蔽中断如何处理\">#</a> 不可屏蔽中断如何处理？</h2>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<p>特别说明：</p>\n<blockquote>\n<p>当非可屏蔽中断产生时，CPU 在执行完当前指令后会里面进入中断处理程序</p>\n</blockquote>\n<blockquote>\n<p>非可屏蔽中断不受 EFLAG 寄存器中 IF 位的影响，一旦发生，CPU 必须处理</p>\n</blockquote>\n<blockquote>\n<p>非可屏蔽中断处理程序位于 IDT 表中的 2 号位置</p>\n</blockquote>\n<h1 id=\"异常\"><a class=\"anchor\" href=\"#异常\">#</a> 异常</h1>\n<p>描述：</p>\n<blockquote>\n<p>异常通常是 <strong>CPU 在执行指令时检测到的某些错误</strong> ，比如除 0、访问无效页面等。</p>\n</blockquote>\n<p>中断与异常的区别：</p>\n<ol>\n<li><code>中断</code> 来自于 <strong>外部设备</strong> ，是 <strong>中断源</strong> （比如键盘）发起的，<strong>CPU 是被动的</strong></li>\n<li><code>异常</code> 来自于 <strong>CPU 本身</strong> ，是<strong> CPU 主动产生的</strong></li>\n<li><strong>INT N</strong> 虽然被称为 “软件中断”，但其<strong>本质是异常</strong></li>\n<li>EFLAG 的  <code>IF位</code> 对  <code>INT N</code>  无效。</li>\n</ol>\n<h2 id=\"异常处理\"><a class=\"anchor\" href=\"#异常处理\">#</a> 异常处理</h2>\n<p>描述：</p>\n<blockquote>\n<p>无论是由<strong>硬件设备触发的中断请求</strong>还是由 <strong>CPU 产生的异常</strong> ，处理程序都在  <code>IDT表</code></p>\n</blockquote>\n<p>常见的异常处理程序：</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<p><code>页错误</code> ：当我们访问一个 <strong>线性地址</strong> ，而这个线性地址指向的<strong>物理页</strong>是 <strong>无效的</strong> ，便会触发 CPU 异常，该异常位于 <strong>E 号门</strong> （IDT [0xE]）<br />\n <code>段错误</code> ：一旦<strong>段的运算发生异常</strong>时（如权限检查），便会走 <strong>D 号门</strong> （IDT [0xD]）<br />\n <code>除0错误</code> ：当<strong>除数为 0</strong> 时，会触发异常，这时走 <strong>0 号门</strong> （IDT [0x0]）<br />\n <code>双重错误</code> ：假设 <strong>执行一个异常（如页错误）时又产生了一个错误</strong> ，那么便会触发双重错误，这时走 <strong>8 号门</strong> （IDT [0x8]）</p>\n<h2 id=\"缺页异常\"><a class=\"anchor\" href=\"#缺页异常\">#</a> 缺页异常</h2>\n<p>缺页异常的 <strong>产生</strong> （例举两种）：</p>\n<ol>\n<li>当 PDE/PTE 的<strong> P=0</strong> 时会发生缺页异常</li>\n<li>当 PDE/PTE 的<strong>属性为只读但程序试图写入</strong>时会发生缺页异常</li>\n</ol>\n<p>一旦发生缺页异常，CPU 会执行 IDT 表中的<strong> 0xE 号</strong>中断处理程序，由操作系统来接管，后面会学习的。</p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<h1 id=\"实验\"><a class=\"anchor\" href=\"#实验\">#</a> 实验</h1>\n<h2 id=\"分析idt表中0x2号中断的执行流程\"><a class=\"anchor\" href=\"#分析idt表中0x2号中断的执行流程\">#</a> 分析 IDT 表中 0x2 号中断的执行流程</h2>\n<h2 id=\"分析idt表中0x8号中断的执行流程\"><a class=\"anchor\" href=\"#分析idt表中0x8号中断的执行流程\">#</a> 分析 IDT 表中 0x8 号中断的执行流程</h2>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTg4NDQ4L2FydGljbGUvZGV0YWlscy8xMDI3NjA1NzA=\">https://blog.csdn.net/qq_41988448/article/details/102760570</span></p>\n",
            "tags": [
                "中断",
                "异常",
                "CLI指令",
                "STI指令",
                "INT2",
                "INT8"
            ]
        }
    ]
}