{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"地址空间\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80plus/",
            "url": "https://or0kit.github.io/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80plus/",
            "title": "驱动开发-内核编程基础plus",
            "date_published": "2021-12-06T14:08:01.000Z",
            "content_html": "<h1 id=\"楔子\"><a class=\"anchor\" href=\"#楔子\">#</a> 楔子</h1>\n<p>学习一下常用的驱动编程机制。</p>\n<h1 id=\"上下文环境\"><a class=\"anchor\" href=\"#上下文环境\">#</a> 上下文环境</h1>\n<p>应用层 EXE 有独立进程的概念。当这个 EXE 运行的时候，开发者可以很清楚地知道程序的定运行在哪一个线程中。对于内核驱动开发来说，进程的概念啊显得相当模糊，初学者往往不清楚自己的驱动代码具体运行在什么进程或线程中。</p>\n<p>这就是需要了解的上下文 (Context) 概念，上下文泛指 CPU 在执行代码时，该代码所处的环境与状态。通俗来讲，这些环境包括（不仅限）：当前代码所属线程、中断请求级别、CPU 寄存器各状态。</p>\n<p>这里可以做一个小实验，写代码验证一下。<br />\n写一个简单的驱动代码，测试驱动入口函数和驱动卸载函数在执行时是属于哪一个进程的，只要在这两个函数中调用  <code>PsGetCurrentProcessId</code>  函数获取当前进程 ID 就行。</p>\n<p>这里我就直接说结果了。</p>\n<p>无论是驱动入口函数还是驱动卸载函数，都隶属于进程 ID 为 4 的进程，也就是 SYSTEM 进程。</p>\n<p>SYSTEM 进程其实是操作系统虚拟出来的一个进程，代表系统内核。一般来说内核代码都处于 SYSTEM 进程空间中，但驱动对象（DRIVER_OBJECT）的派遣例程一般工作在发起请求的进程中。</p>\n<p><strong>地址空间</strong>，对 32 位系统来说，应用层程序有独立的 2GB 低地址虚拟内存空间，而高地址的 2GB 是内核共享的地址空间。<br />\n在 64 位 Windows 中，虚拟地址空间的理论大小为 2 的 64 次方字节，但实际使用的仅一小部分，范围从  <code>0x000`00000000</code>  至  <code>0x7FF`FFFFFFFF</code>  的 8TB 用于应用层空间，范围从  <code>0xFFFF0800`00000000</code>  至  <code>0xFFFFFFFF`FFFFFFFF</code>  的 248TB 用于内核空间。</p>\n<h1 id=\"中断请求级别\"><a class=\"anchor\" href=\"#中断请求级别\">#</a> 中断请求级别</h1>\n<h1 id=\"链表\"><a class=\"anchor\" href=\"#链表\">#</a> 链表</h1>\n<p>链表作为内核</p>\n<h1 id=\"自旋锁\"><a class=\"anchor\" href=\"#自旋锁\">#</a> 自旋锁</h1>\n<h1 id=\"注册表\"><a class=\"anchor\" href=\"#注册表\">#</a> 注册表</h1>\n<p>注册表是 Windows 系统中最重要的数据配置存储结构，存储着系统绝大部分的核心配置信息。注册表实际上也是一种文件。这些文件大多数存储在<strong>系统盘</strong> system32\\config 目录下。</p>\n<p>在资源管理器中我没有权限访问，懒得更改了，我在 cmd 中查看如下：</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>C:\\Windows\\System32\\config&gt;dir</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>C:\\Windows\\System32\\config 的目录</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>2022&#x2F;05&#x2F;09  13:09    &lt;DIR&gt;          .</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>2022&#x2F;05&#x2F;09  13:09    &lt;DIR&gt;          ..</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>2022&#x2F;05&#x2F;06  00:57           524,288 BBI</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>2022&#x2F;01&#x2F;26  16:46            28,672 BCD-Template</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>2022&#x2F;05&#x2F;09  18:04        38,797,312 COMPONENTS</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>2022&#x2F;05&#x2F;06  00:57           786,432 DEFAULT</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>2022&#x2F;05&#x2F;09  17:31         8,118,272 DRIVERS</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>2022&#x2F;01&#x2F;26  18:14            32,768 ELAM</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>2022&#x2F;01&#x2F;26  16:37    &lt;DIR&gt;          Journal</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>2022&#x2F;01&#x2F;26  16:37    &lt;DIR&gt;          RegBack</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>2022&#x2F;05&#x2F;06  00:57           131,072 SAM</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>2022&#x2F;05&#x2F;06  00:57            65,536 SECURITY</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>2022&#x2F;05&#x2F;06  00:57       118,489,088 SOFTWARE</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>2022&#x2F;05&#x2F;06  00:57        24,903,680 SYSTEM</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>2022&#x2F;01&#x2F;26  16:37    &lt;DIR&gt;          systemprofile</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>2022&#x2F;01&#x2F;26  16:37    &lt;DIR&gt;          TxR</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>2022&#x2F;01&#x2F;26  16:40             8,192 userdiff</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>              11 个文件    191,885,312 字节</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>               6 个目录 50,612,371,456 可用字节</pre></td></tr></table></figure><p>可以看到  <code>SOFTWARE</code>  、  <code>SYSTEM</code>  、  <code>SAM</code>  、等文件，这些文件被以<strong>内存映射</strong>的方式映射到内核空间，然后以一种被称为 “HIVE&quot; 的方式组织起来、注册表 API 实际上操作的是这份 HIVE 内存数据，对 HIVE 数据的改动，最终会被回写到 config 目录下对应的文件中。</p>\n<p>如果只是想单纯的使用注册表做数据读取或存储，可以没有必要深入去研究内核对注册表的实现方式。</p>\n<h2 id=\"注册表的打开与关闭\"><a class=\"anchor\" href=\"#注册表的打开与关闭\">#</a> 注册表的打开与关闭</h2>\n<h2 id=\"注册表的修改\"><a class=\"anchor\" href=\"#注册表的修改\">#</a> 注册表的修改</h2>\n<h2 id=\"注册表的读取\"><a class=\"anchor\" href=\"#注册表的读取\">#</a> 注册表的读取</h2>\n<h2 id=\"作业\"><a class=\"anchor\" href=\"#作业\">#</a> 作业</h2>\n<h3 id=\"注册表实现驱动的自启\"><a class=\"anchor\" href=\"#注册表实现驱动的自启\">#</a> 注册表实现驱动的自启</h3>\n<p>驱动文件的转移</p>\n<h1 id=\"文件操作\"><a class=\"anchor\" href=\"#文件操作\">#</a> 文件操作</h1>\n<h2 id=\"文件的打开与关闭\"><a class=\"anchor\" href=\"#文件的打开与关闭\">#</a> 文件的打开与关闭</h2>\n<h2 id=\"文件的读写\"><a class=\"anchor\" href=\"#文件的读写\">#</a> 文件的读写</h2>\n<h2 id=\"文件的删除\"><a class=\"anchor\" href=\"#文件的删除\">#</a> 文件的删除</h2>\n<p>强行删除<br />\n文件的保护</p>\n<h2 id=\"作业-2\"><a class=\"anchor\" href=\"#作业-2\">#</a> 作业</h2>\n<p>在内核中实现文件的拷贝</p>\n<h1 id=\"线程与事件\"><a class=\"anchor\" href=\"#线程与事件\">#</a> 线程与事件</h1>\n<h2 id=\"使用系统线程\"><a class=\"anchor\" href=\"#使用系统线程\">#</a> 使用系统线程</h2>\n<h2 id=\"使用同步事件\"><a class=\"anchor\" href=\"#使用同步事件\">#</a> 使用同步事件</h2>\n",
            "tags": [
                "上下文环境",
                "中断请求级别",
                "链表",
                "自旋锁",
                "注册表",
                "地址空间",
                "文件操作",
                "线程与事件"
            ]
        }
    ]
}