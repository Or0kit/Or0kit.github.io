{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"fat12/16磁盘卷\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/Drive-Development/%E7%A3%81%E7%9B%98%E7%9A%84%E8%99%9A%E6%8B%9F/",
            "url": "https://or0kit.github.io/Bin/Core/Drive-Development/%E7%A3%81%E7%9B%98%E7%9A%84%E8%99%9A%E6%8B%9F/",
            "title": "磁盘的虚拟",
            "date_published": "2022-07-27T14:35:15.000Z",
            "content_html": "<h1 id=\"虚拟的磁盘\"><a class=\"anchor\" href=\"#虚拟的磁盘\">#</a> 虚拟的磁盘</h1>\n<p>虚拟磁盘是我们可以在操作系统中增加一个行为完全可控的虚拟的磁盘驱动器。</p>\n<p>一个虚拟磁盘应用是加密，可以制作一个虚拟的磁盘，对这个磁盘的所有写入操作都通过某种算法以口令加密，同时对这个磁盘的读取作使用同样的算法和口令解密，那么在该程序运行时，操作系统和用户自己都可以看到正确的数据，而在这个程序不工作时，无论是谁企图读这磁盘，都只能看到被加密过的数据。这个特点使得这种磁盘成为一个存放机密文件的好地方，对这个磁盘的任何正常读 / 写，已经在不知不觉中被加（解）密了。</p>\n<h1 id=\"ramdisk\"><a class=\"anchor\" href=\"#ramdisk\">#</a> Ramdisk</h1>\n<p>我们接下来学习一下  <code>WDK6001.18000</code>  里自带的一个例子 —— <code>Ramdisk</code>  。</p>\n<p><code>Ramdisk</code>  使用非分页内存 (nonpaged memory) 做的磁盘存储空间，并将其以一个独立的磁盘形式暴露给用户，用户可以将其格式化成一个 Windows 能够使用的卷，并且像操作一般的磁盘卷一样对它进行操作。</p>\n<p>由于使用了内存作为虚拟的存储介质，这个磁盘具有的一个显著特点是性能的提高。由于内存本身的存取速度就比盘高许多倍，而且内存的随机存取速度又比磁盘寻道速度快很多，这几个优势使得这个内存盘非常适合作为各种软件的缓冲盘。</p>\n<p>这个磁盘的第二个显著特点是占用了大量的内存。这个特点几乎不需要解释，得到了多大的内存空间使用稀疏算法，使它看起来比实际上可用得要大得多，甚至还可以对内存空间进行压缩处理，使得它能存储更多的数据。</p>\n<p>这个磁盘的第三个显著特点就是，这是一个不具有非易失性的存储介质，这点很容易理解，关机重启之后，内存里没有数据可以留下来。</p>\n<p>这个例子使用了微软的 WDF 驱动开发框架，和普通的 WDM 驱动是不太一样的，接下来以这个驱动里的一些行为和方法对比普通的 WDM 驱动的行为和方法进行学习。</p>\n<p>WDM 驱动模型和 WDF 驱动模型的最大的区别是：</p>\n<ul>\n<li>wdf 驱动框架对 WDM 进行了一次封装，WDF 框架就好像 C++ 中的基类一样，且这个基类中的 model,IO model ,pnp 和电源管理模型；且提供了一些与操作系统相关的处理函数，这些函数好像 C++ 中的虚函数一样，WDF 驱动中能够对这些函数进行重写；特别是 Pnp 管理和电源管理！基本上都由 WDF 框架做了，而 WDF 的功能驱动几乎不要对它进行特殊的处理；</li>\n<li>WDF 驱动采用队列进行 IO 处理，而 WDM 中将所有的 IO 操作都用默认的队列进行处理，如果要进行 IRp 同步，必须使用 StartIO；</li>\n<li>WDF 是面向对象的，而 WDM 是面向过程的，WDF 提供对象的封装，如将 IRP 封装成 WDFREQUEST，对象提供方法和 Event。</li>\n</ul>\n<h2 id=\"入口函数\"><a class=\"anchor\" href=\"#入口函数\">#</a> 入口函数</h2>\n<p>再次学习一下驱动程序的入口函数。</p>\n<h3 id=\"入口函数的定义\"><a class=\"anchor\" href=\"#入口函数的定义\">#</a> 入口函数的定义</h3>\n<p>任何一个驱动程序，都会有一个  <code>DriverEntry</code>  入口函数，就像应用程序里的 main 一样。这个函数的声明是这样的:</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>NTSTATUS <span class=\"token function\">DriverEntry</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tIN PDRIVER_OBJECT DrvierObject<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN PUNICODE_STRING RegisitryPath<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个函数的返回值是 NTSTATUS 类型，在驱动程序开发中经常会看到这个类型的返回值，它的各种预定义值几乎包含了驱动程序开发中所有可能出现的返回值，当然主要是各种各样的错误。<br />\n驱动程序开发人员的一个基本技能就是根据这个返回值来确定函数调用出了什么问题，这些返回值的定义位于  <code>WinDDK</code>  安装目录下的  <code>inc\\api\\ntstatus.h</code>  中，从返回值宏定义的英文意思上就基本可以判断出这个返回值的含义了。</p>\n<p>这个函数具有两个参数，第一个参数是一个  <code>PDRIVER_OBJECT</code>  类型的指针，它代表了 Windows 系统为这个驱动程序所分配的一个驱动对象。<strong>这个驱动对象是 Windows 系统中对某个驱动的唯一标识，里面包括了这个驱动的各种信息、各功能函数的入口地址等重要信息，信息量非常庞大，且复杂。</strong><br />\n在这里可以简单地认为，只要正确处理这个结构的每个成员，驱动就能够实现它的功能了。</p>\n<p>DriverEntry 的第二个参数是一个 Unicode 字符串，<strong>它代表了驱动在注册表中的参数所存放的位置。</strong><br />\n由于每一个驱动都是一个类似服务的形式存在的，在系统注册表的  <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services</code>  树下总有一个和驱动名字相同的子树用来描述这个驱动的一些基本信息，并提供一个可使用的存储空间供驱动存放自己的特有信息。<br />\n<strong>之所以在注册表中提供这么一个地方来供驱动存储信息，是因为很多驱动加载得非常早</strong>，甚至仅仅晚于 Windows 内核，这时文件系统还没有建立，驱动程序如果需要在此时享有自己可操作的存储空间（例如用来记录一些参数），除了注册表，没有其他任何地方可以使用。<strong>Windows 内核在启动时加载了一个最小的文件系统，分析磁盘并将注册表的  <code>HKEY_LOCAL_MACHINE\\SYSTEM</code>  树下的所有内容读入到内存里，这样就保证了这一部分的注册表内容在 Windows 内核刚加载之后就是可以读 / 写的。</strong><br />\nWindows 系统在启动过程中会在适当的时候将这棵子树的内容和磁盘上的注册表进行同步，之后的注册表操作就和一般的注册表操作别无二致了。在 Windows 内核刚加载之后，到这个适当的同步时间之前，任何加载的驱动程序都可以操作注册表并确保操作结果被最终留在了磁盘上，这就是 Windows 系统确保任何驱动都可以使用它提供的注册表路径来存储信息的秘密所在，也是这个注册表路径要作为驱动入口函数参数的重要意义。</p>\n<h3 id=\"ramdisk驱动的入口函数\"><a class=\"anchor\" href=\"#ramdisk驱动的入口函数\">#</a> Ramdisk 驱动的入口函数</h3>\n<p>这是 Ramdisk 驱动的入口函数源码：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">DriverEntry</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN PDRIVER_OBJECT DriverObject<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN PUNICODE_STRING RegistryPath</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    WDF_DRIVER_CONFIG config<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">KdPrint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Windows Ramdisk Driver - Driver Framework Edition.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">KdPrint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Built %s %s\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">__DATE__</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">__TIME__</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">WDF_DRIVER_CONFIG_INIT</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">&amp;</span>config<span class=\"token punctuation\">,</span> RamDiskEvtDeviceAdd <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">WdfDriverCreate</span><span class=\"token punctuation\">(</span>DriverObject<span class=\"token punctuation\">,</span> RegistryPath<span class=\"token punctuation\">,</span> WDF_NO_OBJECT_ATTRIBUTES<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>config<span class=\"token punctuation\">,</span> WDF_NO_HANDLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>看完源码后，我们需要了解  <code>WDF_DRIVER_CONFIG</code>  结构和  <code>WDF_DRIVER_CONFIG_INIT</code> ，还有后面的  <code>WdfDriverCreate</code>  函数。</p>\n<h4 id=\"wdf_driver_config-和-wdf_driver_config_init\"><a class=\"anchor\" href=\"#wdf_driver_config-和-wdf_driver_config_init\">#</a> WDF_DRIVER_CONFIG 和 WDF_DRIVER_CONFIG_INIT</h4>\n<p><code>WDF_DRIVER_CONFIG</code>  结构是  <code>WdfDriverCreate</code>  的输入参数。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_WDF_DRIVER_CONFIG</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  ULONG                     Size<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  PFN_WDF_DRIVER_UNLOAD     EvtDriverUnload<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  ULONG                     DriverInitFlags<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  ULONG                     DriverPoolTag<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> WDF_DRIVER_CONFIG<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PWDF_DRIVER_CONFIG<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>Size</code></p>\n<p>此结构的大小（以字节为单位）。</p>\n<p><code>EvtDriverDeviceAdd</code></p>\n<p>指向驱动程序的 EvtDriverDeviceAdd 回调函数的指针。</p>\n<p><code>EvtDriverUnload</code></p>\n<p>指向驱动程序的 EvtDriverUnload 回调函数的指针。</p>\n<p><code>DriverInitFlags</code></p>\n<p>一个或多个 WDF_DRIVER_INIT_FLAGS 类型值的按位或，用于标识驱动程序初始化标志。</p>\n<p><code>DriverPoolTag</code></p>\n<p>（KMDF 版本 1.5 和更高版本。）驱动程序定义的池标记，框架将分配给所有驱动程序的池分配。</p>\n<hr />\n<p>要初始化  <code>WDF_DRIVER_CONFIG</code>  结构，驱动程序必须调用  <code>WDF_DRIVER_CONFIG_INIT</code> 。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">WDF_DRIVER_CONFIG_INIT</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">[</span>out<span class=\"token punctuation\">]</span>          PWDF_DRIVER_CONFIG        Config<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">,</span> optional<span class=\"token punctuation\">]</span> PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>参数<br />\n <code>[out] Config</code></p>\n<p>指向函数将初始化的 WDF_DRIVER_CONFIG 结构的指针。</p>\n<p><code>[in, optional] EvtDriverDeviceAdd</code></p>\n<p>指向驱动程序的  <code>EvtDriverDeviceAdd</code>  回调函数的指针。</p>\n<h4 id=\"wdfdrivercreate函数\"><a class=\"anchor\" href=\"#wdfdrivercreate函数\">#</a> WdfDriverCreate 函数</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>NTSTATUS <span class=\"token function\">WdfDriverCreate</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span>            PDRIVER_OBJECT         DriverObject<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span>            PCUNICODE_STRING       RegistryPath<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">,</span> optional<span class=\"token punctuation\">]</span>  PWDF_OBJECT_ATTRIBUTES DriverAttributes<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span>            PWDF_DRIVER_CONFIG     DriverConfig<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">[</span>out<span class=\"token punctuation\">,</span> optional<span class=\"token punctuation\">]</span> WDFDRIVER              <span class=\"token operator\">*</span>Driver</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>参数</strong><br />\n <code>[in] DriverObject</code></p>\n<p>指向表示 Windows 驱动程序模型 (WDM) 驱动程序对象的 DRIVER_OBJECT 结构的指针。驱动程序接收该指针作为其 DriverEntry 例程的输入。</p>\n<p><code>[in] RegistryPath</code></p>\n<p>一个指向 UNICODE_STRING 结构的指针，该结构包含驱动程序接收的作为其 DriverEntry 例程的输入的注册表路径字符串。</p>\n<p><code>[in, optional] DriverAttributes</code></p>\n<p>指向调用者分配的 WDF_OBJECT_ATTRIBUTES 结构的指针。（结构的 ParentObject 成员必须为 NULL。）此参数是可选的，可以是 WDF_NO_OBJECT_ATTRIBUTES。</p>\n<p><code>[in] DriverConfig</code></p>\n<p>指向调用者分配的 WDF_DRIVER_CONFIG 结构的指针。</p>\n<p><code>[out, optional] Driver</code></p>\n<p>指向接收新框架驱动程序对象句柄的位置的指针。此参数是可选的，可以是 WDF_NO_HANDLE。</p>\n<p><strong>返回值</strong><br />\n如果操作成功， WdfDriverCreate 返回  <code>STATUS_SUCCESS</code>  。否则，此方法可能会返回以下值之一：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">返回码</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>STATUS_DRIVER_INTERNAL_ERROR</strong></td>\n<td style=\"text-align:left\">驱动程序多次调用 WdfDriverCreaterivercreate</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>STATUS_INVALID_PARAMETER</strong></td>\n<td style=\"text-align:left\">非即插即用 (PnP) 驱动程序指定了 EvtDriverDeviceAdd 回调函数。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ramdisk的入口函数详解\"><a class=\"anchor\" href=\"#ramdisk的入口函数详解\">#</a> Ramdisk 的入口函数详解</h4>\n<ul>\n<li>DriverEntry 做的第一件事情是声明了一个  <code>WDF_DRIVER_CONFIG</code>  类型的变量  <code>config</code> ，并且在两句无关痛痒的输出语句之后，很快地使用  <code>WDF_DRIVER_ CONFIG_INIT</code>  初始化了  <code>config</code>  变量。</li>\n<li><code>WDF_DRIVER_CONFIG</code>  结构通常用来说明这个驱动程序的一些可配置项，其中包括了这个驱动程序的  <code>EvtDriverDeviceAdd</code>  和  <code>EvtDriverUnload</code>  回调函数的入口地址、这个驱动在初始化时的一些标志和在分配内存时所使用的  <code>tag</code>  值。</li>\n<li><code>WDF_DRIVER_CONFIG_INIT</code>  宏在初始化  <code>WDF_DRIVER_CONFIG</code>  类型的变量时会把用户提供的  <code>EvtDriverDeviceAdd</code>  回调函数的入口地址存入其中，并且初始化这个变量的其他部分。</li>\n<li><code>EvtDriverDeviceAdd</code>  回调函数是 WDF 驱动框架中的一个重要的回调函数，它用来在即插即用管理器发现一个新设备的时候对这个设备进行初始化操作，在这里读者可以将自己编写的  <code>RamDiskEvtDeviceAdd</code>  函数提供给系统作为本驱动的  <code>EvtDriverDeviceAdd</code>  回调函数。</li>\n<li>在设置好了  <code>config</code>  变量之后，  <code>DriverEntry</code>  直接调用了  <code>WdfDriverCreate</code>  并返回。<br />\n <code>WdfDriverCreate</code>  函数是在使用任何 WDF 框架提供的函数之前必须调用的一个函数，谭文认为，这无非是微软对原本的驱动程序开发方式的一次包装，它的作用就是根据参数来对 WDF 中的一些环境进行初始化工作，并且建立这个 WDF 驱动的驱动对象。<br />\n <code>WdfDriverCreate</code>  函数的前两个参数就是 DriverEntry 传入的驱动对象（DriverObject）和注册表路径 RegistryPath）；第三个参数被用来说明这个 WDF 驱动的驱动对象的一些属性，这里简单地用  <code>WDF_NO_OBJECT_ATTRIBUTES</code>  来说明不需要的特殊属性；第四个参数是之前初始化过的  <code>WDF_DRIVER_CONFIG</code>  变量；最后一个参数作为这个函数的输出结果 ——WDF 驱动的驱动对象。</li>\n<li>调用了这个函数之后，前面初始化过的 config 变量中的  <code>EvtDriverDeviceAdd</code>  回调函数 —— <code>RamDiskEvtDeviceAdd</code>  就和这个驱动挂钩起来，在今后的系统运行过程中，一旦发现了此类设备，RamDiskEvtDeviceAdd 就会被 Windows 的 PnP 管理器调用，这个驱动自己的处理流程也就要上演了。</li>\n</ul>\n<h2 id=\"evtdriverdeviceadd函数\"><a class=\"anchor\" href=\"#evtdriverdeviceadd函数\">#</a> EvtDriverDeviceAdd 函数</h2>\n<p>在本驱动中， RamDiskEvtDeviceAdd 作为一个 EvtDriverDeviceAdd 函数在 DriverEntry 中被注册，在 DriverEntry 函数执行完毕之后，这个驱动就只依靠 RamDiskEvtDriverDevicAdd 函数和系统保持联系了。正如上一节所说的，系统在运行过程中一旦发现了这种类型的设备，就会调用 RamDiskEvtDriverDevicAdd 函数。下面进行更仔细的分析:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>NTSTATUS <span class=\"token function\">RamDiskEvtDeviceAdd</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tIN WDFDRIVER Driver<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tIN PWDFDEVICT_INIT DeviceInit</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个函数的返回值是 NTSTATUS 类型，可以根据实际函数的执行结果选择返回代表正确的 STATUS_SUCCESS 或者其他代表错误的返回值。</p>\n<p>这个函数的第一个参数在这个例子中并不会使用到；第二个参数是一个  <code>WDFDEVICE_INIT</code>  类型的指针，这个参数是  <code>WDF</code>  驱动模型中自动分配出来的一个数据结构，专门传递给  <code>EvtDriverrDeviceAdd</code>  类函数用来建立一个新设备。<br />\n下面分段具体看这个驱动的  <code>EvtDriverDeviceAdd</code>  类函数是如何工作的。</p>\n<h3 id=\"局部变量的声明\"><a class=\"anchor\" href=\"#局部变量的声明\">#</a> 局部变量的声明</h3>\n<p>这里简单介绍一下每个变量的作用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 将要建立的设备对象的属性描述变量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>WDF_OBJECT_ATTRIBUTES deviceAttributes<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 将要调用的各种函数的状态返回值</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>NTSTATUS status<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 将要建立的设备</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>WDFDEVICE device<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 将要建立的队列对象的属性描述变量</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>WDF_OBJECT_ATTRIBUTES queueAttributes<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 将要建立的队列配置变量</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>WDF_IO_QUEUE_CONFIG ioQueueConfig<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// 这个设备对应的设备扩展域的指针</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>PDEVICE_EXTENSION pDeviceExtension<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 将要建立的队列扩展域的指针</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>PQUEUE_EXTENSION pQueueContext <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 将要建立的队列</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>WDFQUEUE queue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 声名一个 UNICODE_STRING 类型的变量，并将它初始化为 NT_DEVICE_NAME 宏所声名的字符串，这里实际上是 \\\\Device\\\\Ramdisk</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">DECLARE_CONST_UNICODE_STRING</span><span class=\"token punctuation\">(</span>ntDevictName<span class=\"token punctuation\">,</span>NT_DEVICE_NAME<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">// 保证这个函数可以操作 paged 内存</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token function\">PAGRD_CODE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">// 由于我们不适用 Driver 这个参数，为了避免警告，加入这句</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token function\">UNREFFERENCED_PARAMETER</span><span class=\"token punctuation\">(</span>Driver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"磁盘设备的创建\"><a class=\"anchor\" href=\"#磁盘设备的创建\">#</a> 磁盘设备的创建</h3>\n<p><code>EvtDriverDeviceAdd</code>  类函数的一个重要任务是创建设备，而它的  <code>WDFDEVICE_INIT</code>  类型参数就是用来做这件事情的，在创建设备之前需要按照开发人员的思想对  <code>WDFDEVICE_INIT</code>  变量进行进一步的加工，使创建的设备能够达到想要的效果。</p>\n<p><strong>这里的设备首先需要一个名字，这是因为这个设备将会通过这个名字暴露给应用层并且被应用层所使用，一个没有名字的设备是无法在应用层使用的。</strong></p>\n<p>另外，需要将这个设备的类型设置为  <code>FILE_DEVICE_DISK</code>  ，这是因为所有的磁盘设备都需要使用这个设备类型。<br />\n将这个设备的 IO 类型设置为 <code>Direct</code>  方式，这样在将读 / 写和 <code>DeviceIoControl</code>  的 IRP 发送到这个设备时，IRP 所携带的缓冲区可以直接被使用。<br />\n将 <code>Exclusive</code>  设置为 <code>FALSE</code> ，这说明这个设备可以被多次打开。<br />\n这里还需要给这个设备对象关联一个设备扩展的上下文，<strong>这是开发人员指定类型的一块内存区域</strong>，这块内存区域被设备的设备扩展指针所指，开发人员可以在这块内存区域里存储自己定义的一些信息。<em>针对本驱动建立出的任何一个设备，这块内存区域的结构都是相同的，不同的是随设备对象不同而具有不同的内容</em>，这些内容在接下来的编程过程中将会在各种针对设备对象进行的处理中作为处理函数的参数。</p>\n<p>除此之外，还需要为设备的一些功能指定相应的处理函数，例如设备在销毁时将调用哪个函数，在收到  <code>PnP</code>  指令时将调用哪个函数等。</p>\n<p>幸运的是，  <code>WDF</code>  驱动模型框架已经为开发人员做了很多事情，基本上实现了所有功能的标准处理过程，在大部分情况下这些标准处理过程就已经足够了，只需要我们根据自己的要求进行很少的功能处理即可。</p>\n<p>这是  <code>EvtDriverDeviceAdd</code>  函数的的一部分：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 首先需要为这个设备指定一个名词</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// \"\\\\Device\\\\Ramdisk\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>status <span class=\"token operator\">=</span> <span class=\"token function\">WdfDeviceInitAssignName</span><span class=\"token punctuation\">(</span>DeviceInit<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>neDeviceName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> status<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 接下来需要对这个设备进行一些属性的设置，包括设备类型和 IO 操作类型和设备的排他方式</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">WdfDeviceInitSetDeviceType</span><span class=\"token punctuation\">(</span>DeviceInit<span class=\"token punctuation\">,</span>FILE_DEVICE_DISK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">WdfDeviceInitSetIoType</span><span class=\"token punctuation\">(</span>DeviceInit<span class=\"token punctuation\">,</span>WdfDeviceIoDirect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">WdfDeviceInitSetExclusive</span><span class=\"token punctuation\">(</span>DeviceInit<span class=\"token punctuation\">,</span>FALSE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">// 下面来指定这个设备的设备对象扩展</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 这里的 DEVICE_EXTENSION 是一个在头文件中声名的结构体数据类型</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">// 我们使用一个 WDF_OBJECT_ATTRIBUTES 类型的变量并用其设置好 DEVICE_EXTENSION</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token operator\">&amp;</span>deviceAttributes<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  DEVICE_EXTENSION</pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">// 下面我们还将用这个 WDF_OBJECT_ATTRIBUTES 类型的变量来指定这个设备的清除回调函数</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// 这个 WDF_OBJECT_ATTRIBUTES 类型的变量将会在下面建立设备时作为一个参数传进去</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>deviceAttributes<span class=\"token punctuation\">.</span>EvtCleanupCallBack <span class=\"token operator\">=</span> RamDiskEvtDeviceContextCleanup<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">// 到这里，所有的准备工作都已经就绪了，我们可以开始真正建立这个设备了</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">// 建立到的设备被保存到了变量 device 中了</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>status <span class=\"token operator\">=</span> <span class=\"token function\">WdfDeviceCreate</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>DeviceInit<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>deviceAttributes<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>device<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">return</span> status<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">// 这个 pDeviceExtension 是我们声明的一个局部指针变量，将其指向新建立的设备拓展区域</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>pDeviceExtension <span class=\"token operator\">=</span> <span class=\"token function\">DeviceGetExtension</span><span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"如何处理发往设备的请求\"><a class=\"anchor\" href=\"#如何处理发往设备的请求\">#</a> 如何处理发往设备的请求</h3>\n<p>在设备被创建好了之后，如何处理所有可能发送给设备的请求是需要考虑的下一个问题。</p>\n<p>在以往的 WDM 开发中，常用的方式是：<em>开发者把自己实现的回调函数，作为这个设备的功能分发函数</em>。<br />\n此外，一些特殊的功能需求，也可以在回调函数中处理。例如，可以将所有的读 / 写请求都实现为去读 / 写内存，这就是最简单的内存盘。</p>\n<p>上面的处理方式说起来很简单，但是实现时还是需要一些技巧的。<br />\n一种常用的方式是 ** 建立一个或多个队列，将所有发送到这个设备的请求都插入到队列中，由另一个线程去处理队列。** 这是一个典型的生产者 — 消费者模型，这样做的好处是有了一个小小的缓冲，同时还不用担心由缓冲带来的同步问题，因为所有的请求都被队列排队了。</p>\n<p>无独有偶，在 WDF 驱动框架中，微软直接提供了这种处理队列，这样就不用开发人员自己去操心<em>如何建立队列、如何设置同步事件、如何在正确的时间销毁队列了</em>，这可真是一个造福大众的做法。</p>\n<p>为了实现<em>为驱动制作一个处理队列</em>这一目标，在 WDF 驱动框架中需要初始化一个队列配置变量 <code>ioQueueConfig</code> ，这个变量会说明队列的各种属性。<br />\n一种简单的初始化方法是将这个配置变量初始化为<em>默认状态</em>，之后再对一些具有特殊属性的请求注册回调函数，例如为读请求注册回调函数等。<br />\n在这样的初始化之后再为指定设备建立队列，WDF 驱动框架会自动将所有发往这个指定设备的请求都放入队列中处理，同时当请求符合感兴趣的属性（例如读 / 写操作）时会调用之前注册过的处理函数去处理。对每个设备可以建立多个队列，但是在本例中不会讨论多个处理队列的情况。另外，在队列中也具有和设备类似的扩展，下面也会使用到。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 将队列的配置变量初始化为默认值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>      <span class=\"token operator\">&amp;</span>ioQueueConfig<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      WdfIoQueueDispatchSequential</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 我们对读写和 DeviceControl 请求的处理设置为自己的函数，其余的使用默认值</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>ioQueueConfig<span class=\"token punctuation\">.</span>EvtIoDeviceControl <span class=\"token operator\">=</span> RamDiskEvtIoDeviceControl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>ioQueueConfig<span class=\"token punctuation\">.</span>EvtIoRead          <span class=\"token operator\">=</span> RamDiskEvtIoRead<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>ioQueueConfig<span class=\"token punctuation\">.</span>EvtIoWrite         <span class=\"token operator\">=</span> RamDiskEvtIoWrite<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// 指定这个队列的队列对象扩展，这里的 QUEUE_EXTENSION 是一个在头文件中声明好的结构体数据类型</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token operator\">&amp;</span>queueAttributes<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tQUEUE_EXTENSION</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 万事俱备，我们将开始创建队列，将之前创建的设备作为这个队列的父对象</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">// 在这个设备被销毁的同时，该队列也会被销毁，这样就不用担心队列结束的问题了</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>status <span class=\"token operator\">=</span> <span class=\"token function\">WdfIoQueueCreate</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\tdevice<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token operator\">&amp;</span>ioQueueConfig<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\tqueueAttributes<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token operator\">&amp;</span>queue</pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">return</span> status<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">// 将指针 pQueueContext 指向刚刚生成的队列的扩展</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>pQueueContext <span class=\"token operator\">=</span> <span class=\"token function\">QueueGetExtension</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token comment\">// 这里初始化队列扩展里的 DeviceExtension 项，将其</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">// 设置为刚建立的设备拓展指针，这样以后在有队列的地方都</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token comment\">// 可以轻松的获得这个队列对应的设备的设备扩展了</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>pQueueContext<span class=\"token operator\">-></span>DeviceExtension <span class=\"token operator\">=</span> pDeviceExtension<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"用户配置的初始化\"><a class=\"anchor\" href=\"#用户配置的初始化\">#</a> 用户配置的初始化</h3>\n<p>在设备和用来处理设备请求的队列都建立好了之后，接下来就需要初始化与内存盘相关的一些数据结构了。</p>\n<p>对于内存盘来说，在驱动层中就是以刚才建立的那个设备作为代表的，那么自然而然地，内存盘相应的数据结构也应该和这个设备相联系。</p>\n<p>在这里就使用了这个设备的设备扩展来存放这些数据结构的内容，具体而言，这个数据结构就是之前代码中的 <code>DEVICE_EXTENSION</code>  数据结构。</p>\n<p>同时为了给用户提供一些可配置的参数，在注册表中还开辟了一个键用来存放这些可配置参数，这些参数对应到驱动中就成为了一个 <code>DISK_INFO</code>  类型的数据结构，在 <code>DEVICE_EXTENSION</code>  中会有一个成员来表示它。下面先来认识一下这两个数据结构:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_DISK_INFO</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 磁盘的大小，以 Byte (字节) 计算，所以我们的磁盘最大只有 4GB</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    ULONG   DiskSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 磁盘上根文件系统的进入节点</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    ULONG   RootDirEntries<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 磁盘的每个簇由多少个扇区组成</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    ULONG   SectorsPerCluster<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 磁盘的盘符</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    UNICODE_STRING DriveLetter<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span> DISK_INFO<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PDISK_INFO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_DEVICE_EXTENSION</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 用来指向一块内存区域，作为内存盘的实际数据存储空间</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    PUCHAR              DiskImage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// 用来存储内存盘的磁盘 Geometry</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    DISK_GEOMETRY       DiskGeometry<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">// 我们自己定义的磁盘信息结构，在安装时存放在注册表中</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    DISK_INFO           DiskRegInfo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// 盘的符号链接名，这是真正的符号链接名</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    UNICODE_STRING      SymbolicLink<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// DiskRegInfo 中 DriveLetterBuffer 的存储空间，这是用户在注册表中指定的盘符</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    WCHAR               DriveLetterBuffer<span class=\"token punctuation\">[</span>DRIVE_LETTER_BUFFER_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// SymbolicLink 的存储空间</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    WCHAR               DosDeviceNameBuffer<span class=\"token punctuation\">[</span>DOS_DEVNAME_BUFFER_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span> DEVICE_EXTENSION<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PDEVICE_EXTENSION<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在了解了数据结构中各成员对象的用处之后，就可以开始进行这些数据结构的初始化工作了。</p>\n<p>首先需要去注册表中获取用户指定的信息，这里是通过自己实现的一个函数  <code>RamDiskQueryDiskRegParameters</code>  去获取的，这个函数的<em>第一个参数是注册表的路径</em>。<br />\n为了获取这个路径，首先通过  <code>WdfDeviceGetDriver</code>  从之前生成的设备中<em>获取到这个设备对应的驱动对象</em>，然后通过  <code>WdfDriverGetRegistryPath</code>  <em>从这个驱动对象中获取到相应的注册表路径</em>。<br />\n在这里使用的  <code>WdfDeviceGetDriver</code>  和  <code>WdfDriverGetRegistryPath</code>  都是 WDF 库提供的函数，它们的使用方法非常简单，作用也可以直接从函数名称中看出来，一个是通过 WDF 驱动的设备获取相应的驱动对象，而另一个是通过 WDF 驱动的驱动对象来获取注册表路径。</p>\n<p><code>RamDiskQueryDiskRegParameters</code>  函数的<em>第二个参数是一个结构体变量</em>，在这里将要向这个变量里面填写从注册表中获取的值。</p>\n<p><code>RamDiskQueryDiskRegParameters</code>  函数的具体实现比较简单，简单地认为在这个函数调用之后，  <code>pDeviceExtension→DiskRegInfo</code>  中的各成员变量就已经被初始化成了注册表中对应的值</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 将生成的设备的设备拓展中相应的 UNICODE_STRING 初始化</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>pDeviceExtension<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DriveLetter<span class=\"token punctuation\">.</span>Buffer <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token punctuation\">(</span>PWSTR<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>DriveLetterBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>pDeviceExtension<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DriveLetter<span class=\"token punctuation\">.</span>MaximumLength <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>pDeviceExtension<span class=\"token operator\">-></span>DriveLetterBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 从系统为本驱动提供的注册表键中获取我们需要的信息</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">RamDiskQueryDiskRegParameters</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token function\">WdfDriverGetRegistryPath</span><span class=\"token punctuation\">(</span><span class=\"token function\">WdfDeviceGetDriver</span><span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>DiskRegInfo</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>从注册表中获取相应的参数只是初始化工作的第一步。由于这是一个使用内存来作为存储介质的模拟磁盘，因此需要分配出一定大小的内存空间来模拟磁盘空间，这个大小是由注册表中的磁盘大小参数所指定的，在以后的内容中，这块空间将被称为 Ramdisk 的磁盘镜像。</p>\n<p><em>这里需要特别说明的是，在 Windows 内核中，可以分配两种内存：一种是分页内存；另一种是非分页内存。分页内存的特点是它可能只是一个标识，实际存储的数据可能被放在磁盘上的页面文件中，在访问这个内存时系统会发出缺页中断，然后由复杂的页面管理机制将所缺的页面调入内存中。而非分页内存则相反，它永远在内存中，不会被换出到磁盘上。这样的特点也导致了分页内存可以分配得比较多，而非分页内存只能分配很少一部分。这里为了简单起见，全部分配非分页内存，这样的好处是在任何时候都不用担心要访问的地址数据是否真的在内存里，还是会引发复杂的缺页处理流程，这些流程将会导致需要在其他处理函数中作多方面的考虑。在分配内存的函数中还会出现一个内存的 TAG 值，这个值用来区分这个内存是谁分配的，在这里会将这个值赋成本驱动特殊的值，从而区别于其他的驱动所分配的内存。</em></p>\n<p>​在分配了内存之后，磁盘就有了存储空间，但是就好像任何新磁盘一样。这个磁盘需要被分区，格式化。需要我们自己去格式化操作，因为内核中是没有地方调用  <code>format</code>  命令的。具体的操作会在下面介绍。这里先知道  <code>RamDiskFormatDisk</code>  起的作用是把内存介质的磁盘格式化就可以了</p>\n<h3 id=\"链接给应用程序\"><a class=\"anchor\" href=\"#链接给应用程序\">#</a> 链接给应用程序</h3>\n<p>至此，程序建立了设备，建立了处理发往这个设备的队列，读取了用户的配置，并按照这个配置初始化了所需的内存空间和其他一些相关参数。</p>\n<p>接下来需要做的事情就是将它暴露给应用层以供使用。</p>\n<p>在 Windows 中的各盘符，例如 “C:”“D:” 实际上都是一个叫作符号链接的东西，应用层的代码不能够直接访问在内核中建立的设备，但是可以访问符号链接，所以在这里只需要用符号链接指向这个设备，便可以将对符号链接的访问指向这个设备了。</p>\n<p>这里所要做的是根据用户配置中选定的盘符去建立符号链接，将这个盘符和在这一节最开始所建立的符号链接联系起来。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 分配用户指定大小的非分页内存，并使用我们自己的内存 TAG 值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>pDeviceExtension<span class=\"token operator\">-></span>DiskImage <span class=\"token operator\">=</span> <span class=\"token function\">ExAllocatePoolWithTag</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>      NonPagedPool<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      pDeviceExtension<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      RAMDISK_TAG</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\">// 下面的代码只有在内存分配成功时才会运行</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pDeviceExtension<span class=\"token operator\">-></span>DiskImage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      UNICODE_STRING deviceName<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      UNICODE_STRING win32Name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token comment\">// 这里调用我们自己实现的函数去初始化磁盘</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token function\">RamDiskFormatDisk</span><span class=\"token punctuation\">(</span>pDeviceExtension<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      status <span class=\"token operator\">=</span> STATUS_SUCCESS<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      <span class=\"token comment\">// 初始化一个内容为 \"\\\\DosDevices\\\\\" 的 UNICODE_STRING 变量</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      <span class=\"token function\">RtlInitUnicodeString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>win32Name<span class=\"token punctuation\">,</span> DOS_DEVICE_NAME<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      <span class=\"token comment\">// 初始化一个内容为 \"\\\\Device\\\\Ramdisk\" 的 UNICODE_STRING 变量</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>      <span class=\"token comment\">// 这个变量没有用处这里只是为了保持原文档的完整性</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token function\">RtlInitUnicodeString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>deviceName<span class=\"token punctuation\">,</span> NT_DEVICE_NAME<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token comment\">// 在这里我们首先准备好用来存储符号链接名的 UNICODE_STRING 变量</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>      pDeviceExtension<span class=\"token operator\">-></span>SymbolicLink<span class=\"token punctuation\">.</span>Buffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PWSTR<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>          <span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>DosDeviceNameBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>      pDeviceExtension<span class=\"token operator\">-></span>SymbolicLink<span class=\"token punctuation\">.</span>MaximumLength <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>          <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>pDeviceExtension<span class=\"token operator\">-></span>DosDeviceNameBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>      pDeviceExtension<span class=\"token operator\">-></span>SymbolicLink<span class=\"token punctuation\">.</span>Length <span class=\"token operator\">=</span> win32Name<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>      <span class=\"token comment\">// 将符号链接名的开头设置为 \"\\\\DosDevices\\\\\" ，这是所有符号链接共有的前缀</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token function\">RtlCopyUnicodeString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>SymbolicLink<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>win32Name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>      <span class=\"token comment\">// 在上面赋值好的前缀后面连接我们从用户配置中读出来的用户指定的盘符</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>      <span class=\"token function\">RtlAppendUnicodeStringToString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>SymbolicLink<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                                      <span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DriveLetter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>      <span class=\"token comment\">// 现在符号链接名已经准备好，我们调用 WDF 驱动框架模型提供的 WdfDeviceCreateSymbolicLink 函数来为之前生成的设备简历符号链接</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>      status <span class=\"token operator\">=</span> <span class=\"token function\">WdfDeviceCreateSymbolicLink</span><span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                                            <span class=\"token operator\">&amp;</span>pDeviceExtension<span class=\"token operator\">-></span>SymbolicLink<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>  <span class=\"token comment\">// 返回状态，函数完结</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token keyword\">return</span> status<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h3>\n<p>到此为止，已经完整地分析了在  <code>Ramdisk</code>  驱动中  <code>EvtDriverDeviceAdd</code>  函数的具体实现。<strong>可以发现这个函数里面建立了设备对象，为了处理这个设备将要收到的各种请求，又建立了处理队列；同时由于对这个设备所需要处理的读 / 写和  <code>DeviceIoControl</code>  请求有自己的处理需求，因此没有使用系统默认的处理函数，而是注册了自己实现的 3 个处理函数。之后根据用户写在注册表中的配置参数初始化了一些相关属性，为设备存储数据准备好了内存，最后给设备建立了符号链接以便于应用层的代码访问。</strong></p>\n<p>至此，Ramdisk 的磁盘设备已经建立起来了，它在内核中代表了这个内存盘，而且由于这个设备已经暴露给了应用层的代码，各种各样的访问和请求必将接踵而至。<br />\n但是在分析如何处理这些请求之前，还需要先对磁盘卷的结构做一番介绍。</p>\n<h2 id=\"fat1216磁盘卷初始化\"><a class=\"anchor\" href=\"#fat1216磁盘卷初始化\">#</a> FAT12/16 磁盘卷初始化</h2>\n<h3 id=\"磁盘卷结构简介\"><a class=\"anchor\" href=\"#磁盘卷结构简介\">#</a> 磁盘卷结构简介</h3>\n<p>微软操作系统对磁盘的管理，包括分区的划分、每种文件系统的不同特性等。不过在这个驱动中，我们所面对的只是一个最简单的磁盘结构，即一个<em>分区基于 FAT12/16 的磁盘</em>。</p>\n<p>下面结合<strong>简单的磁盘结构</strong>和这个驱动的特性，对 FAT12/16 磁盘卷进行学习。</p>\n<p>Windows 磁盘卷首先继承了它所在磁盘的特性，这些特性是由硬件决定的，不可设置，不可更改。<br />\n这些特性包括如下内容。</p>\n<ol>\n<li>每扇区的字节数。扇区是磁盘读 / 写的基本单位，硬盘的物理设计导致它不能一次读 / 写一个字节，而是一次最少读 / 写一个扇区，现在几乎所有的硬盘扇区大小都是 512 字节。</li>\n<li>每磁道的扇区数。硬盘的盘片是圆形的，读者可以认为每个磁道都是一个圆圈，整个盘片被划分成了多个同心圆，即多个磁道。硬盘设计时规定每个磁道被划分成同样数目的扇区。</li>\n<li>每柱面的磁道数。硬盘不仅是由一个盘片组成的，当硬盘具有多个盘片时，读者可以认为所有盘片的同样位置的磁道组成了一个圆柱体，这就是一个柱面。这个参数实际上说明了硬盘的所有盘片加起来有多少个面（可能会遇见只有一个面的盘片，为了市场划分故意不在一个面上做磁性介质）。</li>\n<li>柱面数。表示硬盘的一个圆形盘片能够划分成多少个同心圆，这个数字随着硬盘技术的提高在不断地增大，因为磁盘的物理大小是固定的，那么柱面数越多就说明每个磁道越细，所需要的磁头分辨率也越高。</li>\n</ol>\n<p>这里可以参考《30 天制作操作系统》中的这张图：</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>磁盘结构是由制造过程中的物理结构决定的，而操作系统对磁盘的管理主要通过文件系统来实现，这是一种逻辑上的结构。<br />\n文件系统是建立在软件能够读 / 写磁盘任意扇区基础上的一种数据组织结构。在微软公司的操作系统中，常见的文件系统包括了 FAT12、FAT16、FAT32 和 NTFS 等。</p>\n<p>关于 FAT32 文件系统的详细说明可以参考其他资料，但是总体来说，FAT32 文件系统与 FAT12/16 文件系统的区别不是很大。</p>\n<p>至于 NTFS 文件系统，现在还没有一个完善的解决方案能够以第三方的代码来读 / 写它，也就是说，NTFS 文件系统的特性还没有被搞清楚，我们在任何时候都应该通过微软提供的文件系统驱动来读 / 写它，直到可信的第三方解决方案推出。</p>\n<p>在 FAT12/16 文件系统中，有几个参数需要了解一下。</p>\n<ul>\n<li>\n<p><strong>MBR</strong>。 MBR 是 Master Boot Record（主引导记录）的简称。<em>它位于整个磁盘的第一个扇区，大小正好是一个扇区的大小</em>，MBR 的起始处是一段程序，在 BIOS 的代码执行到最后时，BIOS 会将这段程序加载到内存中并开始执行。在这段程序的后面是一个硬盘分区表，<em>用于记录当前磁盘具体的分区信息</em>。由于 Ramdisk 驱动只是用来建立一个可用的磁盘卷，并不要求这个卷可以引导和具有其他一些特征，所以在 Ramdisk 的磁盘镜像中并不会看到 MBR 部分的存在，在这里将 Ramdisk 生成的磁盘卷当作一个分区即可。</p>\n</li>\n<li>\n<p><strong>DBR</strong>。 DBR 是 DOS Boot Record（操作系统引导记录）的简称。上面讲到过，在 MBR 的硬盘分区表中会记录每个分区的信息，包括起始位置等；而 DBR 就存在于这个起始位置指向的第一个扇区里，DBR 里面包括了有效的引导程序、厂商标志、描述数据区等。引导程序是一段用来加载真正操作系统的程序，在 DBR 的最开始是一个跳转指令，跳转到 DBR 后面一点的引导程序处。厂商标志又叫作 OEM 串，一般是由格式化程序所填写的。数据描述区又称为 BPB 的数据块，记录了分区的众多信息，这些信息用于系统在为这个逻辑盘建立文件系统时做初始参数，例如文件系统格式、根目录大小和簇大小等。作为文件系统的一个组成部分，DBR 是由操作系统的格式化程序建立的，在文件系统驱动操作任何一个磁盘卷时，这一部分的信息将被读取并作为文件系统在这个磁盘卷上的参数使用，所以在 Ramdisk 驱动中，DBR 部分是需要存在的。</p>\n</li>\n<li>\n<p><strong>FAT 区</strong>。 FAT 是 File Allocation Table（文件分配表）的简称。它位于 DBR 之后，并且以一式两份的形式连续保存。FAT 表实际上是一个链表，它的每个表项的编号都代表磁盘上的一个簇，每个表项的内容都是另一个簇的编号，而一条这样完整的链就代表了一个文件在磁盘上所占的所有的簇。FAT 表的第 0 项和第 1 项是被保留的，从第 2 项开始用来记录某个文件所在的位置。由上面内容可以知道，FAT 表的大小只和磁盘的大小及这个磁盘上的文件系统对每个簇的大小的定义相关。这里需要说明的是，FAT12 和 FAT16 的唯一区别就是一个 FAT 表的表项中能使用几位做存储空间，由于这个存储空间存储的就是另一个表项的索引值，所以这实际上就代表了表项个数的上限，换句话说，代表了这个文件系统中最大的簇的个数。如果用 12 个位来表示一个表项的索引值，那么这个索引值的上限就是 4096；而在 FAT16 文件系统中，最多可以有 65536 个簇。</p>\n</li>\n<li>\n<p><strong>根目录入口点</strong>。 上面说了 FAT 是多个链表的集合体，其中的每一条链代表了一个文件，但是这些链的起始点是如何确定的呢？这就要用到这里所说的根目录入口点了。多个根目录入口点形成了一个表，这个表紧跟着 FAT 表存储，这个表的每个表项代表了根目录下的一个文件或者一个目录，这个表项里面记载了很多相关的信息，例如文件或者目录的名字、属性和修改日期等，最重要的是记录了这个文件或者目录在 FAT 表中的起点，这样就可以通过查询 FAT 表找到这个文件或者目录的所有簇，进而获取所有的数据。而通过查询每个目录的目录项内容又可以知道这个目录下面存储的文件在 FAT 表中的对应位置，这样就可以遍历到磁盘上的所有文件了。</p>\n</li>\n</ul>\n<p>以上所说的磁盘结构和 FAT12/16 文件系统的一些结构在这个驱动中并不会全部用到。由于本驱动的目的只是用来演示，所以并不需要完善的磁盘特性，更何况这个磁盘每次开机之后才会建立起来，也不可能用它来进行引导，所以并不需要与之相关的数据和信息。在这里对这些知识能有所了解即可。</p>\n<h3 id=\"ramdisk对磁盘的初始化\"><a class=\"anchor\" href=\"#ramdisk对磁盘的初始化\">#</a> Ramdisk 对磁盘的初始化</h3>\n<p>在 Ramdisk 驱动中的  <code>EvtDriverDeviceAdd</code>  类函数里会调用  <code>RamDiskFormatDisk</code>  函数对所分配的用于做磁盘镜像的内存空间进行初始化，在简单了解了磁盘卷结构之后，来学习下这个函数是如何初始化这个磁盘映像空间的。</p>\n<p>首先来了解一下这个函数的本地变量声明，为了在分析过程中有所参照。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 一个指向磁盘启动扇区的指针</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>PBOOT_SECTOR bootSector <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PBOOT_SECTOR<span class=\"token punctuation\">)</span> devExt<span class=\"token operator\">-></span>DiskImage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 指向 FAT 第一个 FAT 表的指针</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>PUCHAR\t\tfirstFatSector<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 用于记录有多少个根目录日寇点</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>ULONG rootDirEntries<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 用于记录每个簇由多少扇区组成</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>ULONG sectorsPerCluster<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 用于记录 FAT 文件系统的类型，是 FAT12 还是 16</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>USHORT fatType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// 用于记录在 FAT 表里一共有多少个表项</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>USHORT fatEntries<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 用于记录一个 FAT 表需要占用多少个扇区来存储</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>USHORT fatSectorCnt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 用于指向第一个根目录入口点</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>PDIR_ENTRY rootDir<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 用于确定这个函数是可以存取分页内存的</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">PAGED_CODE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">// 用于确定这个盘的引导扇区的大小确实是一个扇区大小</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token function\">ASSERT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>BOOT_SECTOR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">512</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">// 用于确定我们操作的磁盘不是一个不可用的指针</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token function\">ASSERT</span><span class=\"token punctuation\">(</span>devExt<span class=\"token operator\">-></span>DiskImage <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">// 清空磁盘镜像</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token function\">RtlZeroMemory</span><span class=\"token punctuation\">(</span>devExt<span class=\"token operator\">-></span>DiskImage<span class=\"token punctuation\">,</span>devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来格式化函数开始初始化一个保存在磁盘设备的设备扩展中的数据结构 <code>DiskGeometry</code> 。从名字就可以看出，这个数据结构保存了很多和磁盘物理结构相关的信息，也就是前面所说的磁盘特性。</p>\n<p>这个数据结构是 WinDDK 所定义好的，几乎适用于所有的磁盘。看一下这个数据结构的定义。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> struce _DISK_GEOMETRY<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 有多少个柱面</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    LARGE_INTEGER Cylinders<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 磁盘介质的类型</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    MEDIA_TYPE MediaType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 每个柱面有多少磁道，也就是有多少个盘片</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    ULONG TracksPerCylinder<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 每个磁道有多少扇区</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    ULONG SectorsPerTrack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 每个扇区有多少字节</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    ULONG BytePerSector<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span>DISK_GEOMETRY<span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>PDISK_GEOMETRY<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个数据结构被放在了磁盘设备的设备扩展中，在今后的很多场合中都作为磁盘的参数被访问。<br />\n接下来看看是如何初始化这个结构体的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 每个扇区有 512 个字节</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>BytesPerSector <span class=\"token operator\">=</span> <span class=\"token number\">512</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 每个磁道有 32 个扇区</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>SectorsPerTrack <span class=\"token operator\">=</span> <span class=\"token number\">32</span><span class=\"token punctuation\">;</span>     </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 每个柱面有 2 个磁道</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>TracksPerCylinder <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 柱面数目有磁盘的总容量计算得到</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>Cylinders<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">=</span> devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize <span class=\"token operator\">/</span> <span class=\"token number\">512</span> <span class=\"token operator\">/</span> <span class=\"token number\">32</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 磁盘的介质类型使我们自己定义的 RAMDISK_MEDIA_TYPE</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>MediaType <span class=\"token operator\">=</span> RAMDISK_MEDIA_TYPE<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在初始化了磁盘的物理参数之后，这里初始化一个文件系统和磁盘相关的参数 ——<strong> 根目录入口点数</strong>，这个参数决定了根目录中能够存在多少个文件和子目录。还要初始化的还有每个簇由多少个扇区组成，这是根据用户指定的数目来初始化的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 根据用户指定的值对用户的根目录项的数据进行初始化</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>rootDirEntries <span class=\"token operator\">=</span> devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>RootDirEntries<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 每个簇有多少扇区的初始化</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>sectorsPerCluster <span class=\"token operator\">=</span> devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>SectorsPerCluster<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 由于根目录入口点只是用 32 个字节，，但是最少占用一个扇区，这里为了充分利用空间，在用户指定的数目不合适时会修正这个数目，以使扇区空间得到充分的利用</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rootDirEntries <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>DIR_ENTRIES_PER_SECTOR <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    rootDirEntries <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">(</span>rootDirEntries <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>DIR_ENTRIES_PER_SECTOR <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token operator\">~</span> <span class=\"token punctuation\">(</span>DIR_ENTRIES_PER_SECTOR <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在格式化函数的开头可以看到，  <code>bootSector</code>  指针直接指向了磁盘镜像的首地址，联系之前讲解过的磁盘和文件系统结构，通过之前的说明可以发现在磁盘镜像最前面存储的应该是这个分区的 DBR，也就是说 ，  <code>bootSector</code>  指针指向的是这个磁盘卷的 DBR。</p>\n<p>下面看一下 <code>bootSector</code>  结构体的实际数据结构，值得注意的是，这也是标准 DBR 的结构。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">pack</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span>  <span class=\"token class-name\">_BOOT_SECTOR</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    UCHAR       bsJump<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// x86 jmp instruction, checked by FS</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    CCHAR       bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// OEM name of formatter</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    USHORT      bsBytesPerSec<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Bytes per Sector</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    UCHAR       bsSecPerClus<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// Sectors per Cluster</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    USHORT      bsResSectors<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// Reserved Sectors</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    UCHAR       bsFATs<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// Number of FATs - we always use 1</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    USHORT      bsRootDirEnts<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Number of Root Dir Entries</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    USHORT      bsSectors<span class=\"token punctuation\">;</span>          <span class=\"token comment\">// Number of Sectors</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    UCHAR       bsMedia<span class=\"token punctuation\">;</span>            <span class=\"token comment\">// Media type - we use RAMDISK_MEDIA_TYPE</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    USHORT      bsFATsecs<span class=\"token punctuation\">;</span>          <span class=\"token comment\">// Number of FAT sectors</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    USHORT      bsSecPerTrack<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Sectors per Track - we use 32</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    USHORT      bsHeads<span class=\"token punctuation\">;</span>            <span class=\"token comment\">// Number of Heads - we use 2</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    ULONG       bsHiddenSecs<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// Hidden Sectors - we set to 0</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    ULONG       bsHugeSectors<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Number of Sectors if > 32 MB size</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    UCHAR       bsDriveNumber<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Drive Number - not used</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    UCHAR       bsReserved1<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// Reserved</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    UCHAR       bsBootSignature<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// New Format Boot Signature - 0x29</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    ULONG       bsVolumeID<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// VolumeID - set to 0x12345678</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    CCHAR       bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// Label - set to RamDisk</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    CCHAR       bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// File System Type - FAT12 or FAT16</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    CCHAR       bsReserved2<span class=\"token punctuation\">[</span><span class=\"token number\">448</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// Reserved</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    UCHAR       bsSig2<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// Originial Boot Signature - 0x55, 0xAA</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span>   BOOT_SECTOR<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PBOOT_SECTOR<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>……</pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">pack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr></table></figure><p>在谭文一书中对各个成员的中文解释为：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 跳转指令，跳转到 DBR 中的引导程序</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>UCHAR bsJump<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 该卷的 OEM 名称</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>CCHAR bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 每个扇区有多少字节</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>USHORT bsBytesPerSec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 每个簇有多少扇区</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>UCHAR bsSecPerClus<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 保留扇区数据，指的是第一个 FAT 表开始之前的扇区数，也包括 DBR 本身</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>USHORT bsResSector<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// 这个卷有多少个 FAT 表</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>USHORT bsFATs<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 这个卷的根目录入口点有几个</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>USHORT bsRootEntrents<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 这个卷一共有多少个扇区，如果大于 65535 个扇区，则该字段为 0</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>USHORT bsSectors<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 这个卷的介质类型</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>UCHAR bsMedia<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">// 每个 FAT 表占用多少个扇区</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>USHORT bsFATsecs<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">// 每个磁道有多少个扇区</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>USHORT bsSecPerTrack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">// 有多少个磁头</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>USHORT bsHeads<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">// 有多少个隐藏扇区</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>ULONG bsHiddenSecs<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">// 一个卷超过 65535 个扇区时，会使用这个字段来说明总扇区数</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>ULONG bsHugeSectors<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">// 驱动器编号</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>UCHAR bsDriverNumber<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">// 保留字段</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>UCHAR bsReserved1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">// 磁盘扩展引导区标签，Windows 要求这个标签为 0x28 或者 0x29</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>UCHAR bsBootSignature<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token comment\">// 磁盘卷 ID</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>ULONG bsVolumeID<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token comment\">// 磁盘卷标</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>CCHAR bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\">// 磁盘上的文件系统类型</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>CCHAR bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token comment\">// 保留字段</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>CCHAR bsReserved2<span class=\"token punctuation\">[</span><span class=\"token number\">448</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token comment\">//DBR 结束签名</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>UCHAR bsSig2<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>了解了这个结构体后就要了解如何初始化这个结构体了。初始化这个数据结构是通过向磁盘镜像的起始位置填充指定数据来完成的。</p>\n<p>在下面的程序段中可以看到，对于 FAT12 和 FAT16 相同的结构体成员是如何初始化的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// We need to have the 0xeb and 0x90 since this is one of the checks the file system recognizer uses</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 我们需要 0xeb 和 0x90，因为这是文件系统识别器使用的检查之一</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 对一开始的跳转指令成员填入硬编码，这是 windows 系统指定的</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsJump<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0xeb</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsJump<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0x3c</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsJump<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0x90</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// Set OemName to \"RajuRam \"</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// NOTE: Fill all 8 characters, eg. sizeof(bootSector->bsOemName);</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// 注：填写全部 8 个字符，</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// OEM 名称成员，本驱动的作者填入了他的名字，我们可以填写任意名称</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'R'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'j'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'u'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'R'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'m'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsOemName<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// 每个扇区有多少个字节，这个成员的数值直接取自之前初始化的磁盘信息数据结构</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsBytesPerSec <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SHORT<span class=\"token punctuation\">)</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>BytesPerSector<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">// 这个卷只有一个保留扇区，既 DBR 本身</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsResSectors  <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">// 和正常的卷不同，为了节省空间，我们只放一份 FAT 表，而不是通常的两份</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFATs        <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">// 根目录入口点数由之前的计算得知</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsRootDirEnts <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>USHORT<span class=\"token punctuation\">)</span>rootDirEntries<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\">// 这个磁盘的总扇区书有磁盘总大小和每个扇区的字节数计算得到</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsSectors     <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>USHORT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize <span class=\"token operator\">/</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                                      devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>BytesPerSector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">// 这个磁盘的介质类型由之前初始化的磁盘信息得到</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsMedia       <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>UCHAR<span class=\"token punctuation\">)</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>MediaType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token comment\">// 每个簇有多少个扇区由之前的计算初始化得到</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsSecPerClus  <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>UCHAR<span class=\"token punctuation\">)</span>sectorsPerCluster<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来开始计算这个磁盘 FAT 表所占用的空间。</p>\n<p>FAT 表里面存储的是一个将很多簇串联起来的链表，那么 FAT 表的表项数量就是磁盘上实际用来存储数据的簇的数量，而这个簇的数量又是由磁盘总扇区数减去用来存储其他数据的扇区数之后除以每个簇的扇区数得到的。</p>\n<p>下面看一下在实际程序中是如何计算的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// FAT 表的表项数目是总扇区数减去保留的扇区数，再减去根目录入口点占据的扇区数，再除以每簇占据的扇区数得到簇的数量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 最后 + 2 因为 FAT 表的前两项是保留的</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>fatEntries <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token punctuation\">(</span>bootSector<span class=\"token operator\">-></span>bsSectors <span class=\"token operator\">-</span> bootSector<span class=\"token operator\">-></span>bsResSectors <span class=\"token operator\">-</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            bootSector<span class=\"token operator\">-></span>bsRootDirEnts <span class=\"token operator\">/</span> DIR_ENTRIES_PER_SECTOR<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                bootSector<span class=\"token operator\">-></span>bsSecPerClus <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>根据这个表项数量首先可以决定到底使用 FAT12 还是 FAT16 文件系统</strong>。<br />\n在决定了使用哪种文件系统之后，就可以算出每个 FAT 表的表项需要占用多少空间，进而算出整个 FAT 表所占用的扇区数。在实际的计算过程中还需要做一些小修正，这是因为在考虑了 FAT 表占用的空间之后，总的 FAT 表的表项数目可能有一些小出入。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 如果 FAT 表的表项数大于 4087，就使用 FAT16 文件系统，反之使用 FAT12 文件系统</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fatEntries <span class=\"token operator\">></span> <span class=\"token number\">4087</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        fatType <span class=\"token operator\">=</span>  <span class=\"token number\">16</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 做修正</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        fatSectorCnt <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fatEntries <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">511</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">512</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        fatEntries   <span class=\"token operator\">=</span> fatEntries <span class=\"token operator\">+</span> fatSectorCnt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        fatSectorCnt <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fatEntries <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">511</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">512</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        fatType <span class=\"token operator\">=</span>  <span class=\"token number\">12</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 做修正</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        fatSectorCnt <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fatEntries <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">511</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">512</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        fatEntries   <span class=\"token operator\">=</span> fatEntries <span class=\"token operator\">+</span> fatSectorCnt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        fatSectorCnt <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fatEntries <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">511</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">512</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在上面的计算过程之后获得了文件系统的类型和 FAT 表需要占用的扇区数目。</p>\n<p>下面可以接着初始化 DBR 的数据结构了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 初始化 FAT 表所占用的分区数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFATsecs       <span class=\"token operator\">=</span> fatSectorCnt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 初始化 DBR 中每个磁道的扇区数</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsSecPerTrack   <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>USHORT<span class=\"token punctuation\">)</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>SectorsPerTrack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 初始化磁头数，也就是每个柱面的磁道数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsHeads         <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>USHORT<span class=\"token punctuation\">)</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>TracksPerCylinder<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 初始化启动签名，Windows 要求是 0x28 或 0x29</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsBootSignature <span class=\"token operator\">=</span> <span class=\"token number\">0x29</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 随便填写一个卷 ID</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsVolumeID      <span class=\"token operator\">=</span> <span class=\"token number\">0x12345678</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// 将卷标设置为 “RamDisk”</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'R'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'m'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'D'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'i'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">'k'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsLabel<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">// 根据我们之前计算得出的结果来悬着到底是 FAT12 还是 FAT16 文件系统</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'F'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'T'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span> fatType <span class=\"token operator\">==</span> <span class=\"token number\">16</span> <span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">'6'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">// 签署 DBR 最后的标志，0x55AA</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsSig2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0x55</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>bootSector<span class=\"token operator\">-></span>bsSig2<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0xAA</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>DBR 初始化完毕。</p>\n<p>在 FAT12/16 文件系统中，DBR 之后紧接着的是 FAT 表，对于 FAT 表的初始化很简单，只需要在 FAT 表的第 1 个表项内填写介质标识即可。同时要注意的是，FAT12 和 FAT16 的表项长度不同</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 定位到 FAT 表的起始点，这里的定位方式是利用了 DBR 只有一个扇区这一条件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>firstFatSector    <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PUCHAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>bootSector <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 填写介质类型标识</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>firstFatSector<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>UCHAR<span class=\"token punctuation\">)</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>MediaType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>firstFatSector<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>firstFatSector<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 注意如果是 FAT16，那么每个 FAT 表的表项是 4 个字节</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fatType <span class=\"token operator\">==</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    firstFatSector<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 FAT 表之后，就是根目录入口点了。</p>\n<p>在 FAT12/16 文件系统中，根目录入口点的数据结构定义如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">pack</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span>  <span class=\"token class-name\">_DIR_ENTRY</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// 文件名</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  UCHAR       deName<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// File Name</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\">// 文件扩展名</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  UCHAR       deExtension<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// File Extension</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token comment\">// 文件属性</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  UCHAR       deAttributes<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// File Attributes</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token comment\">// 系统保留</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  UCHAR       deReserved<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// Reserved</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token comment\">// 文件建立的时间</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  USHORT      deTime<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// File Time</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token comment\">// 文件建立的日期</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  USHORT      deDate<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// File Date</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token comment\">// 文件的第一个簇的编号</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  USHORT      deStartCluster<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// First Cluster of file</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token comment\">// 文件大小</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  ULONG       deFileSize<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// File Length</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span>DIR_ENTRY<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PDIR_ENTRY<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">pack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr></table></figure><p>在 FAT12/16 文件系统中，通常第一个根目录入口点存储了一个最终被作为卷标的目录入口点，这里将其初始化，在这之后，这个磁盘卷就算是被格式化完毕了，也就可以拿来使用了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 由于紧跟着 FAT 表，所以根目录入口点的表的起始位置很容易定位</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>rootDir <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PDIR_ENTRY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>bootSector <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> fatSectorCnt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 初始化卷标</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'M'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'S'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'-'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'R'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'M'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'D'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deName<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'R'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">// Set device extension name to \"IVE\"</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// NOTE: Fill all 3 characters, eg. sizeof(rootDir->deExtension);</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deExtension<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'I'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deExtension<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'V'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deExtension<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'E'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 将这个入口点的属性设置为卷标属性</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>rootDir<span class=\"token operator\">-></span>deAttributes <span class=\"token operator\">=</span> DIR_ATTR_VOLUME<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"驱动中的请求处理\"><a class=\"anchor\" href=\"#驱动中的请求处理\">#</a> 驱动中的请求处理</h2>\n<p><strong>WDF 驱动框架会将所有发往之前建立的磁盘设备的请求都排队放入已经建立的队列中，而在放入队列后绝大多数请求都得到了合适的处理</strong>，由于我们对读 / 写和 DeviceIoControl 请求注册了回调函数，所以队列会将这些请求交给注册的回调函数去处理。</p>\n<p>回调函数在收到请求之后，只能执行下面列举的 4 种操作中的一种，但是不能够忽略这个请求。</p>\n<p>这 4 种操作如下。</p>\n<ol>\n<li>重新排队。回调函数可以把这个请求放到另一个队列里去等待其他的处理函数处理。</li>\n<li>完成请求。回调函数可以对这个请求做自己的一些处理，并且在处理完毕之后完成它。这也是功能性驱动最常见的一种处理方式。</li>\n<li>撤销请求。回调函数可以要求撤销这个请求。</li>\n<li>转发请求。回调函数可以把这个请求转发给其他设备。</li>\n</ol>\n<p>​在 Windows 系统当中，设备之间是一种层叠的关系，在这个磁盘设备之上还会有文件系统设备，一般应用程序的访问都应该是访问文件系统设备，而文件系统设备会负责做文件系统方面的维护。比如对 FAT 表的维护、对文件的读写等，而这些操作最终都会转换成对磁盘的读写发往磁盘设备。</p>\n<h3 id=\"读写请求\"><a class=\"anchor\" href=\"#读写请求\">#</a> 读 / 写请求</h3>\n<p>读 / 写请求的回调函数原型如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RamDiskEvtIoRead</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN WDFQUEUE Queue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN WDFREQUEST Request<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    IN size_t Length</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">RamDiskEvtIoWrite</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    IN WDFQUEUE Queue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    IN WDFREQUEST Request<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    IN size_t Length</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这两个函数没有返回值。<br />\n它们的第一个参数是一个队列对象，这个对象说明了这个请求的来源；<br />\n第二个参数则是具体的请求；<br />\n最后一个参数是<strong>读 / 写请求的回调函数所特有的</strong>，用来说明需要读或者写多少个字节的内容</p>\n<p><em>之前建立队列时曾经将磁盘设备的设备扩展和队列的扩展联系起来</em>，在这里就可以看出它的用处 ——<strong> 我们可以轻易地在这些回调函数里通过队列对象获取到磁盘设备的设备扩展，进而获取到所有的相关参数</strong>。</p>\n<p><em>对于一个磁盘设备来说，读 / 写请求就是要读 / 写磁盘上的某一段区域的内容，这个区域由起始点（offset）和长度（length）来划定，长度已经由回调函数的参数提供，而起始点就要通过 WDF 驱动框架提供的各种函数在第二个参数 —— 请求参数中获取了。读 / 写请求还有另外一个重要的参数就是缓冲区，它由系统提供，用来存放读出来的数据或者需要写入的数据，这个参数也需要从请求参数中获取。</em></p>\n<p>在获取了所有必需的参数之后，作为以内存为介质的模拟磁盘设备来说，只需要简单地将内存镜像中适当地点、适当长度的数据拷贝到读缓冲区中，或者将写缓冲区中的数据拷贝到内存镜像中即可，这也就是作为一个内存盘来说，针对于标准磁盘读 / 写请求的特殊处理。</p>\n<p>在真实应用中，在磁盘设备之上的文件系统设备会根据 FAT 表等数据结构，将对文件的访问转换成对磁盘设备的访问，而磁盘对于上层来说，就是一个起始位置为 0、总长度为磁盘卷总大小的扁平的寻址空间，任何由文件系统转换过来的访问都应该在这个空间之内。</p>\n<p>下面看一下读请求的具体处理流程：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RamDiskEvtIoRead</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN WDFQUEUE Queue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN WDFREQUEST Request<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    IN size_t Length</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token comment\">// 从队列的扩展中获取到对应的磁盘设备的扩展</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  PDEVICE_EXTENSION      devExt <span class=\"token operator\">=</span> <span class=\"token function\">QueueGetExtension</span><span class=\"token punctuation\">(</span>Queue<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>DeviceExtension<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token comment\">// 用于保存各种函数返回值的状态变量</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  NTSTATUS               Status <span class=\"token operator\">=</span> STATUS_INVALID_PARAMETER<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token comment\">// 用于获取请求参数的变量</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  WDF_REQUEST_PARAMETERS Parameters<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token comment\">// 用于获取读请求起始地址的变量，这是一个 64 位的数据</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  LARGE_INTEGER          ByteOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token comment\">// 这是一个用于获取缓冲区的内存句柄</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  WDFMEMORY              hMemory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token comment\">// 初始化参数变量，为之后从请求参数中获取各种信息做准备</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token function\">WDF_REQUEST_PARAMETERS_INIT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>Parameters<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token comment\">// 从请求参数中获取信息</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  <span class=\"token function\">WdfRequestGetParameters</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>Parameters<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  <span class=\"token comment\">// 将请求参数中读的起始位置取出来</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  ByteOffset<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">=</span> Parameters<span class=\"token punctuation\">.</span>Parameters<span class=\"token punctuation\">.</span>Read<span class=\"token punctuation\">.</span>DeviceOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>  <span class=\"token comment\">// 这里是自己实现的一个参数检查函数。由于读取的范围不能超过磁盘镜像的大小</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token comment\">// 并且必须是扇区对齐，所以这里需要有一个参数检查。</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">RamDiskCheckParameters</span><span class=\"token punctuation\">(</span>devExt<span class=\"token punctuation\">,</span> ByteOffset<span class=\"token punctuation\">,</span> Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>      <span class=\"token comment\">// 从请求参数中获取读缓冲区的内存句柄</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      Status <span class=\"token operator\">=</span> <span class=\"token function\">WdfRequestRetrieveOutputMemory</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hMemory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>Status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>          <span class=\"token comment\">// 根据之前获取到的读参数进行内存拷贝，填写读请求的缓存区从而完成读请求的操作</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>          Status <span class=\"token operator\">=</span> <span class=\"token function\">WdfMemoryCopyFromBuffer</span><span class=\"token punctuation\">(</span>hMemory<span class=\"token punctuation\">,</span> <span class=\"token comment\">// Destination</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                                          <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Offset into the destination</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                                          devExt<span class=\"token operator\">-></span>DiskImage <span class=\"token operator\">+</span> ByteOffset<span class=\"token punctuation\">.</span>LowPart<span class=\"token punctuation\">,</span> <span class=\"token comment\">// source</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                                          Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token comment\">// 结束这个请求，这里要注意的是，需要将读取的长度作为返回的信息一并返回</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>  <span class=\"token function\">WdfRequestCompleteWithInformation</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> Status<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>ULONG_PTR<span class=\"token punctuation\">)</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>写请求与读请求类似如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RamDiskEvtIoWrite</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN WDFQUEUE Queue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN WDFREQUEST Request<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    IN size_t Length</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    PDEVICE_EXTENSION      devExt <span class=\"token operator\">=</span> <span class=\"token function\">QueueGetExtension</span><span class=\"token punctuation\">(</span>Queue<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>DeviceExtension<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    NTSTATUS               Status <span class=\"token operator\">=</span> STATUS_INVALID_PARAMETER<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    WDF_REQUEST_PARAMETERS Parameters<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    LARGE_INTEGER          ByteOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    WDFMEMORY              hMemory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">WDF_REQUEST_PARAMETERS_INIT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>Parameters<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">WdfRequestGetParameters</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>Parameters<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    ByteOffset<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">=</span> Parameters<span class=\"token punctuation\">.</span>Parameters<span class=\"token punctuation\">.</span>Write<span class=\"token punctuation\">.</span>DeviceOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">RamDiskCheckParameters</span><span class=\"token punctuation\">(</span>devExt<span class=\"token punctuation\">,</span> ByteOffset<span class=\"token punctuation\">,</span> Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        Status <span class=\"token operator\">=</span> <span class=\"token function\">WdfRequestRetrieveInputMemory</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hMemory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>Status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            Status <span class=\"token operator\">=</span> <span class=\"token function\">WdfMemoryCopyToBuffer</span><span class=\"token punctuation\">(</span>hMemory<span class=\"token punctuation\">,</span> <span class=\"token comment\">// Source</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                                    <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// offset in Source memory where the copy has to start</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                                    devExt<span class=\"token operator\">-></span>DiskImage <span class=\"token operator\">+</span> ByteOffset<span class=\"token punctuation\">.</span>LowPart<span class=\"token punctuation\">,</span> <span class=\"token comment\">// destination</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                                    Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token function\">WdfRequestCompleteWithInformation</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> Status<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>ULONG_PTR<span class=\"token punctuation\">)</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其中的参数检查函数如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>BOOLEAN</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RamDiskCheckParameters</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN PDEVICE_EXTENSION devExt<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN LARGE_INTEGER ByteOffset<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    IN size_t Length</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// Check for invalid parameters.  It is an error for the starting offset</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// + length to go past the end of the buffer, or for the length to</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// not be a proper multiple of the sector size.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// Others are possible, but we don't check them since we trust the</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// file system.</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize <span class=\"token operator\">&lt;</span> Length <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        ByteOffset<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> <span class=\"token comment\">// QuadPart is signed so check for negative values</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ULONGLONG<span class=\"token punctuation\">)</span>ByteOffset<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize <span class=\"token operator\">-</span> Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token punctuation\">(</span>Length <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">.</span>BytesPerSector <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// Do not give an I/O boost for parameter errors.</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token function\">KdPrint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token string\">\"Error invalid parameter\\n\"</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token string\">\"ByteOffset: %x\\n\"</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token string\">\"Length: %d\\n\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            ByteOffset<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            Length</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>         <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token keyword\">return</span> TRUE<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"deviceiocontrol请求\"><a class=\"anchor\" href=\"#deviceiocontrol请求\">#</a> DeviceIoControl 请求</h3>\n<p>在正常情况下，文件系统会发给本驱动所建立的磁盘设备一些读 / 写请求，而实际上除了读 / 写请求，还会有一些控制方面的请求，这种请求被统称为 DeviceIoControl 请求。</p>\n<p>一个标准的磁盘卷设备，需要支持数量庞大的 DeviceIoControl 请求，但是对于这个小例子来说，仅仅支持最小的能够保证正常工作的 DeviceIoControl 请求就已经足够了。</p>\n<p>下面来看看 Ramdisk 驱动是如何处理 DeviceIoControl 请求的。</p>\n<p>首先是  <code>DeviceIoControl</code>  请求的处理函数原型:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RamDiskEvtIoDeviceControl</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN WDFQUEUE     Queue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN WDFREQUEST   Request<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    IN size_t       OutputBufferLength<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    IN size_t       InputBufferLength<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    IN ULONG        IoControlCode</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ul>\n<li>这个回调函数没有返回值。</li>\n<li>第一个参数同样是请求来自于哪个队列；</li>\n<li>第二个参数是请求参数；</li>\n<li>第三个和第四个参数是作为 DeviceIoControl 回调函数所特有的参数，即输出缓冲区长度和输入缓冲区长度。由于 DeviceIoControl 请求通常是伴随着一些请求的相关信息而传入的，填满了请求到的信息传出，所以这里需要这两个缓冲区的长度；</li>\n<li>最后一个参数是请求的功能号，即说明这是一个什么样的 DeviceIoControl 请求。</li>\n</ul>\n<p>接下来看看这些请求是如何被处理的。</p>\n<p>DeviceIoControl 请求有很多种，针对每类不同的设备具有不同的含义，其中有些是必须要处理的，不处理这个设备就有可能不能启动，或者不能正常工作；还有一些在最简单的情况下是不需要处理的，不处理的后果最多会导致某些参数显示不正确等小错误发生。</p>\n<p>Ramdisk 驱动只需要处理几个 DeviceIoControl 请求即可，这几个请求是由相关文档的描述和开发人员的长期经验总结得出的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RamDiskEvtIoDeviceControl</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IN WDFQUEUE Queue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IN WDFREQUEST Request<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    IN size_t OutputBufferLength<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    IN size_t InputBufferLength<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    IN ULONG IoControlCode</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token comment\">// 初始化返回状态为非法的设备请求，这样在其他无关紧要的、不需要处理的 DeviceIoControl 请求到来时，可以直接返回这个状态</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    NTSTATUS          Status <span class=\"token operator\">=</span> STATUS_INVALID_DEVICE_REQUEST<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 用来存放返回的 DeviceIoControl 所要求的的数据长度</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    ULONG_PTR         information <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 中间变量</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    size_t            bufSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// 和读 / 写回调函数相同，也通过队列的扩展来获取设备的扩展</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    PDEVICE_EXTENSION devExt <span class=\"token operator\">=</span> <span class=\"token function\">QueueGetExtension</span><span class=\"token punctuation\">(</span>Queue<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>DeviceExtension<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">// 由于我们对发过来的请求的长度很有信心（因为是 Windows 标准请求），所以这不需要输入缓冲区和输出缓冲区</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">UNREFERENCED_PARAMETER</span><span class=\"token punctuation\">(</span>OutputBufferLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">UNREFERENCED_PARAMETER</span><span class=\"token punctuation\">(</span>InputBufferLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// 开始判断是哪个 DeviceIoControl 请求</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>IoControlCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// 这是一个获取当前分区信息的 DeviceIoControl 请求，需要处理</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">case</span> IOCTL_DISK_GET_PARTITION_INFO<span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token comment\">// 首先声明一个输出缓冲区的指针</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            PPARTITION_INFORMATION outputBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token comment\">// 由于这个 DeviceIoControl 请求所需的信息大部分是从 DBR 中获取的，所以需要一个指向 DBR 的指针</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            PBOOT_SECTOR bootSector <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PBOOT_SECTOR<span class=\"token punctuation\">)</span> devExt<span class=\"token operator\">-></span>DiskImage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token comment\">// 这是将要返回的信息的长度，它会被上层发出 DeviceIoControl 请求的设备收到</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            information <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>PARTITION_INFORMATION<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token comment\">// 通过框架函数来获取这个 DeviceIoControl 请求所携带的输出缓冲区</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            Status <span class=\"token operator\">=</span> <span class=\"token function\">WdfRequestRetrieveOutputBuffer</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>PARTITION_INFORMATION<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>outputBuffer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>bufSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token comment\">// 如果获取缓冲区成功，将 DBR 中的相关信息填入缓冲区</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>Status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>PartitionType <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                    <span class=\"token punctuation\">(</span>bootSector<span class=\"token operator\">-></span>bsFileSystemType<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'6'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> PARTITION_FAT_16 <span class=\"token operator\">:</span> PARTITION_FAT_12<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                <span class=\"token comment\">// 还需要根据这个驱动的现实情况来 “编造” 一些数据</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>BootIndicator       <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>RecognizedPartition <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>RewritePartition    <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>StartingOffset<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>PartitionLength<span class=\"token punctuation\">.</span>QuadPart <span class=\"token operator\">=</span> devExt<span class=\"token operator\">-></span>DiskRegInfo<span class=\"token punctuation\">.</span>DiskSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>HiddenSectors       <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ULONG<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                outputBuffer<span class=\"token operator\">-></span>PartitionNumber     <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ULONG<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>                <span class=\"token comment\">// 成功，修改返回状态</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                Status <span class=\"token operator\">=</span> STATUS_SUCCESS<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token keyword\">case</span> IOCTL_DISK_GET_DRIVE_GEOMETRY<span class=\"token operator\">:</span>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>            <span class=\"token comment\">// 首先声明一个输出缓冲区</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            PDISK_GEOMETRY outputBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>            <span class=\"token comment\">// 这是将要返回的信息的长度，它会被上层发出 DeviceIoControl 请求的设备接收到</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>            information <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>DISK_GEOMETRY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>            <span class=\"token comment\">// 通过框架函数来获取这个 DeviceIoControl 请求所携带的输出缓冲区</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>            Status <span class=\"token operator\">=</span> <span class=\"token function\">WdfRequestRetrieveOutputBuffer</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>DISK_GEOMETRY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>outputBuffer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>bufSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>            <span class=\"token comment\">// 如果获取缓冲区成功，将相关信息填入缓冲区</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">NT_SUCCESS</span><span class=\"token punctuation\">(</span>Status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>                <span class=\"token comment\">// 这里实际上就是填入之前初始化好的磁盘的几何信息</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>                <span class=\"token function\">RtlCopyMemory</span><span class=\"token punctuation\">(</span>outputBuffer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>devExt<span class=\"token operator\">-></span>DiskGeometry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>DISK_GEOMETRY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                <span class=\"token comment\">// 修改返回状态</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>                Status <span class=\"token operator\">=</span> STATUS_SUCCESS<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    <span class=\"token comment\">// 对于这两个 DeviceIoControl 请求，直接返回成功，因为这两个请求是不需要其他信息的</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>    <span class=\"token keyword\">case</span> IOCTL_DISK_CHECK_VERIFY<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>    <span class=\"token keyword\">case</span> IOCTL_DISK_IS_WRITABLE<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>        <span class=\"token comment\">// 修改返回状态</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>        Status <span class=\"token operator\">=</span> STATUS_SUCCESS<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>    <span class=\"token comment\">// 结束这个 DeviceIoControl 请求，需要将读取的长度作为返回信息一并返回</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>    <span class=\"token function\">WdfRequestCompleteWithInformation</span><span class=\"token punctuation\">(</span>Request<span class=\"token punctuation\">,</span> Status<span class=\"token punctuation\">,</span> information<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>至此结束。</p>\n<h2 id=\"ramdisk的编译与安装\"><a class=\"anchor\" href=\"#ramdisk的编译与安装\">#</a> Ramdisk 的编译与安装</h2>\n<h3 id=\"编译\"><a class=\"anchor\" href=\"#编译\">#</a> 编译</h3>\n<p>pass</p>\n<h3 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>在编译完成之后，生成的文件是 WdfRamdisk.sys 和 ramdisk.inf。前者是驱动的二进制编译结果，后者则是用于安装的信息文件。<br />\n为了正常安装这个驱动，还需要一个小工具，它在 “WDK 安装目录” <code>\\redist\\wdf\\x86</code>  下，叫作 <code>WdfCoInstaller01007.dll</code> 。这个动态链接库文件是 WDF 驱动框架在安装时的一个必要文件，用于安装驱动框架本身的相关内容。</p>\n<p>在准备好了这三个文件之后，读者可以将这三个文件拷贝到要安装的机器的同一个目录中。在 “控制面板” 中找到 “添加硬件” 这一项，然后选择 “添加新的硬件设备”“安装我手动从列表选择的硬件（高级）”“显示所有设备”，单击 “从磁盘安装”，选择 ramdisk.inf。接着一直点击 Next”，这样驱动就安装完毕了，在重启系统之后，就会发现 “我的电脑” 中多出了一个盘，名为 RAMDISK。</p>\n<h3 id=\"对安装的深入探究\"><a class=\"anchor\" href=\"#对安装的深入探究\">#</a> 对安装的深入探究</h3>\n<p>那么安装时到底做了什么事情使得这个驱动可以在每次启动时工作起来呢？下面就来一探究竟。</p>\n<p>安装的过程都来自于 <code>ramdisk.inf</code>  的控制。 <code>ramdisk.inf</code>  文件是随着编译产生的，编译器在获取到了当前编译的平台、目标平台等信息之后（这些信息由编译环境提供），会将  <code>RAMDISK</code>  程序目录下的 <code>ramdisk.inx</code>  文件中的一些变量加以赋值，最终生成了适合于相应目标平台的 <code>ramdisk.inf</code>  文件。当然，仅仅有 <code>ramdisk.inf</code>  文件还是不够的，这里还使用了 Windows 系统自带的添加硬件向导来完成安装。在这里不需要搞清楚添加硬件向导到底在读入了这个 <code>ramdisk.inf</code>  之后做了哪些操作，这些操作必将是很复杂的，而且牵扯到过多的其他方面内容，读者只需要从结果来看看安装过程最终在系统中留下了什么即可。</p>\n<p>首先可以发现 <code>WdfRamdisk.sys</code>  文件被拷贝到了 Windows 的  <code>System32\\drivers</code>  目录下，这是正常的，因为所有的 Windows 驱动程序几乎都放在这个目录下。接下来读者会在注册表中发现一些增加的项，这些项各有作用，下面就对它们做一些简单的讲解。</p>\n<ol>\n<li>\n<p><code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\Root\\UNKNOWN”</code> 。这是在安装之后新增加的一个键，在这之下还有一个叫作 <code>0000</code>  的子键，读者可以在管理员用户下用 <code>regedit</code>  命令查看这个键的内容。在 Windows 系统启动时，PnP 管理器会枚举  <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\Root\\”</code>  下的所有键，并会根据键中的信息为每个设备创建一个 PDO（物理设备对象 ） 。 在 <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ Root\\”</code>  下的所有键代表了在系统安装时记录的或者通过添加硬件向导添加的一个硬件信息，Windows 虚拟了一条根总线并且把这些硬件挂接在上面。PnP 管理器完成 PDO 的建立之后会进行标准的 PnP 操作，与 PDO 相对应的驱动将会被加载。在 <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\Root\\UNKNOWN\\0000”</code>  键下可以看到和 Ramdisk 相关的信息，其中有一个值是 Service，系统将会寻找这个值指明的驱动，进行加载和调用。另外，在这个键下面还有一个值是 <code>ClassGUID</code> ，这个值的内容将作为这一类驱动的索引，在下面笔者将会用 <code>ClassGUID</code>  来代替这一长串的数字。</p>\n</li>\n<li>\n<p><code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Ramdisk”</code> 。上面已经说到系统会去加载 Service 所指明的驱动，而在 <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\Root\\UNKNOWN\\0000”</code>  中的 Service 值的内容正是  <code>Ramdisk</code>  ，于是系统就会 在 <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\”</code>  下面寻找这个叫作 Ramdisk 的服务，并根据它的内容去最终加载驱动程序本身。 <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Ramdisk”</code>  是一个标准的服务描述键，读者应该已经对它非常熟悉了，这里不再多讲，这个键最重要的一点就是指明了 <code>ramdisk.sys</code>  文件的位置。</p>\n</li>\n<li>\n<p><code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\ClassGUID”</code> 。请读者注意这个键最后的 <code>ClassGUID</code>  实际上是一长串数字，数字的内容在  <code>“\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\Root\\UNKNOWN\\0000”</code>  键的 <code>ClassGUID</code>  值中。这个键说明了具有同样 Class 的驱动所通用的一些信息，在 Ramdisk 驱动中这个键没有太大的用处，但是在其他的驱动如类过滤驱动等驱动程序中，这个键却起着非常重要的作用。</p>\n</li>\n</ol>\n<h1 id=\"结束\"><a class=\"anchor\" href=\"#结束\">#</a> 结束</h1>\n<p>通过 Ramdisk 驱动，简单了解了 WDF 驱动开发框架。</p>\n",
            "tags": [
                "磁盘虚拟",
                "DriverEntry函数的定义",
                "WDF_DRIVER_CONFIG结构",
                "EvtDriverDeviceAdd函数",
                "FAT12/16磁盘卷"
            ]
        }
    ]
}