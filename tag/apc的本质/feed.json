{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"apc的本质\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Apc/APC%E6%9C%BA%E5%88%B6-01%E5%88%9D%E8%AF%86APC/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Apc/APC%E6%9C%BA%E5%88%B6-01%E5%88%9D%E8%AF%86APC/",
            "title": "APC机制-01初识APC",
            "date_published": "2022-02-24T06:35:12.000Z",
            "content_html": "<h1 id=\"楔子\"><a class=\"anchor\" href=\"#楔子\">#</a> 楔子</h1>\n<p>线程是不能被 “杀掉”、“挂起” 和 “恢复” 的，线程在执行的时候自己占据着 CPU，无论多核还是单核，线程都是自己做的这些事，那么其他线程如何控制它呢？如何改变一个线程的行为？可以给他提供一个函数，让它自己去调用，这个函数就是 APC (Asyncroneus Procedure Call)，即异步过程调用。</p>\n<p>首先有以下疑问：</p>\n<blockquote>\n<p>至于为什么会执行 APC，上述已说。<br />\n谁插入的 APC？<br />\n插入到哪里？<br />\n谁执行的 APC？<br />\n什么时候执行 APC？</p>\n</blockquote>\n<h2 id=\"apc-队列\"><a class=\"anchor\" href=\"#apc-队列\">#</a> APC 队列</h2>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kd&gt; dt _KTHREAD</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>nt!_KTHREAD</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t...</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t   +0x034 ApcState         : _KAPC_STATE</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t...</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>kd&gt; dt _KAPC_STATE</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>nt!_KAPC_STATE</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   +0x000 ApcListHead\t&#x2F;&#x2F;2 个 APC 队列 用户 APC 和内核 APC </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   +0x010 Process\t\t&#x2F;&#x2F; 线程所属或者所挂靠的进程</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   +0x014 KernelApcInProgress\t&#x2F;&#x2F; 内核 APC 是否正在执行</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   +0x015 KernelApcPending\t&#x2F;&#x2F; 是否有正在等待执行的内核 APC</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   +0x016 UserApcPending\t&#x2F;&#x2F; 是否有正在等待执行的用户 APC</pre></td></tr></table></figure><p>用户 APC：APC 函数地址位于用户空间，在用户空间执行.<br />\n 内核 APC：APC 函数地址位于内核空间，在内核空间执行.</p>\n<h2 id=\"apc-结构\"><a class=\"anchor\" href=\"#apc-结构\">#</a> APC 结构</h2>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kd&gt; dt _KAPC</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>nt!_KAPC</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   +0x000 Type</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   +0x002 Size</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   +0x004 Spare0                                 </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   +0x008 Thread                                 </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   +0x00c ApcListEntry</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   +0x014 KernelRoutine</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   +0x018 RundownRoutine</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   +0x01c NormalRoutine   &#x2F;&#x2F; 找到你提供的 APC 函数，并不完全等于 APC 函数的地址，后面会讲。</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   +0x020 NormalContext</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   +0x024 SystemArgument1</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   +0x028 SystemArgument2</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   +0x02c ApcStateIndex</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   +0x02d ApcMode</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>   +0x02e Inserted</pre></td></tr></table></figure><h2 id=\"apc函数何时被执行\"><a class=\"anchor\" href=\"#apc函数何时被执行\">#</a> APC 函数何时被执行？</h2>\n<p><code>KiServiceExit</code>  函数：这个函数是系统调用、异常或中断返回用户空间的必经之路。</p>\n<p><code>KiDeliverApc</code>  函数：负责执行 APC 函数。</p>\n<h2 id=\"分析-terminatethread-和-suspendthread-函数\"><a class=\"anchor\" href=\"#分析-terminatethread-和-suspendthread-函数\">#</a> 分析 TerminateThread 和 SuspendThread 函数</h2>\n<p>分析  <code>TerminateThread</code>  /  <code>SuspendThread</code>  是如何实现的（从 3 环开始分析）以此证明控制别的线程就是通过 APC 实现的。</p>\n<p>分析流程为：</p>\n<ol>\n<li><code>TerminateThread -&gt; NtTerminateThread -&gt; PspTerminateThreadByPointer -&gt; KeInitializeApc、KeInsertQueueApc</code></li>\n<li><code>SuspendThread -&gt; NtSuspendThread -&gt; PsSuspendThread -&gt; KeSuspendThread -&gt; KiInsertQueueApc</code></li>\n</ol>\n<p>可以发现函数调用到最后都是通过 APC 控制的。</p>\n<h2 id=\"自己编写代码向某个线程插入一个用户apc\"><a class=\"anchor\" href=\"#自己编写代码向某个线程插入一个用户apc\">#</a> 自己编写代码向某个线程插入一个用户 APC</h2>\n<p>使用现成的 API 就可以，目的是体会什么是 APC。</p>\n<p>这里最简单的办法就是，自己给自己插入 APC，自己创建一个线程一直打印一句话，然后主线程给这个线程插入 APC，打印另一句话。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pass</pre></td></tr></table></figure>",
            "tags": [
                "APC的本质"
            ]
        }
    ]
}