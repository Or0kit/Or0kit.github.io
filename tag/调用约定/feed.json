{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"调用约定\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Win32/win32%E5%AD%A6%E4%B9%A0/",
            "url": "https://or0kit.github.io/Bin/Win32/win32%E5%AD%A6%E4%B9%A0/",
            "title": "win32学习",
            "date_published": "2021-03-30T07:14:33.000Z",
            "content_html": "<h1 id=\"winmain-函数\"><a class=\"anchor\" href=\"#winmain-函数\">#</a> WinMain 函数</h1>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> WINAPI <span class=\"token function\">WinMain</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    HINSTANCE hInstance<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 应用程序当前实例的句柄</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    HINSTANCE hPrevInstance<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 应用程序的先前实例的句柄。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    LPSTR IpCmdLine<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 命令行的字符串的指针</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> nShowCmd  <span class=\"token comment\">// 窗口显示方式、默认为 SW_SHOWDEFAULT</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>WinMain 函数接收 4 个参数，这些参数都是在系统调用 WinMain 函数时，传递给应用程序的。</p>\n<p>第一个参数 hInstance 表示该程序当前运行的实例的句柄，这是一个数值。当程序在 Windows 下运行时，它唯一标识运行中的实例（注意，只有运行中的程序实例，才有实例句柄）。一个应用程序可以运行多个实例，每运行一个实例，系统都会给该实例分配一个句柄值，并通过 hInstance 参数传递给 WinMain 函数。</p>\n<p>同一个程序打开两次，出现两个窗口，第一次打开的窗口就是先前实例的窗口。对于一个 32 位程序，该参数总为 NULL。</p>\n<p>第二个参数 hPrevInstance 表示当前实例的前一个实例的句柄。通过查看 MSDN 我们可以知道，在 Win32 环境下，这个参数总是 NULL ，即在 Win32 环境下，这个参数不再起作用。</p>\n<p>第三个参数 lpCmdLine 是一个以空终止的字符串，指定传递给应用程序的命令行参数。 例如：在 D 盘下有一个 sunxin.txt 文件，当我们用鼠标双击这个文件时将启动记事本程序（ notepad.exe ），此时系统会将 D:/sunxin.txt 作为命令行参数传递给记事本程序的 WinMain 函数，记事本程序在得到这个文件的全路径名后，就在窗口中显示该文件的内容。要在 VC++ 开发环境中向应用程序传递参数，可以单击菜单 【 Project 】→【 Settings 】，选择 “Debug” 选项卡，在 “ Program arguments ” 编辑框中输入你想传递给应用程序的参数。</p>\n<p>第四个参数 nCmdShow 指定程序的窗口应该如何显示，例如最大化、最小化、隐藏等。这个参数的值由该程序的调用者所指定，在调用 ShowWindow () 时可以使用到该值</p>\n<p>=============================================================</p>\n<p><span class=\"label\">应用程序句柄</span></p>\n<p>WinMain 函数的第一个参数 hInstance 就是可执行文件的实例句柄，实际上是个内存地址，它指出系统在何处把 exe 文件装载入进程的地址空间！<br />\nPE 中的 ImageBase</p>\n<p><span class=\"label\">窗口显示方式</span></p>\n<p>第四个参数 nCmdShow，指定窗口第一次出现 (程序刚刚启动时) 时的显示方式。显示方式有多种，比如：</p>\n<p>不显示，nCmdShow = 0;<br />\n 正常显示，nCmdShow = 1;(默认为 1)<br />\n 最小化显示，nCmdShow = 2;<br />\n 最大化显示，nCmdShow = 3;<br />\n 如果需要改变系统的默认的显示方式，需要在创建窗口之前指定 nCmdShow 的值 (通过一个简单的赋值语句 nCmdShow = n)</p>\n<p>不过，其实这里要让 nCmdShow 起作用，需要把 nCmdShow 作为参数传递给 ShowWindow 函数</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * ShowWindow() Commands</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_HIDE</span>             <span class=\"token expression\"><span class=\"token number\">0</span></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWNORMAL</span>       <span class=\"token expression\"><span class=\"token number\">1</span></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_NORMAL</span>           <span class=\"token expression\"><span class=\"token number\">1</span>     激活并显示一个窗口。如果窗口被最小化或最大化，系统 将其恢复到原来的尺寸和大小。应用程序 在第一次显示窗口的时候应该指定此标志。</span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWMINIMIZED</span>    <span class=\"token expression\"><span class=\"token number\">2</span>     激活窗口并将其最小化。</span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWMAXIMIZED</span>    <span class=\"token expression\"><span class=\"token number\">3</span>     激活窗口并将其最大化。</span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_MAXIMIZE</span>         <span class=\"token expression\"><span class=\"token number\">3</span>     最大化指定的窗口。</span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWNOACTIVATE</span>   <span class=\"token expression\"><span class=\"token number\">4</span>     以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。</span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOW</span>             <span class=\"token expression\"><span class=\"token number\">5</span>     在窗口原来的位置以原来的尺寸激活和显示窗口。</span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_MINIMIZE</span>         <span class=\"token expression\"><span class=\"token number\">6</span>     最小化指定的窗口并且激活在Z序中的下一个顶层窗口。</span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWMINNOACTIVE</span>  <span class=\"token expression\"><span class=\"token number\">7</span></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWNA</span>           <span class=\"token expression\"><span class=\"token number\">8</span>     以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。</span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_RESTORE</span>          <span class=\"token expression\"><span class=\"token number\">9</span>     激活并显示窗口。如果窗口最小化或最大化，则系统 将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序 应该指定这个标志。</span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_SHOWDEFAULT</span>      <span class=\"token expression\"><span class=\"token number\">10</span>     依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序 的程序 传递给CreateProcess函数的。</span></span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_FORCEMINIMIZE</span>    <span class=\"token expression\"><span class=\"token number\">11</span>     在WindowNT5<span class=\"token punctuation\">.</span><span class=\"token number\">0</span>中最小化窗口，即使拥有窗口的线程被挂起也会最小化。在从其他线程最小化窗口时才使用这个参数。</span></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SW_MAX</span>              <span class=\"token expression\"><span class=\"token number\">11</span></span></span></pre></td></tr></table></figure><h1 id=\"winapi和apientry\"><a class=\"anchor\" href=\"#winapi和apientry\">#</a> WINAPI 和 APIENTRY</h1>\n<p>另外，这里稍微说明一下  <code>WINAPI</code>  这个宏定义，我们看 WinMain 函数的原型：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> WINAPI <span class=\"token function\">WinMain</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    HINSTANCE hInstance<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    HINSTANCE hPreInstance<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    LPSTR     lpCmdLine<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span>       nCmdShow</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>WINAPI 是这样定义的：</p>\n<p><code>#define WINAPI      __stdcall</code></p>\n<p>在 VC6.0 下生成的 WinMain 函数，实际上是：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> APIENTRY <span class=\"token function\">WinMain</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    HINSTANCE hInstance<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    HINSTANCE hPreInstance<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    LPSTR     lpCmdLine<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span>       nCmdShow</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>APIENTRY 这个定义为：</p>\n<p><code>#define APIENTRY    WINAPI</code></p>\n<p>所以归根到底都是  <code>__stdcall</code> ，这个是什么东西了？这里解释一下：</p>\n<p><code>__stdcall</code>  一种调用约定 (调用函数时候的一种约定)，其他的调用约定有：</p>\n<p><code>__cdecl 和 __fastcall</code></p>\n<p>调用约定将决定以下内容：</p>\n<p>1) 函数参数的压栈顺序，</p>\n<p>2) 由调用者还是被调用者把参数弹出栈，</p>\n<p>3) 以及产生函数修饰名的方法。</p>\n<p>WIN32API 使用的是 <code>__stdcall</code>  调用约定</p>\n<p>标准 C，C++ 使用的是 <code>__cdecl</code>  调用约定</p>\n<p><code>__stdcall</code>  调用约定：函数的参数自右向左压栈，被调用的函数在返回前清理传送参数的内存栈</p>\n<p><code>__cdecl</code>  调用约定：每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用 <code>_stdcall</code>  函数的大。函数采用从右到左的压栈方式。注意：对于可变参数的成员函数，始终使用 <code>__cdecl</code>  的调用约定</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zMDI0Nzc4MS9hcnRpY2xlL2RldGFpbHMvOTcxNDE1MTg=\">https://blog.csdn.net/weixin_30247781/article/details/97141518</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzMzU1MS9hcnRpY2xlL2RldGFpbHMvMTEzMjUwOTk5\">https://blog.csdn.net/weixin_42333551/article/details/113250999</span></p>\n",
            "tags": [
                "WinMain函数",
                "调用约定"
            ]
        }
    ]
}