{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"跨段跳转流程\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Protect-Mode/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Protect-Mode/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC/",
            "title": "保护模式-代码跨段跳转",
            "date_published": "2021-08-08T05:48:15.000Z",
            "content_html": "<h1 id=\"代码跨段跳转\"><a class=\"anchor\" href=\"#代码跨段跳转\">#</a> 代码跨段跳转</h1>\n<h2 id=\"要点回顾\"><a class=\"anchor\" href=\"#要点回顾\">#</a> 要点回顾</h2>\n<p>段寄存器:<br />\n <code>ES,CS,SS,DS,FS,GS,LDTR,TR</code> <br />\n 除 CS 外，其他的段寄存器都可以通过  <code>MOV,LES,LSS,LDS,LFS,LGS</code>  指令进行修改</p>\n<p>思考：CS 为什么不可以直接修改呢？</p>\n<p><strong>CS 的改变意味着 EIP 的改变，改变 CS 的同时必须修改 EIP, 所以我们无法使用上面的指令来进行修改</strong></p>\n<h2 id=\"代码段跳转流程\"><a class=\"anchor\" href=\"#代码段跳转流程\">#</a> 代码段跳转流程</h2>\n<p>段间跳转分为两种情况：</p>\n<p>要跳转的段是一致代码段<br />\n要跳转的段是非一致代码段</p>\n<p><strong>同时修改 CS 和 EIP 的指令:</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">指令</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">JMP FAR</td>\n<td style=\"text-align:left\">远跳转</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CALL FAR</td>\n<td style=\"text-align:left\">远调用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RETF(return far)</td>\n<td style=\"text-align:left\">远返回</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INT(interrupt)</td>\n<td style=\"text-align:left\">中断</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IRET(interrupt return)</td>\n<td style=\"text-align:left\">执行到中断程序或过程的远返回</td>\n</tr>\n</tbody>\n</table>\n<p><strong>只改变 EIP 的指令：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">指令</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">JMP</td>\n<td style=\"text-align:left\">跳转</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CALL</td>\n<td style=\"text-align:left\">调用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">JCC(jump condition code)</td>\n<td style=\"text-align:left\">跳转指令状态码 / 条件跳转</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RET</td>\n<td style=\"text-align:left\">返回</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"执行流程\"><a class=\"anchor\" href=\"#执行流程\">#</a> 执行流程</h3>\n<p>JMP FAR 指令<br />\n指令格式<br />\n <code>JMP Selector:Offset</code></p>\n<p>如： <code>JMP 0x20:0x00452610</code></p>\n<p>Selector 为段选择子<br />\n Offset 为要跳转的偏移</p>\n<p>思考：CPU 如何执行  <code>JMP 0x20:0x004183D</code>  这行指令</p>\n<ul>\n<li><strong>1）段选择子拆分</strong></li>\n</ul>\n<blockquote>\n<p>0x20 二进制：0000 0000 0010 0000 即<br />\n RPL = 00<br />\nTI = 0<br />\nIndex = 4</p>\n</blockquote>\n<ul>\n<li><strong>2）查表得到段描述符</strong></li>\n</ul>\n<p>TI=0：查 GDT 表<br />\n Index=4：找到对应的段描述符</p>\n<p>四种情况可以跳转：</p>\n<blockquote>\n<p>代码段<br />\n调用门<br />\n TSS 任务段<br />\n任务门</p>\n</blockquote>\n<ul>\n<li><strong>3）权限检查</strong></li>\n</ul>\n<p>一致代码段：要求  <code>CPL &gt;= DPL</code> <br />\n 非一致代码段：要求  <code>CPL == DPL</code>  并且  <code>RPL &lt;= DPL</code></p>\n<ul>\n<li><strong>4）加载段描述符</strong></li>\n</ul>\n<p>通过上面的权限检查后，CPU 会将段描述符加载到 CS 段寄存器中</p>\n<ul>\n<li><strong>5）代码执行</strong></li>\n</ul>\n<p>CPU 将  <code>CS.Base + Offset</code>  的值写入 EIP，然后执行 CS:EIP 处的代码</p>\n<p>段间跳转到此结束</p>\n<ul>\n<li><strong>6）总结</strong></li>\n</ul>\n<p>一致代码段（共享的段）<br />\n特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据<br />\n特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</p>\n<p>非一致代码段（普通代码段）<br />\n只允许同级访问<br />\n绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态</p>\n<p><strong>注意：直接对代码段进行 JMP 或者 CALL 的操作，无论目标是一致代码段还是非一致代码段，CPL 都不会发生改变。如果要提升 CPL 的权限，只能通过调用门</strong></p>\n<h2 id=\"代码跳转实验\"><a class=\"anchor\" href=\"#代码跳转实验\">#</a> 代码跳转实验</h2>\n<p>验证 JMP FAR 指令执行的结果。自己构造一个段描述符，并使用对应的段选择子进行测试。</p>\n<h3 id=\"计算段选择子\"><a class=\"anchor\" href=\"#计算段选择子\">#</a> 计算段选择子</h3>\n<p>使用 Windbg 找到一处未被使用的段描述符：</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>确定了要被构造的段描述符的地址为： <code>0x8003f048</code></p>\n<p>根据 <strong>段描述符地址 = GDT 表首地址 + 索引 × 段描述符长度 = GDT 表首地址 + 索引 × 8</strong> 可以逆推出</p>\n<p><code>索引 =（ 段描述符地址 - GDT表首地址）÷ 8</code></p>\n<p>即 索引 = (0x8003f048-0x8003f000) ÷ 8 = 0x48 ÷ 8 = 72 ÷ 8 = 9</p>\n<p>既我们的段选择子的索引（Index）为 9，查询（Ti=0）GDT 表，请求特权（RPL=0b11）等级为 3。</p>\n<p>得到： <code>0000 0000 0100 1011</code>  既  <code>0x4B</code></p>\n<h3 id=\"构造段描述符\"><a class=\"anchor\" href=\"#构造段描述符\">#</a> 构造段描述符</h3>\n<table>\n<thead>\n<tr>\n<th>数据位</th>\n<th>31-24</th>\n<th>23</th>\n<th>22</th>\n<th>21</th>\n<th>20</th>\n<th>19-16</th>\n<th>15</th>\n<th>14-13</th>\n<th>12</th>\n<th>11-8</th>\n<th>7-0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>含义</td>\n<td>Base</td>\n<td>G</td>\n<td>D/B</td>\n<td>0</td>\n<td>AVL</td>\n<td>Seg.Limit</td>\n<td>P</td>\n<td>DPL</td>\n<td>S</td>\n<td>Type</td>\n<td>Base</td>\n</tr>\n<tr>\n<td>解释</td>\n<td>基地址</td>\n<td>粒度</td>\n<td>默认操作大小</td>\n<td>固定为 0</td>\n<td>用于系统软件使用</td>\n<td>段大小限制</td>\n<td>有效位</td>\n<td>特权等级</td>\n<td>描述符类型</td>\n<td>段类型</td>\n<td>基地址</td>\n</tr>\n<tr>\n<td>数值</td>\n<td>00000000</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1111</td>\n<td>1</td>\n<td>00</td>\n<td>1</td>\n<td>1111</td>\n<td>0000000</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<table>\n<thead>\n<tr>\n<th>数据位</th>\n<th>31-16</th>\n<th>15-0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>含义</td>\n<td>Base Adress</td>\n<td>Segment Limit</td>\n</tr>\n<tr>\n<td>解释</td>\n<td>基地址</td>\n<td>段大小限制</td>\n</tr>\n<tr>\n<td>数值</td>\n<td>0000000000000000</td>\n<td>1111111111111111</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>主要修改了 DPL 为 0；段类型设置为可执行可读，可从较低特权级别调用，可访问的 代码段描述符</p>\n<p>将上面的二进制拼接得到： <code>00cf9f00`0000ffff</code></p>\n<h3 id=\"写入段描述符\"><a class=\"anchor\" href=\"#写入段描述符\">#</a> 写入段描述符</h3>\n<p>将构造好的段描述符写入</p>\n<p>在 windbg 中使用指令</p>\n<p><code>eq  8003f048 00cf9f00`0000ffff</code></p>\n<p><code>eq ：edit qword</code> ，以 qword 的数据宽度编辑修改指定地址的数据</p>\n<p>指令格式为： <code>eq address data</code></p>\n<p>修改后再用 windbg 查看</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<h3 id=\"od测试指令\"><a class=\"anchor\" href=\"#od测试指令\">#</a> OD 测试指令</h3>\n<p>使用 OD 随便打开一个软件。选择一个跳转的地址。</p>\n<p><code>jmp 0x4B:0x0085F472</code></p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<p>可以看到 EIP 被修改为了 Offset (偏移)，CS 被修改为了 Selector (段选择子)。EIP 和 CS 同时被修改了。</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<h3 id=\"尝试修改cpl\"><a class=\"anchor\" href=\"#尝试修改cpl\">#</a> 尝试修改 CPL</h3>\n<p>原本的 CPL 为 3，CPL 为当前特权级别，等于 CS 和 SS 的 RPL（请求特权级别）</p>\n<p>前面的其它操作不变，将段选择子的请求特权级别修改为 0</p>\n<p>即将段选择子修改为</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Index</th>\n<th>TI</th>\n<th>RPL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>二进制值</td>\n<td>0000 0000 0100 1</td>\n<td>0</td>\n<td>00</td>\n</tr>\n<tr>\n<td>十进制值</td>\n<td>9</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>含义</td>\n<td>索引为 9</td>\n<td>查询 GDT 表</td>\n<td>请求特权等级为 0</td>\n</tr>\n</tbody>\n</table>\n<p>得到新的段选择子为 <code>0x48</code></p>\n<p>使用 OD 执行新的指令</p>\n<p><code>jmp 0x48:0x0085F47E</code></p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>可以看到，CS 仍然是 0x4B，CPL 仍然没有发生改变，当前特权等级依旧为 3</p>\n<p>也就是说 CPL 无法通过这种方式改变</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTg4NDQ4L2FydGljbGUvZGV0YWlscy8xMDI1Nzk2OTU=\">https://blog.csdn.net/qq_41988448/article/details/102579695</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuNTJwb2ppZS5jbi90aHJlYWQtMTQyMzQ4NC0xLTEuaHRtbA==\">https://www.52pojie.cn/thread-1423484-1-1.html</span></p>\n",
            "tags": [
                "跨段跳转流程",
                "JMP FAR指令"
            ]
        }
    ]
}