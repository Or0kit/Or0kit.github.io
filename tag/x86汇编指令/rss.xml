<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Or0kit • Posts by &#34;x86汇编指令&#34; tag</title>
        <link>https://Or0kit.github.io</link>
        <description>临渊羡鱼，不如退而结网</description>
        <language>zh-CN</language>
        <pubDate>Wed, 24 Mar 2021 20:19:17 +0800</pubDate>
        <lastBuildDate>Wed, 24 Mar 2021 20:19:17 +0800</lastBuildDate>
        <category>Algolia</category>
        <category>Drozer</category>
        <category>同义词替换</category>
        <category>xpath</category>
        <category>win32api</category>
        <category>WOW64</category>
        <category>windows消息机制</category>
        <category>虚拟内存</category>
        <category>jsDelivr</category>
        <category>First blog</category>
        <category>markdown 学习</category>
        <category>Android</category>
        <category>替换密钥</category>
        <category>数论基础</category>
        <category>ADB</category>
        <category>雷电模拟器</category>
        <category>Hadoop</category>
        <category>IDA</category>
        <category>Windows逆向</category>
        <category>SSH隧道</category>
        <category>url</category>
        <category>http</category>
        <category>应急响应</category>
        <category>Nginx</category>
        <category>Linux</category>
        <category>CentOS7配置vsftp</category>
        <category>Psad</category>
        <category>fwsnort</category>
        <category>x86汇编指令</category>
        <category>动态分析技术基础</category>
        <category>静态分析基础</category>
        <category>逆向</category>
        <category>IDA学习</category>
        <category>恶意代码分析实战入门</category>
        <category>加壳</category>
        <category>脱壳</category>
        <category>C++壳</category>
        <category>ESP寻址</category>
        <category>定位Win32窗口回调函数</category>
        <category>HOOK攻防</category>
        <category>瞬时HOOK过检测</category>
        <category>INLINE-HOOK</category>
        <category>IAT HOOK</category>
        <category>INLINE HOOK</category>
        <category>进程监控</category>
        <category>模块隐藏</category>
        <category>进程通信</category>
        <category>tlhelp32.h</category>
        <category>进程遍历</category>
        <category>模块遍历</category>
        <category>外挂原理</category>
        <category>DLL注入之进程间通信</category>
        <category>TEB</category>
        <category>PEB</category>
        <category>R3层断链</category>
        <category>Win临界区</category>
        <category>Win事件</category>
        <category>线程同步</category>
        <category>Win互斥体</category>
        <category>内存映射文件</category>
        <category>内存映射共享</category>
        <category>写拷贝</category>
        <category>Win子窗口控件</category>
        <category>win32文件函数</category>
        <category>代码注入</category>
        <category>窗口程序</category>
        <category>消息机制</category>
        <category>消息类型</category>
        <category>私有内存</category>
        <category>共享内存</category>
        <category>设备对象</category>
        <category>DC设备上下文</category>
        <category>图形对象</category>
        <category>创建线程</category>
        <category>线程控制</category>
        <category>线程相关API</category>
        <category>线程上下文</category>
        <category>CONTEXT结构体</category>
        <category>物理内存</category>
        <category>Windows进程</category>
        <category>句柄表</category>
        <category>远程线程函数</category>
        <category>远程线程</category>
        <category>DLL注入</category>
        <category>DLL注入相关函数</category>
        <category>WinMain函数</category>
        <category>调用约定</category>
        <category>我的GetProcAddress</category>
        <category>资源文件</category>
        <category>消息断点</category>
        <category>PE课后作业</category>
        <category>通用控件</category>
        <category>WM_NOTIFY消息类型</category>
        <category>MFC</category>
        <category>PE查看器</category>
        <category>RVA与FOA</category>
        <category>PE结构</category>
        <category>DOS头属性说明</category>
        <category>标准PE头属性说明</category>
        <category>扩展PE头属性说明</category>
        <category>节表属性说明</category>
        <category>空白区添加代码</category>
        <category>合并节</category>
        <category>导入表</category>
        <category>注入</category>
        <category>导入表注入</category>
        <category>导出表</category>
        <category>扩大节</category>
        <category>新增节</category>
        <category>移动NT头</category>
        <category>移动导出表</category>
        <category>移动重定位表</category>
        <category>重定位表</category>
        <category>静态链接库</category>
        <category>动态链接库</category>
        <category>句柄</category>
        <category>CobaltStrike</category>
        <category>RedTeam</category>
        <category>Apeache</category>
        <category>php</category>
        <category>Nmap</category>
        <category>guestbook</category>
        <category>SQLmap</category>
        <category>apache</category>
        <category>log</category>
        <category>mysql主键</category>
        <category>CSRF</category>
        <category>SSRF</category>
        <category>业务逻辑漏洞</category>
        <category>xss</category>
        <category>webshell流量特征</category>
        <category>虚拟网卡</category>
        <category>button</category>
        <category>单选框</category>
        <category>复选框件</category>
        <category>Edit</category>
        <category>Combo Box</category>
        <category>Tab</category>
        <category>ListCtrl</category>
        <category>MFC的本质</category>
        <category>MFC的层次结构图</category>
        <category>手动创建一个MFC程序</category>
        <category>MFC的初始化过程</category>
        <category>MFC运行时类型识别</category>
        <category>关键字static</category>
        <category>关键字const</category>
        <category>MFC动态创建</category>
        <category>MFC消息映射</category>
        <category>结构体AFX_MSGMAP_ENTRY</category>
        <category>结构体AFX_MSGM</category>
        <category>MFC的三大类消息</category>
        <category>数据传输</category>
        <category>ini文件的读写</category>
        <category>python</category>
        <category>SSH</category>
        <category>python文件读取</category>
        <category>数据分析</category>
        <category>socket</category>
        <category>数据库编程</category>
        <category>python内置属性</category>
        <category>multiprocessing</category>
        <category>threading</category>
        <category>scrapy</category>
        <category>测试</category>
        <category>BHP</category>
        <category>Python的import功能</category>
        <category>木马</category>
        <category>非可变序列算法</category>
        <category>可变序列算法</category>
        <category>排序算法</category>
        <category>迭代器</category>
        <category>使用自定义对象</category>
        <category>0环与3环的通信（常规方法）</category>
        <category>内核空间</category>
        <category>内核模块</category>
        <category>遍历内核模块</category>
        <category>定位未导出函数PspTiminateProcess</category>
        <category>内核编程基础</category>
        <category>ANSI_STRING</category>
        <category>UNICODE_STRING</category>
        <category>内核内存</category>
        <category>上下文环境</category>
        <category>中断请求级别</category>
        <category>链表</category>
        <category>自旋锁</category>
        <category>注册表</category>
        <category>地址空间</category>
        <category>文件操作</category>
        <category>线程与事件</category>
        <category>内核重载</category>
        <category>配置VS2019+WDK10</category>
        <category>第一个驱动程序</category>
        <category>驱动调试</category>
        <category>调试驱动程序</category>
        <category>OpenSCManager</category>
        <category>CreateService</category>
        <category>APC的本质</category>
        <category>APC的备用队列</category>
        <category>线性地址的管理</category>
        <category>VAD树</category>
        <category>_MMVAD</category>
        <category>_MMVAD_FLAGS</category>
        <category>共享物理页</category>
        <category>共享文件</category>
        <category>LoadLibrary的本质</category>
        <category>VirtualAlloc</category>
        <category>MEM_COMMIT与MEM_RESERVE</category>
        <category>malloc</category>
        <category>堆内存</category>
        <category>栈内存</category>
        <category>全局区内存</category>
        <category>MmAddPhysicalMemoryEx</category>
        <category>缺页异常</category>
        <category>消息队列</category>
        <category>PsConvertToGuiThread</category>
        <category>win32k.sys</category>
        <category>GUI线程</category>
        <category>窗口程序的创建</category>
        <category>消息循环</category>
        <category>临界区</category>
        <category>KPCR结构体</category>
        <category>模拟线程切换</category>
        <category>模拟挂起与恢复函数</category>
        <category>等待链表</category>
        <category>调度链表</category>
        <category>ETHREAD</category>
        <category>KTHREAD</category>
        <category>进程的创建</category>
        <category>获取当前进程</category>
        <category>EPROCESS</category>
        <category>KPROCESS</category>
        <category>2-9-9-12分页</category>
        <category>PAE</category>
        <category>PDPTE</category>
        <category>PDE</category>
        <category>PTE</category>
        <category>XD标志位</category>
        <category>逆向分析MmIsAddressValid函数(2-9-9-12)</category>
        <category>TLB</category>
        <category>INVLPG指令</category>
        <category>全局页</category>
        <category>ShadowWalker</category>
        <category>PWT</category>
        <category>PDT</category>
        <category>CPU缓存</category>
        <category>中断</category>
        <category>异常</category>
        <category>CLI指令</category>
        <category>STI指令</category>
        <category>INT2</category>
        <category>INT8</category>
        <category>中断门描述符</category>
        <category>IDT</category>
        <category>提权</category>
        <category>跨段跳转流程</category>
        <category>JMP FAR指令</category>
        <category>TSS</category>
        <category>任务门</category>
        <category>LDT段描述符</category>
        <category>LDT</category>
        <category>CR0</category>
        <category>CR2</category>
        <category>CR4</category>
        <category>CRL</category>
        <category>DPL</category>
        <category>RPL</category>
        <category>段寄存器结构</category>
        <category>段描述符</category>
        <category>段选择子</category>
        <category>GDT表</category>
        <category>调用门</category>
        <category>调用门描述符</category>
        <category>逆向分析MmIsAddressValid函数</category>
        <category>error C2143</category>
        <category>error C2275</category>
        <category>CALL与CALL FAR</category>
        <category>陷阱门描述符</category>
        <category>10-10-12分页</category>
        <category>页目录表基址</category>
        <category>页表的基址</category>
        <category>0地址执行ShellCode</category>
        <category>PDE_PTE</category>
        <category>物理页</category>
        <category>SSDT HOOK</category>
        <category>OpenProcess</category>
        <category>系统服务表</category>
        <category>SSDT</category>
        <category>SSDT HOOK隐藏</category>
        <category>API进出内核</category>
        <category>系统调用阶段总结</category>
        <category>网络安全法</category>
        <category>ASCII</category>
        <category>GBK</category>
        <category>ANSI</category>
        <category>Unicode</category>
        <category>UTF-8</category>
        <category>URL 编码/解码</category>
        <category>十进制</category>
        <category>二进制</category>
        <category>十六进制</category>
        <category>内存</category>
        <category>x64</category>
        <category>编写ShellCode实现IAT HOOK</category>
        <category>ShellCode原则</category>
        <category>傀儡进程加密壳</category>
        <category>ZwUnmapViewOfSection函数</category>
        <category>加载图标</category>
        <category>提取图标</category>
        <category>资源表</category>
        <category>HTML</category>
        <category>文件包含</category>
        <category>sql注入</category>
        <category>MFC命令传递</category>
        <category>远控界面编写</category>
        <category>STL</category>
        <category>Vector容器</category>
        <category>Deque容器</category>
        <category>List容器</category>
        <category>Set容器</category>
        <category>Multiset容器</category>
        <category>Map容器</category>
        <category>Multimap容器</category>
        <category>Stack容器</category>
        <category>Queue容器</category>
        <category>priority_queue容器</category>
        <category>经典定长指令</category>
        <category>经典变长指令</category>
        <category>指令前缀</category>
        <category>串口</category>
        <category>过滤</category>
        <category>键盘过滤</category>
        <category>KAPC</category>
        <category>QueueUserAPC</category>
        <category>NtQueueApcThread</category>
        <category>KeInitializeApc</category>
        <category>KeInsertQueueApc</category>
        <category>KiInsertQueueApc</category>
        <category>进程句柄表</category>
        <category>全局句柄表</category>
        <category>消息队列与线程</category>
        <category>Windows线程切换</category>
        <category>KiSwapContext</category>
        <category>SwapContext</category>
        <category>时钟中断</category>
        <category>时间片管理</category>
        <category>线程切换与TSS</category>
        <category>线程切换与FS</category>
        <category>线程切换与线程优先级</category>
        <category>快速调用</category>
        <category>中断调用</category>
        <category>分析ReadProcessMemory</category>
        <category>KiFastSystemCall</category>
        <category>KiIntSystemCall</category>
        <category>重写3环</category>
        <category>文件上传</category>
        <category>隐藏驱动</category>
        <category>IopLoadDriver</category>
        <category>延迟过程调用</category>
        <category>进程挂靠</category>
        <category>跨进程读写内存</category>
        <category>APC</category>
        <category>逆向分析NtReadVirtualMemory</category>
        <category>逆向分析NtWriteVIrtualMemory</category>
        <category>AD-Attack-Defense</category>
        <category>payload</category>
        <category>sysenter指令</category>
        <category>KiFastCallEntry函数</category>
        <category>KiSystemService函数</category>
        <category>Trap_Frame</category>
        <category>web安全</category>
        <category>磁盘虚拟</category>
        <category>PDO</category>
        <category>Windows中从击键到内核的过程</category>
        <category>KEYBOARD_INPUT_DATA结构</category>
        <category>IRP完成回调函数</category>
        <category>DriverEntry函数的定义</category>
        <category>WDF_DRIVER_CONFIG结构</category>
        <category>EvtDriverDeviceAdd函数</category>
        <category>FAT12/16磁盘卷</category>
        <category>磁盘的过滤</category>
        <category>具有还原功能的磁盘卷过滤驱动</category>
        <category>文件系统</category>
        <category>Minifilter</category>
        <category>boot驱动</category>
        <category>bitmap</category>
        <category>_KUSER_SHARED_DATA</category>
        <category>哈希表</category>
        <category>Sfilter</category>
        <category>Windows网络编程</category>
        <category>协议层次和服务模型</category>
        <category>IP地址</category>
        <category>端口号</category>
        <category>DNS</category>
        <category>网络地址转换NAT</category>
        <category>分布式网络应用程序</category>
        <category>客户/服务器模型</category>
        <category>浏览器/服务器模型</category>
        <category>P2P模型</category>
        <item>
            <guid isPermalink="true">https://or0kit.github.io/Bin/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</guid>
            <title>汇编指令学习</title>
            <link>https://or0kit.github.io/Bin/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</link>
            <category>x86汇编指令</category>
            <pubDate>Wed, 24 Mar 2021 20:19:17 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;之前学的，因为一些事情就耽搁了，转而学其他的了，现在有时间了，打算接着学。&lt;/p&gt;
&lt;h1 id=&#34;内存格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存格式&#34;&gt;#&lt;/a&gt; 内存格式&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;每个内存单元宽度为 8&lt;/li&gt;
&lt;li&gt;【0x 编号】称为内存地址&lt;/li&gt;
&lt;li&gt;内存是存储数据的，内存地址是对存储数据的一个标识，指向数据却不是数据，通过内存地址的指引，可以访问到内存当中指向的数据.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内存最小的单位是一个字节 ==&amp;gt;&amp;gt; 8 个二进制数  ==&amp;gt;&amp;gt; 两位的十六进制数&lt;/p&gt;
&lt;p&gt;一个内存单元能存一个两位的十六进制数，而这就是内存数据&lt;/p&gt;
&lt;h1 id=&#34;简单指令intel汇编语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简单指令intel汇编语法&#34;&gt;#&lt;/a&gt; 简单指令 (intel 汇编语法)&lt;/h1&gt;
&lt;h2 id=&#34;mov&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mov&#34;&gt;#&lt;/a&gt; mov&lt;/h2&gt;
&lt;p&gt;格式：  &lt;code&gt;mov destination, source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov eax, ebx&lt;/code&gt;   // 将 EBX 中的内容复制到 EAX 寄存器中&lt;br /&gt;
 &lt;code&gt;mov eax, 0x42&lt;/code&gt;  // 将立即数 0x42 复制到 EAX 寄存器中&lt;br /&gt;
 &lt;code&gt;mov eax, [0x443212C4]&lt;/code&gt;  // 将内存地址 0x443212C4 的四个字节复制到 EAX 寄存器&lt;br /&gt;
 &lt;code&gt;mov eax, [ebx+esi*4]&lt;/code&gt;   // 将 ebx+esi*4 等式结果只想的内存地址处 4 个字节复制至 EAX&lt;/p&gt;
&lt;h2 id=&#34;lea&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lea&#34;&gt;#&lt;/a&gt; lea&lt;/h2&gt;
&lt;p&gt;格式：  &lt;code&gt;lea destination, source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;lea 指令用来将一个内存地址赋给目的操作数。&lt;br /&gt;
例如，  &lt;code&gt;lea eax, [ebx+8]&lt;/code&gt;  就是将 EBX+8 的值给 EAX。&lt;br /&gt;
相反的， &lt;code&gt;mov eax, [ebx+8]&lt;/code&gt;  则加载内存中地址为 EBX+8 处的数据。&lt;/p&gt;
&lt;h2 id=&#34;加减运算sub-add-inc-dec&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加减运算sub-add-inc-dec&#34;&gt;#&lt;/a&gt; 加减运算：sub add inc dec&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;label&#34;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指令&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sub eax,0x10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX 寄存器值减去 0x10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add eax,ebx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将 EBX 值加入 EAX 并将结果保存至 EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;inc edx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX 值递增 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dec ecx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ECX 值递减 1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;乘除运算mul-div&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#乘除运算mul-div&#34;&gt;#&lt;/a&gt; 乘除运算:mul div&lt;/h2&gt;
&lt;p&gt;乘法和除法都使用了一个预先规定的寄存器。因此其运算就是指令码加上寄存器要去乘除的值。&lt;br /&gt;
 &lt;code&gt;mul&lt;/code&gt;  和 &lt;code&gt;div&lt;/code&gt;  指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。&lt;br /&gt;
 &lt;code&gt;mul value&lt;/code&gt;  指令总是将 &lt;code&gt;eax&lt;/code&gt;  乘上 &lt;code&gt;value&lt;/code&gt; 。因此， &lt;code&gt;EAX&lt;/code&gt;  寄存器必须在乘法指令出现前就赋值好。&lt;/p&gt;
&lt;p&gt;乘法的结果以 64 位的形式分开存储在两个寄存器中： &lt;code&gt;EDX&lt;/code&gt;  和 &lt;code&gt;EAX&lt;/code&gt; 。其中 EDX 存储了高的 32 位，EAX 存储低的 32 位。&lt;/p&gt;
&lt;p&gt;32 位模式下，MUL（无符号数乘法）指令有三种类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一种执行 8 位操作数与 AL 寄存器的乘法；
第二种执行 16 位操作数与 AX 寄存器的乘法；
第三种执行 32 位操作数与 EAX 寄存器的乘法。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MUL reg/mem8
MUL reg/meml6
MUL reg/mem32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被乘数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;乘数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AL&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DX:AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX:EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。&lt;/p&gt;
&lt;p&gt;有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。&lt;/p&gt;
&lt;p&gt;32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DIV reg/mem8
DIV reg/meml6
DIV reg/mem32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下表给出了被除数、除数、商和余数之间的关系：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被除数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;除数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;商&lt;/td&gt;
&lt;td&gt;余数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AL&lt;/td&gt;
&lt;td&gt;AH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DX:AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td&gt;DX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX:EAX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX&lt;/td&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数，商存放到 RAX，余数存放在 RDX 中。&lt;/p&gt;
&lt;h2 id=&#34;否操作指令not&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#否操作指令not&#34;&gt;#&lt;/a&gt; 否操作指令 NOT&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;NOT OPRD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把 OPRD 取反，再回送给 OPRD&lt;/p&gt;
&lt;p&gt;对标志位没有影响&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;与操作指令and与&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#与操作指令and与&#34;&gt;#&lt;/a&gt; 与操作指令 AND [与]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AND OPRD1，OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;OPRD1 和 OPRD2 执行与操作，结果送到 OPRD1&lt;/p&gt;
&lt;p&gt;执行后，CF＝OF＝0，标志 PF，ZF，SF 反映运算结果，AF 未定义&lt;/p&gt;
&lt;p&gt;某个操作数自身与，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;label&#34;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov al, 00001111b&lt;/code&gt; &lt;br /&gt;
 &lt;code&gt;and al, 11110101b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后 &lt;code&gt;al&lt;/code&gt;  的结果就是 &lt;code&gt;00000101b&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;或操作指令 OR [或]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;OR OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标志位同与运算指令&lt;/p&gt;
&lt;p&gt;某个操作数自身或，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image002.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;异或操作指令xor异或&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异或操作指令xor异或&#34;&gt;#&lt;/a&gt; 异或操作指令 XOR [异或]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XOR OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标志位同与运算指令&lt;/p&gt;
&lt;p&gt;某个操作数自身异或，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;与 0 异或，不变，与 1 异或，取反。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image004.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;测试指令test&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#测试指令test&#34;&gt;#&lt;/a&gt; 测试指令 TEST&lt;/h2&gt;
&lt;p&gt;指令格式：TEST  R/M,R/M/IMM&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEST OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指令与 AND 类似，但结果不回送&lt;/p&gt;
&lt;p&gt;指令执行后，ZF，PF，SF 反映运算结果，CF＝OF＝0&lt;/p&gt;
&lt;p&gt;该指令在一定程序上和 CMP 指令时类似的，两个数值进行与操作，结果不保存，但是会改变相应标志位.&lt;/p&gt;
&lt;p&gt;与的操作表项如下：&lt;/p&gt;
&lt;p&gt;1 and 1 = 1	&lt;br /&gt;
1 and 0 = 0&lt;br /&gt;
0 and 1 = 0&lt;br /&gt;
0 and 0 = 0&lt;/p&gt;
&lt;p&gt;常见用法：用这个指令，可以确定某寄存器是否等于 0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEST EAX,EAX&lt;/code&gt; 			观察 Z 位&lt;/p&gt;
&lt;p&gt;但是如果 EAX 的二进制某些位为 1 的话，那么运算的结果就不为零。&lt;/p&gt;
&lt;h2 id=&#34;cmp指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cmp指令&#34;&gt;#&lt;/a&gt; CMP 指令&lt;/h2&gt;
&lt;p&gt;指令格式：CMP  R/M,R/M/IMM&lt;/p&gt;
&lt;p&gt;该指令是比较两个操作数，实际上，它相当于 SUB 指令，但是相减的结构并不保存到第一个操作数中。&lt;/p&gt;
&lt;p&gt;只是根据相减的结果来改变零标志位的，当两个操作数相等的时候，零标志位置 1。&lt;/p&gt;
&lt;h2 id=&#34;移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#移位指令&#34;&gt;#&lt;/a&gt; 移位指令&lt;/h2&gt;
&lt;p&gt;移位指令分为算术移位和逻辑移位。&lt;/p&gt;
&lt;p&gt;移动操作数的位有两种方法。第一种是逻辑移位 (logic shift)，空出来的位用 0 填充。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。注意，位 7 被填充为 0：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image005.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下图所示为二进制数 1100 1111 逻辑右移一位，得到 0110 0111。最低位移入进位标志位：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image006.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;另一种移位的方法是算术移位 (arithmetic shift)，空出来的位用原数据的符号位填充：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;例如，二进制数 1100 1111，符号位为 1。算术右移一位后，得到 1110 0111：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;逻辑移位:   &lt;code&gt;SHL&lt;/code&gt; 、 &lt;code&gt;SHR&lt;/code&gt; &lt;br /&gt;
 算术移位:   &lt;code&gt;CAL&lt;/code&gt; 、 &lt;code&gt;CAR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无符号数的乘法和除法可以用逻辑移位；&lt;br /&gt;
 有符号数的乘法和除法可以用算术移位；&lt;/p&gt;
&lt;h3 id=&#34;逻辑移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#逻辑移位指令&#34;&gt;#&lt;/a&gt; 逻辑移位指令&lt;/h3&gt;
&lt;p&gt;SHL（左移）指令使目的操作数逻辑左移一位，最低位用 0 填充。最高位移入进位标志位，而进位标志位中原来的数值被丢弃&lt;br /&gt;
 SHR（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。最低位复制到进位标志位，而进位标志位中原来的数值被丢弃&lt;/p&gt;
&lt;p&gt;SHL/SHR 的第一个操作数是目的操作数，第二个操作数是移位次数：&lt;br /&gt;
SHL/SHR destination,count&lt;/p&gt;
&lt;p&gt;该指令可用的操作数类型如下所示：&lt;br /&gt;
SHL/SHR reg, imm8&lt;br /&gt;
SHL/SHR mem, imm8&lt;br /&gt;
SHL/SHR reg, CL&lt;br /&gt;
SHL/SHR mem, CL&lt;/p&gt;
&lt;p&gt;x86 处理器允许 imm8 为 0〜255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和 RCL 指令。&lt;/p&gt;
&lt;h3 id=&#34;算术移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#算术移位指令&#34;&gt;#&lt;/a&gt; 算术移位指令&lt;/h3&gt;
&lt;p&gt;算数移位指令分为：算数左移 SAL (Shift Algebraic Left) 和算数右移 SAR (Shift Algebraic Right);&lt;br /&gt;
 指令格式:  &lt;code&gt;SAL/SAR reg/mem,CL/imm&lt;/code&gt; &lt;br /&gt;
 受影响的标志位：CF,OF,PF,SF,ZF; 对 AF 的影响无定义；&lt;/p&gt;
&lt;h3 id=&#34;循环移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#循环移位指令&#34;&gt;#&lt;/a&gt; 循环移位指令&lt;/h3&gt;
&lt;p&gt;循环移位指令 ror 和 rol 与移位指令类似，但移出的那一位会被填到另一端空出来的位置上，即右循环指令（ror）会将最低位循环一到最高位；左循环移位（rol）则相反。&lt;/p&gt;
&lt;h2 id=&#34;nop指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nop指令&#34;&gt;#&lt;/a&gt; NOP 指令&lt;/h2&gt;
&lt;p&gt;nop 指令什么也不做。当它出现时，直接执行下一条指令。&lt;br /&gt;
nop 指令实际上是 xchg eax,eax 的一个谓名字&lt;/p&gt;
&lt;h2 id=&#34;push-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#push-指令&#34;&gt;#&lt;/a&gt; push 指令&lt;/h2&gt;
&lt;h2 id=&#34;pop-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pop-指令&#34;&gt;#&lt;/a&gt; pop 指令&lt;/h2&gt;
&lt;h1 id=&#34;movsb-movsw-movsd-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#movsb-movsw-movsd-指令&#34;&gt;#&lt;/a&gt; movsb、movsw、movsd 指令&lt;/h1&gt;
&lt;p&gt;MOVSB、MOVSW 和 MOVSD 指令：将数据到 EDI 指向的内存&lt;/p&gt;
&lt;h1 id=&#34;rep-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rep-指令&#34;&gt;#&lt;/a&gt; rep 指令&lt;/h1&gt;
&lt;p&gt;按计数寄存器 ecx 中指定的次数重复执行字符串指令&lt;/p&gt;
&lt;p&gt;rep movsd&lt;/p&gt;
&lt;p&gt;取 esi 的值 到 edi 指向的地址&lt;/p&gt;
&lt;h1 id=&#34;pause指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pause指令&#34;&gt;#&lt;/a&gt; pause 指令&lt;/h1&gt;
&lt;p&gt;提高自旋等待循环的性能。当执行 “自旋 - 等待循环” 时，Pentium 4 或 Intel Xeon 处理器在退出循环时会遭受严重的性能损失，因为它检测到可能的内存顺序冲突。PAUSE 指令向处理器提示代码序列是一个自旋 - 等待循环。在大多数情况下，处理器使用这个提示来避免内存顺序冲突，这大大提高了处理器性能。因此，建议在所有自旋 - 等待循环中放置 PAUSE 指令。&lt;/p&gt;
&lt;p&gt;PAUSE 指令的另一个功能是降低 Pentium 4 处理器在执行旋转循环时的功耗。Pentium 4 处理器可以非常快地执行一个自旋 - 等待循环，导致处理器在等待其所旋转的资源变得可用时消耗大量电力。在自旋 - 等待循环中插入暂停指令可以大大降低处理器的功耗。&lt;/p&gt;
&lt;p&gt;这个指令被引入到奔腾 4 处理器中，但它向后兼容所有的 IA-32 处理器。在早期的 IA-32 处理器中，PAUSE 指令就像 NOP 指令一样工作。奔腾 4 和英特尔 Xeon 处理器将 PAUSE 指令实现为预定义延迟。延迟是有限的，对于某些处理器可以是零。该指令不会改变处理器的体系结构状态 (也就是说，它实际上执行了一个延迟的无操作操作)。&lt;/p&gt;
&lt;p&gt;该指令的操作在非 64 位模式和 64 位模式下是相同的。&lt;/p&gt;
&lt;h1 id=&#34;lock指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lock指令&#34;&gt;#&lt;/a&gt; LOCK 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;在伴随指令执行期间断言处理器的 LOCK# 信号 (将指令转换为原子指令)。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;在多处理器环境中，LOCK# 信号确保处理器在断言信号时独占任何共享内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意，在后来的 Intel 64 和 IA-32 处理器 (包括 Pentium 4, Intel Xeon 和 P6 系列处理器) 中，锁可能会在没有 LOCK# 信号的情况下发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCK 前缀只能放在以下指令的前面，并且只能放在目的操作数为内存操作数的指令的前面：ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD 和 XCHG。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 LOCK 前缀与这些指令中的一个一起使用，并且源操作数是内存操作数，则可能会生成一个未定义的操作码异常 (#UD)。&lt;br /&gt;
如果 LOCK 前缀与任何不在上面列表中的指令一起使用，也会生成一个未定义的操作码异常。&lt;br /&gt;
XCHG 指令总是对 LOCK# 信号进行断言，而不管 LOCK 前缀是否存在。&lt;br /&gt;
LOCK 前缀通常与 BTS 指令一起使用，在共享内存环境中的内存位置上执行 read-modifywrite 操作。&lt;br /&gt;
LOCK 前缀的完整性不受内存字段对齐的影响。&lt;br /&gt;
内存锁定在任意错位的字段中被观察到。&lt;br /&gt;
该指令的操作在非 64 位模式和 64 位模式下是相同的&lt;/p&gt;
&lt;h2 id=&#34;protected-mode-exceptions&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#protected-mode-exceptions&#34;&gt;#&lt;/a&gt; Protected Mode Exceptions&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#UD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 LOCK 前缀与以下未列出的指令一起使用: ADD,ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC,NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG，就会产生异常。&lt;/p&gt;
&lt;p&gt;其他异常可以由该指令在应用 LOCK 前缀时生成。&lt;/p&gt;
&lt;h1 id=&#34;xadd-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#xadd-指令&#34;&gt;#&lt;/a&gt; xadd 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;将第一个操作数 (目标操作数) 与第二个操作数 (源操作数) 交换，然后将两个值的和加载到目标操作数中。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;目标操作数可以是寄存器或内存位置； 源操作数是一个寄存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 64 位模式下，指令的默认操作大小是 32 位。&lt;/p&gt;
&lt;p&gt;以 REX 的形式使用 REX 前缀。R 允许访问附加寄存器 (R8-R15)。以 REX 的形式使用 REX 前缀。W 将操作提升到 64 位。有关编码数据和限制，请参阅本节开头的汇总图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;bts指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bts指令&#34;&gt;#&lt;/a&gt; bts 指令&lt;/h1&gt;
&lt;p&gt;例子：  &lt;code&gt;lock bts dword ptr [esi], 0 ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BTS 指令的作用：&lt;br /&gt;
两件事:&lt;br /&gt;
 一、&lt;br /&gt;
&lt;strong&gt;取 esi 比特位的第 0 位存在 CF 标志位中。&lt;/strong&gt;&lt;br /&gt;
二、&lt;br /&gt;
 &lt;code&gt;lock bts dword ptr [esi],0&lt;/code&gt; &lt;br /&gt;
&lt;strong&gt; 将 dword ptr [esi] 指向的内存地址的第 0 位置 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;cmpxchg8b-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cmpxchg8b-指令&#34;&gt;#&lt;/a&gt; cmpxchg8b 指令&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;CMPXCHG8B m64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比较 EDX:EAX 中的 64 位值 (或 RDX:RAX 中的 128 位值，如果操作数是 128 位) 和操作数 (目的操作数)。&lt;br /&gt;
如果两个值相等，则目标操作数中存储 ECX:EBX 中的 64 位值 (或 RCX:RBX 中的 128 位值)。&lt;br /&gt;
否则，目标操作数中的值被加载到 EDX:EAX (或 RDX:RAX) 中。&lt;br /&gt;
目标操作数是一个 8 字节内存位置 (如果操作数大小为 128 位，则为 16 字节内存位置)。&lt;br /&gt;
对于 EDX:EAX 和 ECX:EBX 寄存器对，EDX 和 ECX 包含高阶 32 位，EAX 和 EBX 包含 64 位值的低阶 32 位。&lt;br /&gt;
对于 RDX:RAX 和 RCX:RBX 寄存器对，RDX 和 RCX 为高 64 位，RAX 和 RBX 为 128 位的低 64 位。&lt;br /&gt;
该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/p&gt;
&lt;h2 id=&#34;operation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#operation&#34;&gt;#&lt;/a&gt; Operation&lt;/h2&gt;
&lt;p&gt;IF (64-Bit Mode and OperandSize = 64)&lt;br /&gt;
THEN&lt;br /&gt;
TEMP128 ← DEST&lt;br /&gt;
IF (RDX:RAX = TEMP128)&lt;br /&gt;
THEN&lt;br /&gt;
ZF ← 1;&lt;br /&gt;
DEST ← RCX:RBX;&lt;br /&gt;
ELSE&lt;br /&gt;
ZF ← 0;&lt;br /&gt;
RDX:RAX ← TEMP128;&lt;br /&gt;
DEST ← TEMP128;&lt;br /&gt;
FI;&lt;br /&gt;
FI&lt;br /&gt;
ELSE&lt;br /&gt;
TEMP64 ← DEST;&lt;br /&gt;
IF (EDX:EAX = TEMP64)&lt;br /&gt;
THEN&lt;br /&gt;
ZF ← 1;&lt;br /&gt;
DEST ← ECX:EBX;&lt;br /&gt;
ELSE&lt;br /&gt;
ZF ← 0;&lt;br /&gt;
EDX:EAX ← TEMP64;&lt;br /&gt;
DEST ← TEMP64;&lt;br /&gt;
FI;&lt;br /&gt;
FI;&lt;br /&gt;
FI;&lt;/p&gt;
&lt;h1 id=&#34;renference&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#renference&#34;&gt;#&lt;/a&gt; Renference&lt;/h1&gt;
&lt;p&gt;Intel 白皮书第二卷&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjI3MjM1L2FydGljbGUvZGV0YWlscy84MDM2ODI1NA==&#34;&gt; https://blog.csdn.net/qq_41627235/article/details/80368254&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy81MThkM2U4NWRmMzZhMzJkNzM3NWE0MTc4NjZmYjg0YWU0NWNjMzg2Lmh0bWw=&#34;&gt;https://wenku.baidu.com/view/518d3e85df36a32d7375a417866fb84ae45cc386.html&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWhlamlhbzE1MTYvYXJ0aWNsZS9kZXRhaWxzLzEwMDg3NTEwNQ==&#34;&gt;https://blog.csdn.net/chuhejiao1516/article/details/100875105&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzM1ODkuaHRtbA==&#34;&gt;http://c.biancheng.net/view/3589.html&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
