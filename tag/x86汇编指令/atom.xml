<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Or0kit.github.io</id>
    <title>Or0kit • Posts by &#34;x86汇编指令&#34; tag</title>
    <link href="https://Or0kit.github.io" />
    <updated>2021-03-24T12:19:17.000Z</updated>
    <category term="Algolia" />
    <category term="同义词替换" />
    <category term="Drozer" />
    <category term="xpath" />
    <category term="win32api" />
    <category term="WOW64" />
    <category term="windows消息机制" />
    <category term="虚拟内存" />
    <category term="jsDelivr" />
    <category term="First blog" />
    <category term="markdown 学习" />
    <category term="Android" />
    <category term="数论基础" />
    <category term="替换密钥" />
    <category term="ADB" />
    <category term="雷电模拟器" />
    <category term="Hadoop" />
    <category term="IDA" />
    <category term="Windows逆向" />
    <category term="SSH隧道" />
    <category term="url" />
    <category term="http" />
    <category term="Linux" />
    <category term="Nginx" />
    <category term="CentOS7配置vsftp" />
    <category term="Psad" />
    <category term="fwsnort" />
    <category term="应急响应" />
    <category term="x86汇编指令" />
    <category term="PE课后作业" />
    <category term="MFC" />
    <category term="PE查看器" />
    <category term="PE结构" />
    <category term="DOS头属性说明" />
    <category term="标准PE头属性说明" />
    <category term="扩展PE头属性说明" />
    <category term="节表属性说明" />
    <category term="空白区添加代码" />
    <category term="RVA与FOA" />
    <category term="合并节" />
    <category term="注入" />
    <category term="导入表注入" />
    <category term="导出表" />
    <category term="导入表" />
    <category term="扩大节" />
    <category term="新增节" />
    <category term="移动NT头" />
    <category term="移动导出表" />
    <category term="移动重定位表" />
    <category term="重定位表" />
    <category term="静态链接库" />
    <category term="动态链接库" />
    <category term="句柄" />
    <category term="逆向" />
    <category term="IDA学习" />
    <category term="静态分析基础" />
    <category term="动态分析技术基础" />
    <category term="恶意代码分析实战入门" />
    <category term="加壳" />
    <category term="脱壳" />
    <category term="C++壳" />
    <category term="ESP寻址" />
    <category term="定位Win32窗口回调函数" />
    <category term="HOOK攻防" />
    <category term="瞬时HOOK过检测" />
    <category term="INLINE-HOOK" />
    <category term="IAT HOOK" />
    <category term="INLINE HOOK" />
    <category term="进程监控" />
    <category term="模块隐藏" />
    <category term="进程通信" />
    <category term="tlhelp32.h" />
    <category term="进程遍历" />
    <category term="模块遍历" />
    <category term="外挂原理" />
    <category term="DLL注入之进程间通信" />
    <category term="TEB" />
    <category term="PEB" />
    <category term="R3层断链" />
    <category term="Win临界区" />
    <category term="Win事件" />
    <category term="线程同步" />
    <category term="Win互斥体" />
    <category term="内存映射文件" />
    <category term="内存映射共享" />
    <category term="写拷贝" />
    <category term="Win子窗口控件" />
    <category term="win32文件函数" />
    <category term="代码注入" />
    <category term="窗口程序" />
    <category term="消息机制" />
    <category term="消息类型" />
    <category term="私有内存" />
    <category term="共享内存" />
    <category term="设备对象" />
    <category term="DC设备上下文" />
    <category term="图形对象" />
    <category term="创建线程" />
    <category term="线程控制" />
    <category term="线程相关API" />
    <category term="线程上下文" />
    <category term="CONTEXT结构体" />
    <category term="物理内存" />
    <category term="Windows进程" />
    <category term="句柄表" />
    <category term="远程线程函数" />
    <category term="远程线程" />
    <category term="DLL注入" />
    <category term="DLL注入相关函数" />
    <category term="WinMain函数" />
    <category term="调用约定" />
    <category term="我的GetProcAddress" />
    <category term="资源文件" />
    <category term="消息断点" />
    <category term="通用控件" />
    <category term="WM_NOTIFY消息类型" />
    <category term="CobaltStrike" />
    <category term="Apeache" />
    <category term="Nmap" />
    <category term="php" />
    <category term="guestbook" />
    <category term="SQLmap" />
    <category term="apache" />
    <category term="log" />
    <category term="mysql主键" />
    <category term="CSRF" />
    <category term="SSRF" />
    <category term="业务逻辑漏洞" />
    <category term="xss" />
    <category term="webshell流量特征" />
    <category term="虚拟网卡" />
    <category term="RedTeam" />
    <category term="python" />
    <category term="SSH" />
    <category term="python文件读取" />
    <category term="数据分析" />
    <category term="socket" />
    <category term="数据库编程" />
    <category term="python内置属性" />
    <category term="scrapy" />
    <category term="测试" />
    <category term="BHP" />
    <category term="Python的import功能" />
    <category term="木马" />
    <category term="button" />
    <category term="multiprocessing" />
    <category term="threading" />
    <category term="单选框" />
    <category term="复选框件" />
    <category term="Edit" />
    <category term="Combo Box" />
    <category term="Tab" />
    <category term="ListCtrl" />
    <category term="MFC的本质" />
    <category term="MFC的层次结构图" />
    <category term="手动创建一个MFC程序" />
    <category term="MFC的初始化过程" />
    <category term="MFC运行时类型识别" />
    <category term="关键字static" />
    <category term="关键字const" />
    <category term="MFC动态创建" />
    <category term="MFC消息映射" />
    <category term="结构体AFX_MSGMAP_ENTRY" />
    <category term="结构体AFX_MSGM" />
    <category term="MFC的三大类消息" />
    <category term="数据传输" />
    <category term="ini文件的读写" />
    <category term="非可变序列算法" />
    <category term="可变序列算法" />
    <category term="排序算法" />
    <category term="迭代器" />
    <category term="使用自定义对象" />
    <category term="0环与3环的通信（常规方法）" />
    <category term="内核空间" />
    <category term="内核模块" />
    <category term="遍历内核模块" />
    <category term="定位未导出函数PspTiminateProcess" />
    <category term="内核编程基础" />
    <category term="ANSI_STRING" />
    <category term="UNICODE_STRING" />
    <category term="内核内存" />
    <category term="上下文环境" />
    <category term="中断请求级别" />
    <category term="链表" />
    <category term="自旋锁" />
    <category term="注册表" />
    <category term="地址空间" />
    <category term="文件操作" />
    <category term="线程与事件" />
    <category term="内核重载" />
    <category term="配置VS2019+WDK10" />
    <category term="第一个驱动程序" />
    <category term="驱动调试" />
    <category term="调试驱动程序" />
    <category term="OpenSCManager" />
    <category term="CreateService" />
    <category term="APC的本质" />
    <category term="APC的备用队列" />
    <category term="线性地址的管理" />
    <category term="VAD树" />
    <category term="_MMVAD" />
    <category term="_MMVAD_FLAGS" />
    <category term="VirtualAlloc" />
    <category term="MEM_COMMIT与MEM_RESERVE" />
    <category term="malloc" />
    <category term="堆内存" />
    <category term="栈内存" />
    <category term="全局区内存" />
    <category term="共享物理页" />
    <category term="共享文件" />
    <category term="LoadLibrary的本质" />
    <category term="MmAddPhysicalMemoryEx" />
    <category term="缺页异常" />
    <category term="消息队列" />
    <category term="PsConvertToGuiThread" />
    <category term="win32k.sys" />
    <category term="GUI线程" />
    <category term="窗口程序的创建" />
    <category term="消息循环" />
    <category term="临界区" />
    <category term="KPCR结构体" />
    <category term="模拟线程切换" />
    <category term="模拟挂起与恢复函数" />
    <category term="等待链表" />
    <category term="调度链表" />
    <category term="ETHREAD" />
    <category term="KTHREAD" />
    <category term="进程的创建" />
    <category term="获取当前进程" />
    <category term="EPROCESS" />
    <category term="KPROCESS" />
    <category term="2-9-9-12分页" />
    <category term="PAE" />
    <category term="PDPTE" />
    <category term="PDE" />
    <category term="PTE" />
    <category term="XD标志位" />
    <category term="逆向分析MmIsAddressValid函数(2-9-9-12)" />
    <category term="PWT" />
    <category term="PDT" />
    <category term="TLB" />
    <category term="CPU缓存" />
    <category term="INVLPG指令" />
    <category term="全局页" />
    <category term="ShadowWalker" />
    <category term="中断" />
    <category term="异常" />
    <category term="CLI指令" />
    <category term="STI指令" />
    <category term="INT2" />
    <category term="INT8" />
    <category term="中断门描述符" />
    <category term="IDT" />
    <category term="提权" />
    <category term="跨段跳转流程" />
    <category term="JMP FAR指令" />
    <category term="TSS" />
    <category term="任务门" />
    <category term="LDT段描述符" />
    <category term="LDT" />
    <category term="CR0" />
    <category term="CR2" />
    <category term="CR4" />
    <category term="段寄存器结构" />
    <category term="段描述符" />
    <category term="段选择子" />
    <category term="GDT表" />
    <category term="CRL" />
    <category term="DPL" />
    <category term="RPL" />
    <category term="调用门" />
    <category term="调用门描述符" />
    <category term="逆向分析MmIsAddressValid函数" />
    <category term="CALL与CALL FAR" />
    <category term="error C2143" />
    <category term="error C2275" />
    <category term="陷阱门描述符" />
    <category term="页目录表基址" />
    <category term="页表的基址" />
    <category term="0地址执行ShellCode" />
    <category term="10-10-12分页" />
    <category term="PDE_PTE" />
    <category term="物理页" />
    <category term="SSDT HOOK" />
    <category term="OpenProcess" />
    <category term="系统服务表" />
    <category term="SSDT" />
    <category term="SSDT HOOK隐藏" />
    <category term="API进出内核" />
    <category term="系统调用阶段总结" />
    <category term="网络安全法" />
    <category term="ASCII" />
    <category term="GBK" />
    <category term="ANSI" />
    <category term="Unicode" />
    <category term="UTF-8" />
    <category term="URL 编码/解码" />
    <category term="十进制" />
    <category term="二进制" />
    <category term="十六进制" />
    <category term="内存" />
    <category term="编写ShellCode实现IAT HOOK" />
    <category term="ShellCode原则" />
    <category term="加载图标" />
    <category term="提取图标" />
    <category term="资源表" />
    <category term="傀儡进程加密壳" />
    <category term="ZwUnmapViewOfSection函数" />
    <category term="HTML" />
    <category term="文件包含" />
    <category term="sql注入" />
    <category term="MFC命令传递" />
    <category term="远控界面编写" />
    <category term="STL" />
    <category term="Vector容器" />
    <category term="Deque容器" />
    <category term="List容器" />
    <category term="Set容器" />
    <category term="Multiset容器" />
    <category term="Map容器" />
    <category term="Multimap容器" />
    <category term="Stack容器" />
    <category term="Queue容器" />
    <category term="priority_queue容器" />
    <category term="经典定长指令" />
    <category term="经典变长指令" />
    <category term="指令前缀" />
    <category term="KAPC" />
    <category term="QueueUserAPC" />
    <category term="NtQueueApcThread" />
    <category term="KeInitializeApc" />
    <category term="KeInsertQueueApc" />
    <category term="KiInsertQueueApc" />
    <category term="进程句柄表" />
    <category term="全局句柄表" />
    <category term="消息队列与线程" />
    <category term="Windows线程切换" />
    <category term="KiSwapContext" />
    <category term="SwapContext" />
    <category term="时钟中断" />
    <category term="时间片管理" />
    <category term="线程切换与TSS" />
    <category term="线程切换与FS" />
    <category term="线程切换与线程优先级" />
    <category term="快速调用" />
    <category term="中断调用" />
    <category term="分析ReadProcessMemory" />
    <category term="KiFastSystemCall" />
    <category term="KiIntSystemCall" />
    <category term="重写3环" />
    <category term="文件上传" />
    <category term="隐藏驱动" />
    <category term="IopLoadDriver" />
    <category term="延迟过程调用" />
    <category term="进程挂靠" />
    <category term="跨进程读写内存" />
    <category term="APC" />
    <category term="逆向分析NtReadVirtualMemory" />
    <category term="逆向分析NtWriteVIrtualMemory" />
    <category term="payload" />
    <category term="AD-Attack-Defense" />
    <category term="sysenter指令" />
    <category term="KiFastCallEntry函数" />
    <category term="KiSystemService函数" />
    <category term="Trap_Frame" />
    <category term="web安全" />
    <category term="Pentest" />
    <entry>
        <id>https://or0kit.github.io/Bin/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</id>
        <title>汇编学习</title>
        <link rel="alternate" href="https://or0kit.github.io/Bin/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
        <content type="html">&lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;之前学的，因为一些事情就耽搁了，转而学其他的了，现在有时间了，打算接着学。&lt;/p&gt;
&lt;h1 id=&#34;内存格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存格式&#34;&gt;#&lt;/a&gt; 内存格式&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;每个内存单元宽度为 8&lt;/li&gt;
&lt;li&gt;【0x 编号】称为内存地址&lt;/li&gt;
&lt;li&gt;内存是存储数据的，内存地址是对存储数据的一个标识，指向数据却不是数据，通过内存地址的指引，可以访问到内存当中指向的数据.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内存最小的单位是一个字节 ==&amp;gt;&amp;gt; 8 个二进制数  ==&amp;gt;&amp;gt; 两位的十六进制数&lt;/p&gt;
&lt;p&gt;一个内存单元能存一个两位的十六进制数，而这就是内存数据&lt;/p&gt;
&lt;h1 id=&#34;简单指令intel汇编语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简单指令intel汇编语法&#34;&gt;#&lt;/a&gt; 简单指令 (intel 汇编语法)&lt;/h1&gt;
&lt;h2 id=&#34;mov&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mov&#34;&gt;#&lt;/a&gt; mov&lt;/h2&gt;
&lt;p&gt;格式：  &lt;code&gt;mov destination, source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov eax, ebx&lt;/code&gt;   // 将 EBX 中的内容复制到 EAX 寄存器中&lt;br /&gt;
 &lt;code&gt;mov eax, 0x42&lt;/code&gt;  // 将立即数 0x42 复制到 EAX 寄存器中&lt;br /&gt;
 &lt;code&gt;mov eax, [0x443212C4]&lt;/code&gt;  // 将内存地址 0x443212C4 的四个字节复制到 EAX 寄存器&lt;br /&gt;
 &lt;code&gt;mov eax, [ebx+esi*4]&lt;/code&gt;   // 将 ebx+esi*4 等式结果只想的内存地址处 4 个字节复制至 EAX&lt;/p&gt;
&lt;h2 id=&#34;lea&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lea&#34;&gt;#&lt;/a&gt; lea&lt;/h2&gt;
&lt;p&gt;格式：  &lt;code&gt;lea destination, source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;lea 指令用来将一个内存地址赋给目的操作数。&lt;br /&gt;
例如，  &lt;code&gt;lea eax, [ebx+8]&lt;/code&gt;  就是将 EBX+8 的值给 EAX。&lt;br /&gt;
相反的， &lt;code&gt;mov eax, [ebx+8]&lt;/code&gt;  则加载内存中地址为 EBX+8 处的数据。&lt;/p&gt;
&lt;h2 id=&#34;加减运算sub-add-inc-dec&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加减运算sub-add-inc-dec&#34;&gt;#&lt;/a&gt; 加减运算：sub add inc dec&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;label&#34;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指令&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sub eax,0x10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX 寄存器值减去 0x10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add eax,ebx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将 EBX 值加入 EAX 并将结果保存至 EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;inc edx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX 值递增 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dec ecx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ECX 值递减 1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;乘除运算mul-div&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#乘除运算mul-div&#34;&gt;#&lt;/a&gt; 乘除运算:mul div&lt;/h2&gt;
&lt;p&gt;乘法和除法都使用了一个预先规定的寄存器。因此其运算就是指令码加上寄存器要去乘除的值。&lt;br /&gt;
 &lt;code&gt;mul&lt;/code&gt;  和 &lt;code&gt;div&lt;/code&gt;  指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。&lt;br /&gt;
 &lt;code&gt;mul value&lt;/code&gt;  指令总是将 &lt;code&gt;eax&lt;/code&gt;  乘上 &lt;code&gt;value&lt;/code&gt; 。因此， &lt;code&gt;EAX&lt;/code&gt;  寄存器必须在乘法指令出现前就赋值好。&lt;/p&gt;
&lt;p&gt;乘法的结果以 64 位的形式分开存储在两个寄存器中： &lt;code&gt;EDX&lt;/code&gt;  和 &lt;code&gt;EAX&lt;/code&gt; 。其中 EDX 存储了高的 32 位，EAX 存储低的 32 位。&lt;/p&gt;
&lt;p&gt;32 位模式下，MUL（无符号数乘法）指令有三种类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一种执行 8 位操作数与 AL 寄存器的乘法；
第二种执行 16 位操作数与 AX 寄存器的乘法；
第三种执行 32 位操作数与 EAX 寄存器的乘法。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MUL reg/mem8
MUL reg/meml6
MUL reg/mem32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被乘数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;乘数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AL&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DX:AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX:EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。&lt;/p&gt;
&lt;p&gt;有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。&lt;/p&gt;
&lt;p&gt;32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DIV reg/mem8
DIV reg/meml6
DIV reg/mem32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下表给出了被除数、除数、商和余数之间的关系：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被除数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;除数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;商&lt;/td&gt;
&lt;td&gt;余数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AL&lt;/td&gt;
&lt;td&gt;AH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DX:AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td&gt;DX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX:EAX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX&lt;/td&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数，商存放到 RAX，余数存放在 RDX 中。&lt;/p&gt;
&lt;h2 id=&#34;否操作指令not&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#否操作指令not&#34;&gt;#&lt;/a&gt; 否操作指令 NOT&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;NOT OPRD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把 OPRD 取反，再回送给 OPRD&lt;/p&gt;
&lt;p&gt;对标志位没有影响&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;与操作指令and与&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#与操作指令and与&#34;&gt;#&lt;/a&gt; 与操作指令 AND [与]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AND OPRD1，OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;OPRD1 和 OPRD2 执行与操作，结果送到 OPRD1&lt;/p&gt;
&lt;p&gt;执行后，CF＝OF＝0，标志 PF，ZF，SF 反映运算结果，AF 未定义&lt;/p&gt;
&lt;p&gt;某个操作数自身与，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;label&#34;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov al, 00001111b&lt;/code&gt; &lt;br /&gt;
 &lt;code&gt;and al, 11110101b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后 &lt;code&gt;al&lt;/code&gt;  的结果就是 &lt;code&gt;00000101b&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;或操作指令 OR [或]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;OR OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标志位同与运算指令&lt;/p&gt;
&lt;p&gt;某个操作数自身或，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image002.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;异或操作指令xor异或&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异或操作指令xor异或&#34;&gt;#&lt;/a&gt; 异或操作指令 XOR [异或]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XOR OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标志位同与运算指令&lt;/p&gt;
&lt;p&gt;某个操作数自身异或，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;与 0 异或，不变，与 1 异或，取反。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image004.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;测试指令test&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#测试指令test&#34;&gt;#&lt;/a&gt; 测试指令 TEST&lt;/h2&gt;
&lt;p&gt;指令格式：TEST  R/M,R/M/IMM&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEST OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指令与 AND 类似，但结果不回送&lt;/p&gt;
&lt;p&gt;指令执行后，ZF，PF，SF 反映运算结果，CF＝OF＝0&lt;/p&gt;
&lt;p&gt;该指令在一定程序上和 CMP 指令时类似的，两个数值进行与操作，结果不保存，但是会改变相应标志位.&lt;/p&gt;
&lt;p&gt;与的操作表项如下：&lt;/p&gt;
&lt;p&gt;1 and 1 = 1	&lt;br /&gt;
1 and 0 = 0&lt;br /&gt;
0 and 1 = 0&lt;br /&gt;
0 and 0 = 0&lt;/p&gt;
&lt;p&gt;常见用法：用这个指令，可以确定某寄存器是否等于 0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEST EAX,EAX&lt;/code&gt; 			观察 Z 位&lt;/p&gt;
&lt;p&gt;但是如果 EAX 的二进制某些位为 1 的话，那么运算的结果就不为零。&lt;/p&gt;
&lt;h2 id=&#34;cmp指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cmp指令&#34;&gt;#&lt;/a&gt; CMP 指令&lt;/h2&gt;
&lt;p&gt;指令格式：CMP  R/M,R/M/IMM&lt;/p&gt;
&lt;p&gt;该指令是比较两个操作数，实际上，它相当于 SUB 指令，但是相减的结构并不保存到第一个操作数中。&lt;/p&gt;
&lt;p&gt;只是根据相减的结果来改变零标志位的，当两个操作数相等的时候，零标志位置 1。&lt;/p&gt;
&lt;h2 id=&#34;移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#移位指令&#34;&gt;#&lt;/a&gt; 移位指令&lt;/h2&gt;
&lt;p&gt;移位指令分为算术移位和逻辑移位。&lt;/p&gt;
&lt;p&gt;移动操作数的位有两种方法。第一种是逻辑移位 (logic shift)，空出来的位用 0 填充。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。注意，位 7 被填充为 0：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image005.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下图所示为二进制数 1100 1111 逻辑右移一位，得到 0110 0111。最低位移入进位标志位：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image006.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;另一种移位的方法是算术移位 (arithmetic shift)，空出来的位用原数据的符号位填充：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;例如，二进制数 1100 1111，符号位为 1。算术右移一位后，得到 1110 0111：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;逻辑移位:   &lt;code&gt;SHL&lt;/code&gt; 、 &lt;code&gt;SHR&lt;/code&gt; &lt;br /&gt;
 算术移位:   &lt;code&gt;CAL&lt;/code&gt; 、 &lt;code&gt;CAR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无符号数的乘法和除法可以用逻辑移位；&lt;br /&gt;
 有符号数的乘法和除法可以用算术移位；&lt;/p&gt;
&lt;h3 id=&#34;逻辑移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#逻辑移位指令&#34;&gt;#&lt;/a&gt; 逻辑移位指令&lt;/h3&gt;
&lt;p&gt;SHL（左移）指令使目的操作数逻辑左移一位，最低位用 0 填充。最高位移入进位标志位，而进位标志位中原来的数值被丢弃&lt;br /&gt;
 SHR（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。最低位复制到进位标志位，而进位标志位中原来的数值被丢弃&lt;/p&gt;
&lt;p&gt;SHL/SHR 的第一个操作数是目的操作数，第二个操作数是移位次数：&lt;br /&gt;
SHL/SHR destination,count&lt;/p&gt;
&lt;p&gt;该指令可用的操作数类型如下所示：&lt;br /&gt;
SHL/SHR reg, imm8&lt;br /&gt;
SHL/SHR mem, imm8&lt;br /&gt;
SHL/SHR reg, CL&lt;br /&gt;
SHL/SHR mem, CL&lt;/p&gt;
&lt;p&gt;x86 处理器允许 imm8 为 0〜255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和 RCL 指令。&lt;/p&gt;
&lt;h3 id=&#34;算术移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#算术移位指令&#34;&gt;#&lt;/a&gt; 算术移位指令&lt;/h3&gt;
&lt;p&gt;算数移位指令分为：算数左移 SAL (Shift Algebraic Left) 和算数右移 SAR (Shift Algebraic Right);&lt;br /&gt;
 指令格式:  &lt;code&gt;SAL/SAR reg/mem,CL/imm&lt;/code&gt; &lt;br /&gt;
 受影响的标志位：CF,OF,PF,SF,ZF; 对 AF 的影响无定义；&lt;/p&gt;
&lt;h3 id=&#34;循环移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#循环移位指令&#34;&gt;#&lt;/a&gt; 循环移位指令&lt;/h3&gt;
&lt;p&gt;循环移位指令 ror 和 rol 与移位指令类似，但移出的那一位会被填到另一端空出来的位置上，即右循环指令（ror）会将最低位循环一到最高位；左循环移位（rol）则相反。&lt;/p&gt;
&lt;h2 id=&#34;nop指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nop指令&#34;&gt;#&lt;/a&gt; NOP 指令&lt;/h2&gt;
&lt;p&gt;nop 指令什么也不做。当它出现时，直接执行下一条指令。&lt;br /&gt;
nop 指令实际上是 xchg eax,eax 的一个谓名字&lt;/p&gt;
&lt;h2 id=&#34;push-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#push-指令&#34;&gt;#&lt;/a&gt; push 指令&lt;/h2&gt;
&lt;h2 id=&#34;pop-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pop-指令&#34;&gt;#&lt;/a&gt; pop 指令&lt;/h2&gt;
&lt;h1 id=&#34;rep-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rep-指令&#34;&gt;#&lt;/a&gt; rep 指令&lt;/h1&gt;
&lt;p&gt;按计数寄存器 ecx 中指定的次数重复执行字符串指令&lt;/p&gt;
&lt;p&gt;rep movsd&lt;/p&gt;
&lt;p&gt;取 esi 的值 到 edi 指向的地址&lt;/p&gt;
&lt;h1 id=&#34;pause指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pause指令&#34;&gt;#&lt;/a&gt; pause 指令&lt;/h1&gt;
&lt;p&gt;提高自旋等待循环的性能。当执行 “自旋 - 等待循环” 时，Pentium 4 或 Intel Xeon 处理器在退出循环时会遭受严重的性能损失，因为它检测到可能的内存顺序冲突。PAUSE 指令向处理器提示代码序列是一个自旋 - 等待循环。在大多数情况下，处理器使用这个提示来避免内存顺序冲突，这大大提高了处理器性能。因此，建议在所有自旋 - 等待循环中放置 PAUSE 指令。&lt;/p&gt;
&lt;p&gt;PAUSE 指令的另一个功能是降低 Pentium 4 处理器在执行旋转循环时的功耗。Pentium 4 处理器可以非常快地执行一个自旋 - 等待循环，导致处理器在等待其所旋转的资源变得可用时消耗大量电力。在自旋 - 等待循环中插入暂停指令可以大大降低处理器的功耗。&lt;/p&gt;
&lt;p&gt;这个指令被引入到奔腾 4 处理器中，但它向后兼容所有的 IA-32 处理器。在早期的 IA-32 处理器中，PAUSE 指令就像 NOP 指令一样工作。奔腾 4 和英特尔 Xeon 处理器将 PAUSE 指令实现为预定义延迟。延迟是有限的，对于某些处理器可以是零。该指令不会改变处理器的体系结构状态 (也就是说，它实际上执行了一个延迟的无操作操作)。&lt;/p&gt;
&lt;p&gt;该指令的操作在非 64 位模式和 64 位模式下是相同的。&lt;/p&gt;
&lt;h1 id=&#34;lock指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lock指令&#34;&gt;#&lt;/a&gt; LOCK 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;在伴随指令执行期间断言处理器的 LOCK# 信号 (将指令转换为原子指令)。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;在多处理器环境中，LOCK# 信号确保处理器在断言信号时独占任何共享内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意，在后来的 Intel 64 和 IA-32 处理器 (包括 Pentium 4, Intel Xeon 和 P6 系列处理器) 中，锁可能会在没有 LOCK# 信号的情况下发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCK 前缀只能放在以下指令的前面，并且只能放在目的操作数为内存操作数的指令的前面：ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD 和 XCHG。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 LOCK 前缀与这些指令中的一个一起使用，并且源操作数是内存操作数，则可能会生成一个未定义的操作码异常 (#UD)。&lt;br /&gt;
如果 LOCK 前缀与任何不在上面列表中的指令一起使用，也会生成一个未定义的操作码异常。&lt;br /&gt;
XCHG 指令总是对 LOCK# 信号进行断言，而不管 LOCK 前缀是否存在。&lt;br /&gt;
LOCK 前缀通常与 BTS 指令一起使用，在共享内存环境中的内存位置上执行 read-modifywrite 操作。&lt;br /&gt;
LOCK 前缀的完整性不受内存字段对齐的影响。&lt;br /&gt;
内存锁定在任意错位的字段中被观察到。&lt;br /&gt;
该指令的操作在非 64 位模式和 64 位模式下是相同的&lt;/p&gt;
&lt;h2 id=&#34;protected-mode-exceptions&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#protected-mode-exceptions&#34;&gt;#&lt;/a&gt; Protected Mode Exceptions&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#UD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 LOCK 前缀与以下未列出的指令一起使用: ADD,ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC,NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG，就会产生异常。&lt;/p&gt;
&lt;p&gt;其他异常可以由该指令在应用 LOCK 前缀时生成。&lt;/p&gt;
&lt;h1 id=&#34;xadd-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#xadd-指令&#34;&gt;#&lt;/a&gt; xadd 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;将第一个操作数 (目标操作数) 与第二个操作数 (源操作数) 交换，然后将两个值的和加载到目标操作数中。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;目标操作数可以是寄存器或内存位置； 源操作数是一个寄存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 64 位模式下，指令的默认操作大小是 32 位。&lt;/p&gt;
&lt;p&gt;以 REX 的形式使用 REX 前缀。R 允许访问附加寄存器 (R8-R15)。以 REX 的形式使用 REX 前缀。W 将操作提升到 64 位。有关编码数据和限制，请参阅本节开头的汇总图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;bts指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bts指令&#34;&gt;#&lt;/a&gt; bts 指令&lt;/h1&gt;
&lt;p&gt;例子：  &lt;code&gt;lock bts dword ptr [esi], 0 ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BTS 指令的作用：&lt;br /&gt;
两件事:&lt;br /&gt;
 一、&lt;br /&gt;
&lt;strong&gt;取 esi 比特位的第 0 位存在 CF 标志位中。&lt;/strong&gt;&lt;br /&gt;
二、&lt;br /&gt;
 &lt;code&gt;lock bts dword ptr [esi],0&lt;/code&gt; &lt;br /&gt;
&lt;strong&gt; 将 dword ptr [esi] 指向的内存地址的第 0 位置 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;cmpxchg8b-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cmpxchg8b-指令&#34;&gt;#&lt;/a&gt; cmpxchg8b 指令&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;CMPXCHG8B m64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比较 EDX:EAX 中的 64 位值 (或 RDX:RAX 中的 128 位值，如果操作数是 128 位) 和操作数 (目的操作数)。&lt;br /&gt;
如果两个值相等，则目标操作数中存储 ECX:EBX 中的 64 位值 (或 RCX:RBX 中的 128 位值)。&lt;br /&gt;
否则，目标操作数中的值被加载到 EDX:EAX (或 RDX:RAX) 中。&lt;br /&gt;
目标操作数是一个 8 字节内存位置 (如果操作数大小为 128 位，则为 16 字节内存位置)。&lt;br /&gt;
对于 EDX:EAX 和 ECX:EBX 寄存器对，EDX 和 ECX 包含高阶 32 位，EAX 和 EBX 包含 64 位值的低阶 32 位。&lt;br /&gt;
对于 RDX:RAX 和 RCX:RBX 寄存器对，RDX 和 RCX 为高 64 位，RAX 和 RBX 为 128 位的低 64 位。&lt;br /&gt;
该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/p&gt;
&lt;h2 id=&#34;operation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#operation&#34;&gt;#&lt;/a&gt; Operation&lt;/h2&gt;
&lt;p&gt;IF (64-Bit Mode and OperandSize = 64)&lt;br /&gt;
THEN&lt;br /&gt;
TEMP128 ← DEST&lt;br /&gt;
IF (RDX:RAX = TEMP128)&lt;br /&gt;
THEN&lt;br /&gt;
ZF ← 1;&lt;br /&gt;
DEST ← RCX:RBX;&lt;br /&gt;
ELSE&lt;br /&gt;
ZF ← 0;&lt;br /&gt;
RDX:RAX ← TEMP128;&lt;br /&gt;
DEST ← TEMP128;&lt;br /&gt;
FI;&lt;br /&gt;
FI&lt;br /&gt;
ELSE&lt;br /&gt;
TEMP64 ← DEST;&lt;br /&gt;
IF (EDX:EAX = TEMP64)&lt;br /&gt;
THEN&lt;br /&gt;
ZF ← 1;&lt;br /&gt;
DEST ← ECX:EBX;&lt;br /&gt;
ELSE&lt;br /&gt;
ZF ← 0;&lt;br /&gt;
EDX:EAX ← TEMP64;&lt;br /&gt;
DEST ← TEMP64;&lt;br /&gt;
FI;&lt;br /&gt;
FI;&lt;br /&gt;
FI;&lt;/p&gt;
&lt;h1 id=&#34;renference&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#renference&#34;&gt;#&lt;/a&gt; Renference&lt;/h1&gt;
&lt;p&gt;Intel 白皮书第二卷&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjI3MjM1L2FydGljbGUvZGV0YWlscy84MDM2ODI1NA==&#34;&gt; https://blog.csdn.net/qq_41627235/article/details/80368254&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy81MThkM2U4NWRmMzZhMzJkNzM3NWE0MTc4NjZmYjg0YWU0NWNjMzg2Lmh0bWw=&#34;&gt;https://wenku.baidu.com/view/518d3e85df36a32d7375a417866fb84ae45cc386.html&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWhlamlhbzE1MTYvYXJ0aWNsZS9kZXRhaWxzLzEwMDg3NTEwNQ==&#34;&gt;https://blog.csdn.net/chuhejiao1516/article/details/100875105&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzM1ODkuaHRtbA==&#34;&gt;http://c.biancheng.net/view/3589.html&lt;/span&gt;&lt;/p&gt;
</content>
        <category term="x86汇编指令" />
        <updated>2021-03-24T12:19:17.000Z</updated>
    </entry>
</feed>
