<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Or0kit.github.io</id>
    <title>Or0kit • Posts by &#34;x64&#34; tag</title>
    <link href="https://Or0kit.github.io" />
    <updated>2022-06-27T08:55:08.000Z</updated>
    <category term="Algolia" />
    <category term="Drozer" />
    <category term="同义词替换" />
    <category term="xpath" />
    <category term="win32api" />
    <category term="WOW64" />
    <category term="windows消息机制" />
    <category term="虚拟内存" />
    <category term="jsDelivr" />
    <category term="First blog" />
    <category term="markdown 学习" />
    <category term="Android" />
    <category term="替换密钥" />
    <category term="数论基础" />
    <category term="ADB" />
    <category term="雷电模拟器" />
    <category term="Hadoop" />
    <category term="IDA" />
    <category term="Windows逆向" />
    <category term="SSH隧道" />
    <category term="url" />
    <category term="http" />
    <category term="应急响应" />
    <category term="Nginx" />
    <category term="Linux" />
    <category term="CentOS7配置vsftp" />
    <category term="Psad" />
    <category term="fwsnort" />
    <category term="x86汇编指令" />
    <category term="动态分析技术基础" />
    <category term="静态分析基础" />
    <category term="逆向" />
    <category term="IDA学习" />
    <category term="恶意代码分析实战入门" />
    <category term="加壳" />
    <category term="脱壳" />
    <category term="C++壳" />
    <category term="ESP寻址" />
    <category term="定位Win32窗口回调函数" />
    <category term="HOOK攻防" />
    <category term="瞬时HOOK过检测" />
    <category term="INLINE-HOOK" />
    <category term="IAT HOOK" />
    <category term="INLINE HOOK" />
    <category term="进程监控" />
    <category term="模块隐藏" />
    <category term="进程通信" />
    <category term="tlhelp32.h" />
    <category term="进程遍历" />
    <category term="模块遍历" />
    <category term="外挂原理" />
    <category term="DLL注入之进程间通信" />
    <category term="TEB" />
    <category term="PEB" />
    <category term="R3层断链" />
    <category term="Win临界区" />
    <category term="Win事件" />
    <category term="线程同步" />
    <category term="Win互斥体" />
    <category term="内存映射文件" />
    <category term="内存映射共享" />
    <category term="写拷贝" />
    <category term="Win子窗口控件" />
    <category term="win32文件函数" />
    <category term="代码注入" />
    <category term="窗口程序" />
    <category term="消息机制" />
    <category term="消息类型" />
    <category term="私有内存" />
    <category term="共享内存" />
    <category term="设备对象" />
    <category term="DC设备上下文" />
    <category term="图形对象" />
    <category term="创建线程" />
    <category term="线程控制" />
    <category term="线程相关API" />
    <category term="线程上下文" />
    <category term="CONTEXT结构体" />
    <category term="物理内存" />
    <category term="Windows进程" />
    <category term="句柄表" />
    <category term="远程线程函数" />
    <category term="远程线程" />
    <category term="DLL注入" />
    <category term="DLL注入相关函数" />
    <category term="WinMain函数" />
    <category term="调用约定" />
    <category term="我的GetProcAddress" />
    <category term="资源文件" />
    <category term="消息断点" />
    <category term="PE课后作业" />
    <category term="通用控件" />
    <category term="WM_NOTIFY消息类型" />
    <category term="MFC" />
    <category term="PE查看器" />
    <category term="RVA与FOA" />
    <category term="PE结构" />
    <category term="DOS头属性说明" />
    <category term="标准PE头属性说明" />
    <category term="扩展PE头属性说明" />
    <category term="节表属性说明" />
    <category term="空白区添加代码" />
    <category term="合并节" />
    <category term="导入表" />
    <category term="注入" />
    <category term="导入表注入" />
    <category term="导出表" />
    <category term="扩大节" />
    <category term="新增节" />
    <category term="移动NT头" />
    <category term="移动导出表" />
    <category term="移动重定位表" />
    <category term="重定位表" />
    <category term="静态链接库" />
    <category term="动态链接库" />
    <category term="句柄" />
    <category term="CobaltStrike" />
    <category term="RedTeam" />
    <category term="Apeache" />
    <category term="php" />
    <category term="Nmap" />
    <category term="guestbook" />
    <category term="SQLmap" />
    <category term="apache" />
    <category term="log" />
    <category term="mysql主键" />
    <category term="CSRF" />
    <category term="SSRF" />
    <category term="业务逻辑漏洞" />
    <category term="xss" />
    <category term="webshell流量特征" />
    <category term="虚拟网卡" />
    <category term="button" />
    <category term="单选框" />
    <category term="复选框件" />
    <category term="Edit" />
    <category term="Combo Box" />
    <category term="Tab" />
    <category term="ListCtrl" />
    <category term="MFC的本质" />
    <category term="MFC的层次结构图" />
    <category term="手动创建一个MFC程序" />
    <category term="MFC的初始化过程" />
    <category term="MFC运行时类型识别" />
    <category term="关键字static" />
    <category term="关键字const" />
    <category term="MFC动态创建" />
    <category term="MFC消息映射" />
    <category term="结构体AFX_MSGMAP_ENTRY" />
    <category term="结构体AFX_MSGM" />
    <category term="MFC的三大类消息" />
    <category term="数据传输" />
    <category term="ini文件的读写" />
    <category term="python" />
    <category term="SSH" />
    <category term="python文件读取" />
    <category term="数据分析" />
    <category term="socket" />
    <category term="数据库编程" />
    <category term="python内置属性" />
    <category term="multiprocessing" />
    <category term="threading" />
    <category term="scrapy" />
    <category term="测试" />
    <category term="BHP" />
    <category term="Python的import功能" />
    <category term="木马" />
    <category term="非可变序列算法" />
    <category term="可变序列算法" />
    <category term="排序算法" />
    <category term="迭代器" />
    <category term="使用自定义对象" />
    <category term="0环与3环的通信（常规方法）" />
    <category term="内核空间" />
    <category term="内核模块" />
    <category term="遍历内核模块" />
    <category term="定位未导出函数PspTiminateProcess" />
    <category term="内核编程基础" />
    <category term="ANSI_STRING" />
    <category term="UNICODE_STRING" />
    <category term="内核内存" />
    <category term="上下文环境" />
    <category term="中断请求级别" />
    <category term="链表" />
    <category term="自旋锁" />
    <category term="注册表" />
    <category term="地址空间" />
    <category term="文件操作" />
    <category term="线程与事件" />
    <category term="内核重载" />
    <category term="配置VS2019+WDK10" />
    <category term="第一个驱动程序" />
    <category term="驱动调试" />
    <category term="调试驱动程序" />
    <category term="OpenSCManager" />
    <category term="CreateService" />
    <category term="APC的本质" />
    <category term="APC的备用队列" />
    <category term="线性地址的管理" />
    <category term="VAD树" />
    <category term="_MMVAD" />
    <category term="_MMVAD_FLAGS" />
    <category term="共享物理页" />
    <category term="共享文件" />
    <category term="LoadLibrary的本质" />
    <category term="VirtualAlloc" />
    <category term="MEM_COMMIT与MEM_RESERVE" />
    <category term="malloc" />
    <category term="堆内存" />
    <category term="栈内存" />
    <category term="全局区内存" />
    <category term="MmAddPhysicalMemoryEx" />
    <category term="缺页异常" />
    <category term="消息队列" />
    <category term="PsConvertToGuiThread" />
    <category term="win32k.sys" />
    <category term="GUI线程" />
    <category term="窗口程序的创建" />
    <category term="消息循环" />
    <category term="临界区" />
    <category term="KPCR结构体" />
    <category term="模拟线程切换" />
    <category term="模拟挂起与恢复函数" />
    <category term="等待链表" />
    <category term="调度链表" />
    <category term="ETHREAD" />
    <category term="KTHREAD" />
    <category term="进程的创建" />
    <category term="获取当前进程" />
    <category term="EPROCESS" />
    <category term="KPROCESS" />
    <category term="2-9-9-12分页" />
    <category term="PAE" />
    <category term="PDPTE" />
    <category term="PDE" />
    <category term="PTE" />
    <category term="XD标志位" />
    <category term="逆向分析MmIsAddressValid函数(2-9-9-12)" />
    <category term="TLB" />
    <category term="INVLPG指令" />
    <category term="全局页" />
    <category term="ShadowWalker" />
    <category term="PWT" />
    <category term="PDT" />
    <category term="CPU缓存" />
    <category term="中断" />
    <category term="异常" />
    <category term="CLI指令" />
    <category term="STI指令" />
    <category term="INT2" />
    <category term="INT8" />
    <category term="中断门描述符" />
    <category term="IDT" />
    <category term="提权" />
    <category term="跨段跳转流程" />
    <category term="JMP FAR指令" />
    <category term="TSS" />
    <category term="任务门" />
    <category term="LDT段描述符" />
    <category term="LDT" />
    <category term="CR0" />
    <category term="CR2" />
    <category term="CR4" />
    <category term="CRL" />
    <category term="DPL" />
    <category term="RPL" />
    <category term="段寄存器结构" />
    <category term="段描述符" />
    <category term="段选择子" />
    <category term="GDT表" />
    <category term="调用门" />
    <category term="调用门描述符" />
    <category term="逆向分析MmIsAddressValid函数" />
    <category term="error C2143" />
    <category term="error C2275" />
    <category term="CALL与CALL FAR" />
    <category term="陷阱门描述符" />
    <category term="10-10-12分页" />
    <category term="页目录表基址" />
    <category term="页表的基址" />
    <category term="0地址执行ShellCode" />
    <category term="PDE_PTE" />
    <category term="物理页" />
    <category term="SSDT HOOK" />
    <category term="OpenProcess" />
    <category term="系统服务表" />
    <category term="SSDT" />
    <category term="SSDT HOOK隐藏" />
    <category term="API进出内核" />
    <category term="系统调用阶段总结" />
    <category term="网络安全法" />
    <category term="ASCII" />
    <category term="GBK" />
    <category term="ANSI" />
    <category term="Unicode" />
    <category term="UTF-8" />
    <category term="URL 编码/解码" />
    <category term="十进制" />
    <category term="二进制" />
    <category term="十六进制" />
    <category term="内存" />
    <category term="x64" />
    <category term="编写ShellCode实现IAT HOOK" />
    <category term="ShellCode原则" />
    <category term="傀儡进程加密壳" />
    <category term="ZwUnmapViewOfSection函数" />
    <category term="加载图标" />
    <category term="提取图标" />
    <category term="资源表" />
    <category term="HTML" />
    <category term="文件包含" />
    <category term="sql注入" />
    <category term="MFC命令传递" />
    <category term="远控界面编写" />
    <category term="STL" />
    <category term="Vector容器" />
    <category term="Deque容器" />
    <category term="List容器" />
    <category term="Set容器" />
    <category term="Multiset容器" />
    <category term="Map容器" />
    <category term="Multimap容器" />
    <category term="Stack容器" />
    <category term="Queue容器" />
    <category term="priority_queue容器" />
    <category term="经典定长指令" />
    <category term="经典变长指令" />
    <category term="指令前缀" />
    <category term="串口" />
    <category term="过滤" />
    <category term="键盘过滤" />
    <category term="KAPC" />
    <category term="QueueUserAPC" />
    <category term="NtQueueApcThread" />
    <category term="KeInitializeApc" />
    <category term="KeInsertQueueApc" />
    <category term="KiInsertQueueApc" />
    <category term="进程句柄表" />
    <category term="全局句柄表" />
    <category term="消息队列与线程" />
    <category term="Windows线程切换" />
    <category term="KiSwapContext" />
    <category term="SwapContext" />
    <category term="时钟中断" />
    <category term="时间片管理" />
    <category term="线程切换与TSS" />
    <category term="线程切换与FS" />
    <category term="线程切换与线程优先级" />
    <category term="快速调用" />
    <category term="中断调用" />
    <category term="分析ReadProcessMemory" />
    <category term="KiFastSystemCall" />
    <category term="KiIntSystemCall" />
    <category term="重写3环" />
    <category term="文件上传" />
    <category term="隐藏驱动" />
    <category term="IopLoadDriver" />
    <category term="延迟过程调用" />
    <category term="进程挂靠" />
    <category term="跨进程读写内存" />
    <category term="APC" />
    <category term="逆向分析NtReadVirtualMemory" />
    <category term="逆向分析NtWriteVIrtualMemory" />
    <category term="AD-Attack-Defense" />
    <category term="payload" />
    <category term="sysenter指令" />
    <category term="KiFastCallEntry函数" />
    <category term="KiSystemService函数" />
    <category term="Trap_Frame" />
    <category term="web安全" />
    <category term="磁盘虚拟" />
    <category term="PDO" />
    <category term="Windows中从击键到内核的过程" />
    <category term="KEYBOARD_INPUT_DATA结构" />
    <category term="IRP完成回调函数" />
    <category term="DriverEntry函数的定义" />
    <category term="WDF_DRIVER_CONFIG结构" />
    <category term="EvtDriverDeviceAdd函数" />
    <category term="FAT12/16磁盘卷" />
    <category term="磁盘的过滤" />
    <category term="具有还原功能的磁盘卷过滤驱动" />
    <category term="文件系统" />
    <category term="Minifilter" />
    <category term="boot驱动" />
    <category term="bitmap" />
    <category term="_KUSER_SHARED_DATA" />
    <category term="哈希表" />
    <category term="Sfilter" />
    <category term="Windows网络编程" />
    <category term="协议层次和服务模型" />
    <category term="IP地址" />
    <category term="端口号" />
    <category term="DNS" />
    <category term="网络地址转换NAT" />
    <category term="分布式网络应用程序" />
    <category term="客户/服务器模型" />
    <category term="浏览器/服务器模型" />
    <category term="P2P模型" />
    <entry>
        <id>https://or0kit.github.io/Bin/Assembly/x64%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</id>
        <title>x64汇编学习</title>
        <link rel="alternate" href="https://or0kit.github.io/Bin/Assembly/x64%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
        <content type="html">&lt;h1 id=&#34;初学x64汇编&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#初学x64汇编&#34;&gt;#&lt;/a&gt; 初学 x64 汇编&lt;/h1&gt;
&lt;p&gt;要学习的 x64 汇编是  &lt;code&gt;AMD64&lt;/code&gt;  与  &lt;code&gt;Intel64&lt;/code&gt;  的合称。&lt;br /&gt;
最早是 Intel 实现了一套 64 位的指令集，但是不兼容之前的 32 位程序，后来 AMD 实现了一套兼容 32 位程序的 64 位指令集，后来的 64 位程序都按照 AMD 的标准实现了，Intel 也得支持这套指令集了。&lt;/p&gt;
&lt;h1 id=&#34;寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寄存器&#34;&gt;#&lt;/a&gt; 寄存器&lt;/h1&gt;
&lt;p&gt;在 16 位和 32 位的编程里，可以使用的通用寄存器是一样的，如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;8 位&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;16 位&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;32 位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;al&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ax&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;eax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ecx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;edx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ebx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ah&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;esp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ch&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ebp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dh&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;si&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;esi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bh&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;di&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;edi&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 x64 体系里，在原来的 8 个通用寄存器的基础上新增了 8 个寄存器，并且原来的寄存器也得到了扩展。&lt;br /&gt;
在 64 位编程里可以使用的通用寄存器如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;更直观一点来看：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;8 位&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;16 位&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;32 位&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;64 位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;al/ah&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ax&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;eax&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cl/ch&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ecx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rcx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dl/dh&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;edx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rdx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bl/bh&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ebx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rbx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;spl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;esp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rsp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bpl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ebp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rbp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sil&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;si&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;esi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rsi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dil&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;di&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;edi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rdi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r8b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r8w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r8d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r9b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r9w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r9d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r10b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r10w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r10d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r11b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r11w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r11d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r12b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r12w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r12d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r13b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r13w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r13d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r14b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r14w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r14d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r15b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r15w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r15d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 64 位编程里可以使用 20 个 8 位寄存器和 16 个 16 位、32 位以及 64 位寄存器，寄存器体系得到了完整的补充。&lt;/p&gt;
&lt;p&gt;所有的 16 个寄存器都可以分割出相应的 8 位、16 位或 32 位寄存器。&lt;br /&gt;
在 16 位编程和 32 位编程里， &lt;code&gt;sp&lt;/code&gt; 、 &lt;code&gt;bp&lt;/code&gt; 、 &lt;code&gt;si&lt;/code&gt;  及 &lt;code&gt;di&lt;/code&gt;  不能使用低 8 位。&lt;br /&gt;
在 64 位编程里，可以使用分割出的 &lt;code&gt;spl&lt;/code&gt; 、 &lt;code&gt;bpl&lt;/code&gt; 、 &lt;code&gt;sil&lt;/code&gt;  及 &lt;code&gt;dil&lt;/code&gt;  低 8 位寄存器。&lt;/p&gt;
&lt;p&gt;64 位的 r8~r15 寄存器分割出相对应的 8 位、16 位及 32 位寄存器形式为: &lt;code&gt;r8b~r15b&lt;/code&gt; ,  &lt;code&gt;r8w~r15w&lt;/code&gt; , 以及 &lt;code&gt;r8d~r15d&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;还有  &lt;code&gt;rip&lt;/code&gt;  与  &lt;code&gt;rflags&lt;/code&gt; ，64 位的 &lt;code&gt;rflags&lt;/code&gt;  寄存器高 32 位为保留位，低 32 位与 32 位下的 &lt;code&gt;eflags&lt;/code&gt;  寄存器一样。&lt;/p&gt;
&lt;h1 id=&#34;虚拟地址空间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟地址空间&#34;&gt;#&lt;/a&gt; 虚拟地址空间&lt;/h1&gt;
&lt;p&gt;在 x64 体系中使用了  &lt;code&gt;canonical&lt;/code&gt;  地址形式，但在 x64 体系里只实现了 48 位的  &lt;code&gt;virtual address&lt;/code&gt; , 高 16 位被用做符号扩展。&lt;/p&gt;
&lt;p&gt;这高 16 位要么全是 0，要么全是 1，这种形式的地址被称为  &lt;code&gt;canonical&lt;/code&gt;  地址，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image002.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;与  &lt;code&gt;canonical&lt;/code&gt;  地址形式相对的是  &lt;code&gt;non-canoncial&lt;/code&gt;  地址形式，如下所示。在 64 位模式下  &lt;code&gt;non-canonical&lt;/code&gt;  地址形式是不合法的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 64 位的线性地址空间里，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0x00000000_00000000&lt;/code&gt;  到  &lt;code&gt;0x00007FFF_FFFFFFFF&lt;/code&gt;  是合法的  &lt;code&gt;canonical&lt;/code&gt;  地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x00008000_00000000&lt;/code&gt;  到  &lt;code&gt;0xFFFF7FFF_FFFFFFFF&lt;/code&gt;  是非法的  &lt;code&gt;non-canonical&lt;/code&gt;  地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0xFFFF8000_00000000&lt;/code&gt;  到  &lt;code&gt;0xFFFFFFFF_FFFFFFFF&lt;/code&gt;  是合法的  &lt;code&gt;canonical&lt;/code&gt;  地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;non-canonical&lt;/code&gt;  地址形式里，它们的符号扩展位出现了问题。&lt;/p&gt;
&lt;p&gt;看下面的地址：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FFFF8010_bc001000&lt;/code&gt; ：这是符合  &lt;code&gt;canonical-address&lt;/code&gt;  的地址， MSB 是 bit47，值为 1。 而 bit63 ~ bit48 全是 1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;00007c80_b8102040&lt;/code&gt; ：这是符合  &lt;code&gt;canonical-address&lt;/code&gt;  的地址， MSB 是 bit47，值为 0。 而 bit63 ~ bit48 全是 0&lt;/p&gt;
&lt;p&gt;实质上， &lt;code&gt;canonical-address&lt;/code&gt;  地址中 bit63 ~ bit48 是符号扩展位。  &lt;code&gt;bit47&lt;/code&gt;  是 64 位地址中最高能表示的位（MSB）。&lt;/p&gt;
&lt;h1 id=&#34;x64体系中需要注意的事情&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#x64体系中需要注意的事情&#34;&gt;#&lt;/a&gt; x64 体系中需要注意的事情&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对 32 位寄存器的写操作（包括运算结果），会对相应的 64 位寄存器的搞 32 位清零。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;p&gt;这是执行  &lt;code&gt;mov eax, 1&lt;/code&gt;  指令之前的  &lt;code&gt;rax&lt;/code&gt;  寄存器&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image004.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;执行后  &lt;code&gt;rax&lt;/code&gt;  寄存器中的值：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image005.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;此举影响所有的 64 位寄存器。&lt;/p&gt;
&lt;p&gt;另一个例子：&lt;/p&gt;
&lt;p&gt;执行 sub eax,1 之前：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image006.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;执行之后，只有低 32 位是对的：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;还有  &lt;code&gt;xor eax,eax&lt;/code&gt;  这个指令并不只是清零  &lt;code&gt;eax&lt;/code&gt;  ,  &lt;code&gt;rax&lt;/code&gt;  也会被清零。&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;33C0     | xor eax,eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;48:33C0  | xor rax,rax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以上汇编代码的作用是一样的都会将 &lt;code&gt;rax&lt;/code&gt;  寄存器清零，但生成的硬编码是不一样的，所以编译器一般想要清空  &lt;code&gt;rax&lt;/code&gt;  寄存器就会生成  &lt;code&gt;xor eax,eax&lt;/code&gt;  汇编代码。&lt;/p&gt;
&lt;p&gt;64 位编程中代码的函数的返回值  &lt;code&gt;return 0&lt;/code&gt;  那么就会生成 &lt;code&gt;xor eax,eax&lt;/code&gt;  汇编代码。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;立即数的使用，优先使用 32 位扩展，64 位立即数指令较少。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当你在 x64dbg 中输入  &lt;code&gt;mov rax,1&lt;/code&gt;  它会自动生成  &lt;code&gt;mov eax, 1&lt;/code&gt;   如果数值较大的话就会使用 rax，编译器也会对这些语句进行优化，优先使用硬编码短的。&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;48:C7C0 FFFFFFFF           | mov rax,FFFFFFFFFFFFFFFF           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;48:B8 FFFFFFFFFFFFFFFF     | mov rax,FFFFFFFFFFFFFFFF           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;66:B8 0100                 | mov ax,1                           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;B0 01                      | mov al,1                           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;B8 01000000                | mov eax,1                          |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;48:B8 8967452301000000     | mov rax,123456789                  |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;48:B8 0100000000000000     | mov rax,1                          |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;64 位指令比较少，如  &lt;code&gt;push&lt;/code&gt;  指令操作立即数，只能操作 32 位立即数。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;好多指令都是不支持 8 字节的立即数。&lt;/p&gt;
&lt;p&gt;如果想要把 &lt;code&gt;0x123456789&lt;/code&gt;  这样的立即数压入栈中就必须得分为两步：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;mov rax,0x123456789;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;pus rax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;此外 x64 下还有其他的 nop 指令，如下所示：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 90                         | nop                                    |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 0F1FFE                     | nop esi,edi                            |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 0F1F1D 1D1222CC            | nop dword ptr ds:[7FF73A025174],ebx    |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 0F1F11                     | nop dword ptr ds:[rcx],edx             |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;与硬编码 0x90 不同，开头为 0x0F1F。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逻辑上这些汇编代码与 &lt;code&gt;nop&lt;/code&gt;  指令没有任何区别。&lt;/p&gt;
&lt;p&gt;在我看的这个教程中称这些汇编代码的出现只是编译器为了字节对齐。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;内存优先使用相对偏移寻址，直接寻址指令较少。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如 mov 指令：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F6C       | 48:8B05 01000000           | mov rax,qword ptr ds:[7FF76DE03F74]    |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F73       | 90                         | nop                                    |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F74       | 90                         | nop                                    |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;硬编码是  &lt;code&gt;48:8B05 + 4个字节相对地址偏移&lt;/code&gt;  便是  &lt;code&gt;mov rax,qword ptr ds:[此指令地址加上此指令长度加上相对偏移]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是：4 个字节相对地址偏移，因为有正负之分所以有效的寻址范围只有正负偏移 2GB&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F5A       | 48:A1 0000000000000000     | mov rax,qword ptr ds:[0]               |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F64       | 48:8B0425 00000000         | mov rax,qword ptr ds:[0]               |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这些是直接寻址的。&lt;/p&gt;
&lt;p&gt;例如 add 指令：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F73       | 48:010425 00000000         | add qword ptr ds:[0],rax               |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F7B       | 48:0105 00000000           | add qword ptr ds:[7FF76DE03F82],rax    |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如这两个 add 指令，都是只能操作 4 个字节的相对地址偏移。&lt;/p&gt;
&lt;p&gt;还有一件事&lt;/p&gt;
&lt;p&gt;我们编写一个 x64 的程序在 vs2019 中看其反汇编：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image009.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;而在 IDA 中查看其反汇编：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;发现其前面加了 cs 段前缀，这是 IDA 的一种错误，观察其硬编码岂可已发现，我们可以在 x64dbg 中实验一下：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F82       | 48:C705 00000000 78563412        | mov qword ptr ds:[7FF76DE03F8D],12345678      |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F8D       | 2E48:C705 00000000 78563412      | mov qword ptr cs:[7FF76DE03F99],12345678      |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;也是可以发现如果是 cs 段的话前面要加上 &lt;code&gt;0x2E&lt;/code&gt;  的硬编码前缀。&lt;/p&gt;
&lt;p&gt;那么 IDA 为什么会这么做呢？&lt;/p&gt;
&lt;p&gt;因为这个指令都是相对偏移寻址，而下一个指令是绝对地址偏移，是处于 PE 结构中的代码段的，所以 IDA 识别成了 cs 段。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;各种 jmp 比较&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 x64 地址空间中，如果加载一个 dll，那么想让程序跳转过去，不一定能实现，因为地址之间相距的大小可能超过了 2GB,&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image011.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F99       | EB 00                            | jmp notepad.7FF76DE03F9B                      |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03F9B       | E9 00000000                      | jmp notepad.7FF76DE03FA0                      |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FA0       | FF25 00000000                    | jmp qword ptr ds:[7FF76DE03FA6]               |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FA6       | FF2425 00000000                  | jmp qword ptr ds:[0]                          |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;应有：hook 的指令选择&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面说了如果地址空间超过 4GB 大小，一般会这样进行跳转：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FAD       | 48:B8 8967452301000000           | mov rax,123456789                             |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FB7       | FFE0                             | jmp rax                                       |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;#x2F;&amp;#x2F; 或者这样&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FBA       | 48:B8 8967452301000000           | mov rax,123456789                             |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FC4       | 50                               | push rax                                      |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FC5       | C3                               | ret                                           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;#x2F;&amp;#x2F; 最好是这样，既保存了 rax 寄存器的值，又可以跳转（13 个字节）&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FC7       | 50                               | push rax                                      |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FC8       | 48:B8 8967452301000000           | mov rax,123456789                             |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FD2       | C3                               | ret                                           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;#x2F;&amp;#x2F; 21 个字节 &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FD4       | 48:83EC 08                       | sub rsp,8                                     |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FD8       | C70424 78563412                  | mov dword ptr ss:[rsp],12345678               |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FDF       | C74424 04 BC9A0000               | mov dword ptr ss:[rsp+4],9ABC                 |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FE7       | C3                               | ret                                           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;#x2F;&amp;#x2F; 13 个字节&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FE9       | 68 78563412                      | push 12345678                                 |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FEE       | C74424 04 BC9A0000               | mov dword ptr ss:[rsp+4],9ABC                 |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF76DE03FF6       | C3                               | ret                                           |&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;x64 汇编没有类似  &lt;code&gt;pushad&lt;/code&gt;  的保存寄存器的指令，想要保存寄存器只能一个一个保存。&lt;/p&gt;
&lt;h1 id=&#34;调用约定&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#调用约定&#34;&gt;#&lt;/a&gt; 调用约定&lt;/h1&gt;
&lt;p&gt;强调一点：&lt;strong&gt;我们这次所学的调用约定只是微软编译器的习惯用法，并不是一种强制的东西，如果我们有一个函数只是自己调用的话，那么我们怎么设计它都可以的，只要堆栈平衡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU 层面并没有限制调用约定，只是微软编译器生成的函数，通常是这个规则。这是微软优化好的，如果我们有更好的，也可以自己设定函数约定。&lt;/p&gt;
&lt;p&gt;微软中的函数也有这种情况，如果一个函数只被另一个函数调用，那么这两个函数之间的调用约定也可能被简化。&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;x64调用约定&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#x64调用约定&#34;&gt;#&lt;/a&gt; x64 调用约定&lt;/h2&gt;
&lt;p&gt;在 32 位编程中有 3 种调用约定  &lt;code&gt;__cdecl&lt;/code&gt; ,   &lt;code&gt;__stdcall&lt;/code&gt; ,  &lt;code&gt;__fastcall&lt;/code&gt; ，而在 64 位编程中只有一种调用约定，为了兼容 32 位的代码这三种调用约定在 64 位编程中都失效了，例如系统 API 的头文件中的一般会有  &lt;code&gt;WINAPI&lt;/code&gt;  这个调用约定，这是一个宏，其本质是 &lt;code&gt;__stdcall&lt;/code&gt; ，所以编译器忽略了，写不写都一样。&lt;/p&gt;
&lt;p&gt;接下来我们从汇编的角度一步一步来了解 x64 的调用约定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用方&lt;strong&gt;分配&lt;/strong&gt;和&lt;strong&gt;清理&lt;/strong&gt;参数所用的栈空间（外平栈）&lt;/li&gt;
&lt;li&gt;前 4 个参数使用  &lt;code&gt;rcx&lt;/code&gt;   &lt;code&gt;rdx&lt;/code&gt;   &lt;code&gt;r8&lt;/code&gt;   &lt;code&gt;r9&lt;/code&gt;  传递&lt;/li&gt;
&lt;li&gt;即使是寄存器传参，也要分配参数栈空间&lt;/li&gt;
&lt;li&gt;对于不定长参数，调用前至少分配 4 个参数&lt;/li&gt;
&lt;li&gt;易变寄存器有：  &lt;code&gt;rax&lt;/code&gt;   &lt;code&gt;rcx&lt;/code&gt;   &lt;code&gt;rdx&lt;/code&gt;   &lt;code&gt;r8&lt;/code&gt;   &lt;code&gt;r9&lt;/code&gt;   &lt;code&gt;r10&lt;/code&gt;   &lt;code&gt;r11&lt;/code&gt; 。  &lt;code&gt;push&lt;/code&gt;   &lt;code&gt;pop&lt;/code&gt;  指令仅用来保存非易变寄存器，其他栈指针操作显式写寄存器  &lt;code&gt;rsp&lt;/code&gt;  实现&lt;/li&gt;
&lt;li&gt;进入  &lt;code&gt;call&lt;/code&gt;  之前  &lt;code&gt;rsp&lt;/code&gt;  满足  &lt;code&gt;0x10&lt;/code&gt;  字节对齐&lt;/li&gt;
&lt;li&gt;通常不适用  &lt;code&gt;rbp&lt;/code&gt;  寻址栈内存，所以  &lt;code&gt;rsp&lt;/code&gt;  在函数帧中尽量保持稳定（一次性分配局部变量和参数空间）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;在cc中调用汇编&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在cc中调用汇编&#34;&gt;#&lt;/a&gt; 在 C/C++ 中调用汇编&lt;/h2&gt;
&lt;p&gt;在 vs2019 中创建一个 cpp 文件和 asm 文件：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image012.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们还要对 asm 文件做一些设置：&lt;/p&gt;
&lt;p&gt;对其右键点击属性：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image013.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后这样设置；&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image014.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;点击应用后会出来自定义生成工具的一些设置，设置命令行编译以及输出，连接对象也要选择是：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image015.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;命令行编译：ml64 &amp;#x2F;Fo $(IntDir)%(fileName).obj&amp;#x2F;c %(fileName).asm&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;输出：$(IntDir)%(fileName).obj&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;此时我们的 asm 就可以参与生成了&lt;/p&gt;
&lt;h2 id=&#34;实验验证&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实验验证&#34;&gt;#&lt;/a&gt; 实验验证&lt;/h2&gt;
&lt;p&gt;前两条都很好理解，接下来亲自实验以代码来验证一下上面所说的 7 条约定。&lt;/p&gt;
&lt;h3 id=&#34;验证第三条&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证第三条&#34;&gt;#&lt;/a&gt; 验证第三条&lt;/h3&gt;
&lt;p&gt;在汇编中写下如下代码：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;func Prot&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.code&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun PROC&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rcx,1;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call func;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	ret&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun ENDP	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;END&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在汇编代码中我们调用函数之前没有去平衡堆栈。&lt;/p&gt;
&lt;p&gt;在 cpp 文件中写下如下代码：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;iostream&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;Windows.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;C&#34;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; __cdecl &lt;span class=&#34;token function&#34;&gt;asm_fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;ULONG64 a1&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;a1: %p\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; a1&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;asm_fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;即使是用寄存器传参还是会报错：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image016.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们可以直接在反汇编中查看原因：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;10:     void func(ULONG64 a1)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    11:     &amp;#123;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB518F0  mov         qword ptr [rsp+8],rcx  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB518F5  push        rbp  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB518F6  push        rdi  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB518F7  sub         rsp,0E8h  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB518FE  lea         rbp,[rsp+20h]  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    12:         printf(&amp;quot;a1: %p\n&amp;quot;, a1);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB51903  mov         rdx,qword ptr [a1]  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB5190A  lea         rcx,[string &amp;quot;a1: %p\n&amp;quot; (07FF67EB59C28h)]  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF67EB51911  call        printf (07FF67EB51190h)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;可以发现调用函数后，会在函数中把寄存器传参的值再取出来放到栈中，而我们没有在栈外平衡堆栈，所以这里把 rcx 里的值也就是我们的参数放到了 rsp+8 中，而这个值也就是函数 ret 返回的地址，所以程序会报错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以我们还是要为其分配栈空间，汇编代码如下：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;func Prot&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.code&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun PROC&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rcx,1;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  sub rsp ,8h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call func;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  add rsp, 8h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	ret&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun ENDP	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;END&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这样就没有错误了。&lt;/p&gt;
&lt;p&gt;当调用的函数有 4 个以上的参数时：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;iostream&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;Windows.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;C&#34;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; __cdecl &lt;span class=&#34;token function&#34;&gt;asm_fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;ULONG64 a1&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; ULONG64 a2&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; ULONG64 a3&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; ULONG64 a4&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; ULONG64 a5&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;a1: %p\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; a1&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;a2: %p\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; a2&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;a3: %p\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; a3&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;a4: %p\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; a4&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;a5: %p\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; a5&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;asm_fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;汇编代码中的平衡栈的操作如下：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;func Prot&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.code&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun PROC&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rcx,1;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rdx,2;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r8,3;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r9,4;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	push 5;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	sub rsp ,20h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call func;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	add rsp,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	ret&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun ENDP	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;END&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;原因是我们的栈空间：&lt;/p&gt;
&lt;p&gt;这是我们执行完 call 指令后，进入到函数中时的栈空间结构图：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image017.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在上面的汇编代码中，我们先用寄存器传递了 4 个参数，然后执行了 push 指令向栈中压入了一个值 5，push 指令执行完后 rsp+8 指向这个 5，然后我们把 rsp 减去 0x20, 既腾出了预留给寄存器传参用的空间，然后执行了 call 指令，函数的返回地址压入了栈中，此时栈顶指向了函数的返回地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;验证第四条&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证第四条&#34;&gt;#&lt;/a&gt; 验证第四条&lt;/h3&gt;
&lt;p&gt;有不定长参数的函数如： &lt;code&gt;printf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以更进其反汇编 c 查看一下：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF6C8C618B0 48 89 4C 24 08       mov         qword ptr [rsp+8],rcx  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF6C8C618B5 48 89 54 24 10       mov         qword ptr [rsp+10h],rdx  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF6C8C618BA 4C 89 44 24 18       mov         qword ptr [rsp+18h],r8  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00007FF6C8C618BF 4C 89 4C 24 20       mov         qword ptr [rsp+20h],r9&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这是函数开头，可以看到函数是直接使用了编译器传参用的默认栈空间。&lt;/p&gt;
&lt;h3 id=&#34;验证第五条&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证第五条&#34;&gt;#&lt;/a&gt; 验证第五条&lt;/h3&gt;
&lt;p&gt;知道了什么是易变寄存器，接下来验证一下第六条： &lt;code&gt;push&lt;/code&gt;   &lt;code&gt;pop&lt;/code&gt;  指令仅用来保存非易变寄存器，其他栈指针操作显式写寄存器  &lt;code&gt;rsp&lt;/code&gt;  实现。&lt;/p&gt;
&lt;p&gt;对于这个约定，我们也可以查看用微软编译器生成代码的反汇编，查看其是否遵守这个约定。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image018.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这是我在 IDA 中搜索的 push 指令，可以发现 &lt;code&gt;push&lt;/code&gt;  指令并没有操作易变寄存器，都是用来保存非易变寄存器的。&lt;/p&gt;
&lt;p&gt;也并没有我们上面汇编代码中的  &lt;code&gt;push 5&lt;/code&gt;  这个指令，那么我们要如何写呢？&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;option casemap:none&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;func Proto&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.code&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun PROC&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rcx,1;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rdx,2;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r8,3;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r9,4;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	sub rsp ,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov qword ptr [rsp+20h],5;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call func;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	add rsp,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	ret&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun ENDP	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;END&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;push 5&lt;/code&gt;  指令变成了 &lt;code&gt;	sub rsp ,28h;&lt;/code&gt;  和	 &lt;code&gt;mov qword ptr [rsp+20h],5;&lt;/code&gt;  两句指令。&lt;/p&gt;
&lt;p&gt;其实写之前可以编写一个程序去查看一下微软编译器会如何去做，我们编写一个 4 个以上参数的函数，然后看一下其反汇编：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;20: int main()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    21: &amp;#123;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0000000140011983  sub         rsp,0F8h  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;000000014001198A  lea         rbp,[rsp+30h]  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    22:     func(1,2,3,4,5);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;000000014001198F  mov         qword ptr [rsp+20h],5  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0000000140011998  mov         r9d,4  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;000000014001199E  mov         r8d,3  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00000001400119A4  mov         edx,2  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00000001400119A9  mov         ecx,1  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;00000001400119AE  call        func (014001119Fh)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到我们的做法和编译器的差不多一样了。&lt;/p&gt;
&lt;h3 id=&#34;验证第七条&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证第七条&#34;&gt;#&lt;/a&gt; 验证第七条&lt;/h3&gt;
&lt;p&gt;通常不适用  &lt;code&gt;rbp&lt;/code&gt;  寻址栈内存，所以  &lt;code&gt;rsp&lt;/code&gt;  在函数帧中尽量保持稳定（一次性分配局部变量和参数空间）&lt;/p&gt;
&lt;p&gt;想要理解这句话我们需要先写一段汇编代码：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;option casemap:none&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;func Proto&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;printf proto	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.data&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;pStr DB &amp;#39;This is asm_fun&amp;#39;, 0AH,00H&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.code&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun PROC&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	lea rcx,[pStr];&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	sub rsp,20h; printf 函数是可变长参数，所以要分配 0x20 栈空间&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call printf;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	add rsp,20h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rcx,1;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rdx,2;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r8,3;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r9,4;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	sub rsp ,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov qword ptr [rsp+20h],5;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call func;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	add rsp,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	ret&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun ENDP	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;END&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这段汇编代码很多简单就是分别调用了两个函数，分别平衡了堆栈。&lt;br /&gt;
这样来回移动 &lt;code&gt;rsp&lt;/code&gt;  显然是不合理的，会影响效率的，所以我们可以一次性分配局部变量和参数空间。&lt;/p&gt;
&lt;p&gt;上面的汇编代码可以更改为：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;option casemap:none&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;func Proto&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;printf proto	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.data&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;pStr DB &amp;#39;This is asm_fun&amp;#39;, 0AH,00H&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.code&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun PROC&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	lea rcx,[pStr];	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	sub rsp ,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call printf;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rcx,1;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov rdx,2;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r8,3;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov r9,4;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	mov qword ptr [rsp+20h],5;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	call func;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	add rsp,28h;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	ret&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;asm_fun ENDP	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;END&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;运行一样没有问题，并且可以观察一下编译器生成的汇编代码是否都是这样一次性分配好栈空间的（是的）。&lt;/p&gt;
&lt;p&gt;也因此我们无法在函数外部通过对 &lt;code&gt;rsp&lt;/code&gt;  的加减来分析函数的参数个数的，具体得进入函数中取看。&lt;/p&gt;
&lt;h3 id=&#34;验证第六条&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证第六条&#34;&gt;#&lt;/a&gt; 验证第六条&lt;/h3&gt;
&lt;h1 id=&#34;seh&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#seh&#34;&gt;#&lt;/a&gt; SEH&lt;/h1&gt;
</content>
        <category term="x64" />
        <updated>2022-06-27T08:55:08.000Z</updated>
    </entry>
</feed>
