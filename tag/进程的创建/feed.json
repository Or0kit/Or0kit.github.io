{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"进程的创建\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Process-Thread/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Process-Thread/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/",
            "title": "进程与线程-进程的创建",
            "date_published": "2022-01-11T13:39:45.000Z",
            "content_html": "<h1 id=\"楔子\"><a class=\"anchor\" href=\"#楔子\">#</a> 楔子</h1>\n<p>我们已经知道了进程和线程是如何在 Windows 中表示的，在内核层和执行体层分别包含了哪些信息。现在我们来看看 Windows 执行体是如何管理进程和线程的，包括进程和线程的创建和终止过程，以及进程和线程是如何创建起来的。</p>\n<h1 id=\"小知识获取当前进程或线程\"><a class=\"anchor\" href=\"#小知识获取当前进程或线程\">#</a> 小知识：获取当前进程或线程</h1>\n<p><strong>内核层函数 KeGetCurrentThread 是一个重要的函数</strong>，它返回当前处理器上正在运行的线程的 KTHREAD 结构指针。通过此结构信息，可以进一步得到 KPROCESS 、ETHREAD 和 EPROCESS 结构。在 WRK 中， KeGetCurrentThread 是这样实现的：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FORCEINLINE</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_KTHREAD</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>NTAPI <span class=\"token function\">KeGetCurrentThread</span> <span class=\"token punctuation\">(</span>VOID<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span>_MSC_FULL_VER <span class=\"token operator\">>=</span> <span class=\"token number\">13012035</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_KTHREAD</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>ULONG_PTR<span class=\"token punctuation\">)</span> <span class=\"token function\">__readfsdword</span> <span class=\"token punctuation\">(</span><span class=\"token function\">FIELD_OFFSET</span> <span class=\"token punctuation\">(</span>KPCR<span class=\"token punctuation\">,</span> PrcbData<span class=\"token punctuation\">.</span>CurrentThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    __asm <span class=\"token punctuation\">&#123;</span>  mov eax<span class=\"token punctuation\">,</span> fs<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> KPCR<span class=\"token punctuation\">.</span>PrcbData<span class=\"token punctuation\">.</span>CurrentThread <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>WRK 本身自带的编译器（tools\\x86\\cl.exe）版本（13.10.4035）大于 13012035 所以上面的代码取第一个条件分支，它展开来实际上只是一条指令。</p>\n<p>第二条分支， <code>mov eax, fs:[0] KPCR.PrcbData.CurrentThread</code>  应该等同于  <code>mov eax,fs:[0x124]</code> <br />\n 下面四种书写方式等价：<br />\n <code>MOV　AX, [BX+SI+1000H]</code> <br />\n <code>MOV　AX, 1000H[BX+SI]</code> <br />\n <code>MOV　AX, 1000H[BX][SI]</code> <br />\n <code>MOV　AX, 1000H[SI][BX]</code></p>\n<p>获取了当前线程的 KTHREAD 结构指针以后，便可以很方便的获取 ETHREAD 、 KPROCESS 和 EPROCESS 结构的指针了。</p>\n<p><strong>执行体层上获得当前线程和进程的函数</strong>分别是 PsGetCurrentThread 和 PsGetCurrentProcess ，代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">_PsGetCurrentProcess</span><span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CONTAINING_RECORD</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">KeGetCurrentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>ApcState<span class=\"token punctuation\">.</span>Process<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>EPROCESS<span class=\"token punctuation\">,</span>Pcb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">_PsGetCurrentThread</span><span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>PETHREAD<span class=\"token punctuation\">)</span><span class=\"token function\">KeGetCurrentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>PEPROCESS</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">PsGetCurrentProcess</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    VOID</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">_PsGetCurrentProcess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>PETHREAD</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token function\">PsGetCurrentThread</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    VOID</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">_PsGetCurrentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们看到，_PsGetCurrentProcess 宏从当前线程 KTHREAD 结构的 ApcState 成员中获得当前线程所属进程的 KPROCESS 结构。 这里之所以从 ApcState 成员中获取进程结构指针，而不是从 KTHREAD 的 Process 域 或 ETHREAD 的 ThreadProcess 域获取进程结构指针，<strong>是因为即使当前线程附载到其他进程中（通过 KeAttachProcess 函数），或者有回到原先的进程中（通过 KeDetachProcess 函数），这种做法也总是能够获得正确的当前进程结构的指针</strong>。 这里涉及 APC 相关的知识，还没学，暂时不深究。</p>\n<h1 id=\"进程创建过程\"><a class=\"anchor\" href=\"#进程创建过程\">#</a> 进程创建过程</h1>\n<p>看了几本书，还是没有捋顺知识点，先埋个坑。多看看书后再往下写了。CR3 的值在实模式下就被初始化好了，在一个链表中。</p>\n<h2 id=\"从r3-createprocess-分析进程创建过程\"><a class=\"anchor\" href=\"#从r3-createprocess-分析进程创建过程\">#</a> 从 R3  <code>CreateProcess</code>  分析进程创建过程</h2>\n<p>由于逆向的流程很复杂，我们先看 Xp 源码。</p>\n<p>BOOL<br />\nWINAPI<br />\nCreateProcessA(<br />\nLPCSTR lpApplicationName,<br />\nLPSTR lpCommandLine,<br />\nLPSECURITY_ATTRIBUTES lpProcessAttributes,<br />\nLPSECURITY_ATTRIBUTES lpThreadAttributes,<br />\nBOOL bInheritHandles,<br />\nDWORD dwCreationFlags,<br />\nLPVOID lpEnvironment,<br />\nLPCSTR lpCurrentDirectory,<br />\nLPSTARTUPINFOA lpStartupInfo,<br />\nLPPROCESS_INFORMATION lpProcessInformation<br />\n)</p>\n",
            "tags": [
                "进程的创建",
                "获取当前进程"
            ]
        }
    ]
}