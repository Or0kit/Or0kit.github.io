{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"进程挂靠\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Process-Thread/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%92%8C%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Process-Thread/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%92%8C%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/",
            "title": "进程与线程-进程挂靠和跨进程读写内存",
            "date_published": "2022-01-23T16:55:34.000Z",
            "content_html": "<h1 id=\"楔子\"><a class=\"anchor\" href=\"#楔子\">#</a> 楔子</h1>\n<p>需要有 APC 的基础，学完句柄表和 APC 后再回来分析。</p>\n<p>额外小知识   <code>NUMA</code></p>\n<p>要点回顾：</p>\n<p>一个进程可以包含多个线程</p>\n<p>一个进程至少要有一个线程</p>\n<p>进程为线程提供资源，也就是提供 Cr3 的值，Cr3 中存储的是页目录表基址，Cr3 确定了，线程能访问的内存也就确定了。</p>\n<h1 id=\"进程挂靠\"><a class=\"anchor\" href=\"#进程挂靠\">#</a> 进程挂靠</h1>\n<p>首先要了解以下知识</p>\n<h2 id=\"进程与线程的关系\"><a class=\"anchor\" href=\"#进程与线程的关系\">#</a> 进程与线程的关系</h2>\n<p>线程代码：</p>\n<p>mov eax,dword ptr ds:[0x12345678]</p>\n<p>CPU 如何解析 0x12345678 这个地址呢？</p>\n<ol>\n<li>\n<p>CPU 解析线性地址时要通过页目录表来找对应的物理页，页目录表基址存在<br />\n Cr3 寄存器中。</p>\n</li>\n<li>\n<p>当前的 Cr3 的值来源于当前的进程 (_KPROCESS.DirectoryTableBase (+0x018))。</p>\n</li>\n</ol>\n<h2 id=\"线程与进程的关联\"><a class=\"anchor\" href=\"#线程与进程的关联\">#</a> 线程与进程的关联</h2>\n<p>线程是如何找到进程的呢？线程与进程是如何关联的呢？</p>\n<p>在线程的结构体中：</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>+0x034 ApcState</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t+0x000 ApcListHead </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   \t\t+0x010 Process </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   \t\t+0x014 KernelApcInProgress</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   \t\t+0x015 KernelApcPending</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   \t\t+0x016 UserApcPending</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t+0x220 ThreadsProcess</pre></td></tr></table></figure><p>有两处与进程相关的成员：  <code>Process</code>  与  <code>ThreadsProcess</code>  ，那么这两个成员与线程有什么关系呢？</p>\n<h2 id=\"0x044负责提供cr3\"><a class=\"anchor\" href=\"#0x044负责提供cr3\">#</a> 0x044 负责提供 Cr3</h2>\n<p>(分析 SwapContext 函数) 线程切换的时候，会比较_KTHREAD 结构体 0x044 处指定的 EPROCESS 是否为同一个，如果不是同一个，会将 0x044 处指定的 EPROCESS 的 DirectoryTableBase 的值取出，赋值给 Cr3。</p>\n<p>所以，线程需要的 Cr3 的值来源于 0x044 处偏移指定的 EPROCESS.</p>\n<p>可以得出以下结论：</p>\n<p>0x220 亲生父母：这个线程谁创建的<br />\n 0x044 养父母：谁在为这个线程提供资源 (也就是提供 Cr3)<br />\n 一般情况下，0x220 与 0x44 指向的是同一个进程</p>\n<p>那么 Cr3 的值可以随便改吗？</p>\n<h2 id=\"修改cr3的值\"><a class=\"anchor\" href=\"#修改cr3的值\">#</a> 修改 Cr3 的值</h2>\n<p>正常情况下，Cr3 的值是由养父母提供的，但 Cr3 的值也可以改成和当前线程毫不相干的其他进程的 DirectoryTableBase。</p>\n<p>线程代码：</p>\n<p>mov cr3,A.DirectoryTableBase<br />\nmov eax,dword ptr ds:[0x12345678]\t\t//A 进程的 0x12345678 内存<br />\n mov cr3,B.DirectoryTableBase<br />\nmov eax,dword ptr ds:[0x12345678]\t\t//B 进程的 0x12345678 内存<br />\n mov cr3,C.DirectoryTableBase<br />\nmov eax,dword ptr ds:[0x12345678]\t\t//C 进程的 0x12345678 内存</p>\n<p>将当前 Cr3 的值改为其他进程，称为 “进程挂靠”。</p>\n<p>那可不可以只修改 Cr3 而不修改养父母？不可以，如果不修改养父母的值，一旦产生线程切换，就会变成自己读自己！</p>\n<p>如果我们自己来写这个代码，在切换 Cr3 后关闭中断，并且不调用会导致线程切换的 API，就可以不用修改养父母的值。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>正常情况下，当前线程使用的 Cr3 是由其所属进程提供的 (ETHREAD 0x44 偏移处指定的 EPROCESS)，正是因为如此，A 进程中的线程只能访问 A 的内存。</p>\n<p>如果要让 A 进程中的线程能够访问 B 进程的内存，就必须要修改 Cr3 的值为 B 进程的页目录表基址 (B.DirectoryTableBase)，这就是所谓的 “进程挂靠”。</p>\n<h1 id=\"跨进程读写内存\"><a class=\"anchor\" href=\"#跨进程读写内存\">#</a> 跨进程读写内存</h1>\n<p>跨进程的本质是 “进程挂靠”，正常情况下，A 进程的线程只能访问 A 进程的地址空间，如果 A 进程的线程想访问 B 进程的地址空间，就要修改当前的 Cr3 的值为 B 进程的页目录表基值 (KPROCESS.DirectoryTableBase)。<br />\n即： <code>mov cr3,B.DirectoryTableBase</code></p>\n<h2 id=\"跨进程操作\"><a class=\"anchor\" href=\"#跨进程操作\">#</a> 跨进程操作</h2>\n<p>A 进制中的线程代码：</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov cr3,B.DirectoryTableBase\t\t&#x2F;&#x2F; 切换 Cr3 的值为 B 进程</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov eax,dword ptr ds:[0x12345678]\t\t&#x2F;&#x2F; 将进程 B 0x12345678 的值存的 eax 中</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov dword ptr ds:[0x00401234],eax\t\t&#x2F;&#x2F; 将数据存储到 0x00401234 中</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mov cr3,A.DirectoryTableBase\t\t&#x2F;&#x2F; 切换回 Cr3 的值</pre></td></tr></table></figure><p>此时  <code>0x00401234</code>  中的数据还有吗？如何将数据传递给 A 进程的变量呢？</p>\n<h2 id=\"ntreadvirtualmemory-流程解析\"><a class=\"anchor\" href=\"#ntreadvirtualmemory-流程解析\">#</a> NtReadVirtualMemory 流程解析</h2>\n<p>一些关键函数的声明为：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">NtReadVirtualMemory</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     IN HANDLE ProcessHandle<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 为进程对象提供一个打开的句柄。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     IN PVOID BaseAddress<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供要读取的指定进程中的基址。</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     OUT PVOID Buffer<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供缓冲区的地址，该缓冲区接收来自指定进程地址空间的内容。</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     IN SIZE_T BufferSize<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供要从指定进程读取的请求字节数。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     OUT PSIZE_T NumberOfBytesRead OPTIONAL <span class=\"token comment\">// 接收传输到指定缓冲区的实际字节数。</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">MmCopyVirtualMemory</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    IN PEPROCESS FromProcess<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    IN CONST VOID <span class=\"token operator\">*</span>FromAddress<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    IN PEPROCESS ToProcess<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    OUT PVOID ToAddress<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    IN SIZE_T BufferSize<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    IN KPROCESSOR_MODE PreviousMode<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    OUT PSIZE_T NumberOfBytesCopied</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token function\">MiDoMappedCopy</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>     IN PEPROCESS FromProcess<span class=\"token punctuation\">,</span><span class=\"token comment\">// 为进程对象提供一个打开的句柄。</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>     IN CONST VOID <span class=\"token operator\">*</span>FromAddress<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供要读取的指定进程中的基址。</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>     IN PEPROCESS ToProcess<span class=\"token punctuation\">,</span><span class=\"token comment\">// 为进程对象提供一个打开的句柄。</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>     OUT PVOID ToAddress<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供缓冲区的地址，该缓冲区接收来自指定进程地址空间的内容。</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>     IN SIZE_T BufferSize<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供要从指定进程读取的请求字节数。</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>     IN KPROCESSOR_MODE PreviousMode<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供以前的处理器模式。</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>     OUT PSIZE_T NumberOfBytesRead<span class=\"token comment\">// 接收传输到指定缓冲区的实际字节数。</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token function\">MiDoPoolCopy</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>     IN PEPROCESS FromProcess<span class=\"token punctuation\">,</span><span class=\"token comment\">// 为进程对象提供一个打开的句柄。</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>     IN CONST VOID <span class=\"token operator\">*</span>FromAddress<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供要读取的指定进程中的基址。</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>     IN PEPROCESS ToProcess<span class=\"token punctuation\">,</span><span class=\"token comment\">// 为进程对象提供一个打开的句柄。</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>     OUT PVOID ToAddress<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供缓冲区的地址，该缓冲区接收来自指定进程地址空间的内容。</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>     IN SIZE_T BufferSize<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供要从指定进程读取的请求字节数。</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>     IN KPROCESSOR_MODE PreviousMode<span class=\"token punctuation\">,</span><span class=\"token comment\">// 提供以前的处理器模式。</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>     OUT PSIZE_T NumberOfBytesRead<span class=\"token comment\">// 接收传输到指定缓冲区的实际字节数。</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>     <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token comment\">/*-- 这个函数将一个线程附加到目标进程的地址空间，并返回上一个附加进程前的 APC 状态信息。--*/</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token function\">KeStackAttachProcess</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    IN PRKPROCESS Process<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    OUT PRKAPC_STATE ApcState</pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token comment\">/*-- 这个函数将一个线程从另一个进程的地址空间中分离出来，并恢复之前的连接状态。--*/</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>VOID</pre></td></tr><tr><td data-num=\"51\"></td><td><pre><span class=\"token function\">KeUnstackDetachProcess</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    IN PRKAPC_STATE ApcState <span class=\"token comment\">// 提供一个指向 APC 状态结构的指针，该结构是由之前对堆栈附加进程的调用返回的。</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"逆向分析-ntreadvirtualmemory\"><a class=\"anchor\" href=\"#逆向分析-ntreadvirtualmemory\">#</a> 逆向分析 NtReadVirtualMemory</h3>\n<details class=\"primary\"><summary>NtReadVirtualMemory 逆向分析  （点击展开）</summary><div>\n<pre><code>; NTSTATUS __stdcall NtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T NumberOfBytesToRead, PSIZE_T NumberOfBytesRead)\nPAGE:004DD2F6 _NtReadVirtualMemory@20 proc near       ; DATA XREF: .text:0042D858↑o\nPAGE:004DD2F6\nPAGE:004DD2F6 var_2C          = dword ptr -2Ch\nPAGE:004DD2F6 var_28          = dword ptr -28h\nPAGE:004DD2F6 Object          = dword ptr -24h\nPAGE:004DD2F6 AccessMode      = byte ptr -20h\nPAGE:004DD2F6 var_1C          = dword ptr -1Ch\nPAGE:004DD2F6 ms_exc          = CPPEH_RECORD ptr -18h\nPAGE:004DD2F6 ProcessHandle   = dword ptr  8\nPAGE:004DD2F6 BaseAddress     = dword ptr  0Ch\nPAGE:004DD2F6 Buffer          = dword ptr  10h\nPAGE:004DD2F6 NumberOfBytesToRead= dword ptr  14h\nPAGE:004DD2F6 NumberOfBytesRead= dword ptr  18h\nPAGE:004DD2F6\nPAGE:004DD2F6 ; __unwind &#123; // __SEH_prolog\nPAGE:004DD2F6                 push    1Ch\nPAGE:004DD2F8                 push    offset stru_402EF0\nPAGE:004DD2FD                 call    __SEH_prolog\nPAGE:004DD302                 mov     eax, large fs:124h ; eax = 当前的KTHREAD\nPAGE:004DD308                 mov     edi, eax        ; edi = eax\nPAGE:004DD30A                 mov     al, [edi+_KTHREAD.PreviousMode]\nPAGE:004DD310                 mov     [ebp+AccessMode], al\nPAGE:004DD313                 mov     esi, [ebp+NumberOfBytesToRead]\nPAGE:004DD316                 test    al, al          ; 如果不是内核模式 （KernelMode = 0） 则对参数做一系列的验证。\nPAGE:004DD318                 jz      short loc_4DD380\nPAGE:004DD31A                 mov     eax, [ebp+BaseAddress]\nPAGE:004DD31D                 lea     edx, [eax+esi]\nPAGE:004DD320                 cmp     edx, eax\nPAGE:004DD322                 jb      short loc_4DD379\nPAGE:004DD324                 mov     eax, [ebp+Buffer]\nPAGE:004DD327                 lea     ecx, [eax+esi]\nPAGE:004DD32A                 cmp     ecx, eax\nPAGE:004DD32C                 jb      short loc_4DD379\nPAGE:004DD32E                 mov     eax, _MmHighestUserAddress ; MmHighestUserAddress = 0x7FFEFFFF  最高的用户层地址\nPAGE:004DD333                 cmp     edx, eax\nPAGE:004DD335                 ja      short loc_4DD379\nPAGE:004DD337                 cmp     ecx, eax\nPAGE:004DD339                 ja      short loc_4DD379\nPAGE:004DD33B                 mov     ebx, [ebp+NumberOfBytesRead] ; 判断 NumberOfBytesRead 参数是否存在（是否为NULL）\nPAGE:004DD33B                                         ;\nPAGE:004DD33B                                         ; if(NumberOfBytesRead)（是否为NULL）&#123;\nPAGE:004DD33B                                         ;\nPAGE:004DD33B                                         ; ……………………\nPAGE:004DD33B                                         ; &#125;\nPAGE:004DD33B                                         ; 不为NULL 执行 jz 跳走\nPAGE:004DD33E                 test    ebx, ebx\nPAGE:004DD340                 jz      short loc_4DD383\nPAGE:004DD342                 and     [ebp+ms_exc.registration.TryLevel], 0\nPAGE:004DD346                 mov     eax, _MmUserProbeAddress ; _MmUserProbeAddress = 0x7FFF0000 保护页的起始地址\nPAGE:004DD34B                 cmp     ebx, eax\nPAGE:004DD34D                 jb      short loc_4DD355\nPAGE:004DD34F                 mov     dword ptr [eax], 0\nPAGE:004DD355\nPAGE:004DD355 loc_4DD355:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+57↑j\nPAGE:004DD355                 mov     eax, [ebx]\nPAGE:004DD357                 mov     [ebx], eax\nPAGE:004DD359                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh\nPAGE:004DD35D                 jmp     short loc_4DD383\nPAGE:004DD35F ; ---------------------------------------------------------------------------\nPAGE:004DD35F\nPAGE:004DD35F loc_4DD35F:                             ; DATA XREF: .text:stru_402EF0↑o\nPAGE:004DD35F                 mov     eax, [ebp+ms_exc.exc_ptr]\nPAGE:004DD362                 mov     eax, [eax]\nPAGE:004DD364                 mov     eax, [eax]\nPAGE:004DD366                 mov     [ebp+var_2C], eax\nPAGE:004DD369                 xor     eax, eax\nPAGE:004DD36B                 inc     eax\nPAGE:004DD36C                 retn\nPAGE:004DD36D ; ---------------------------------------------------------------------------\nPAGE:004DD36D\nPAGE:004DD36D loc_4DD36D:                             ; DATA XREF: .text:stru_402EF0↑o\nPAGE:004DD36D                 mov     esp, [ebp+ms_exc.old_esp]\nPAGE:004DD370                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh\nPAGE:004DD374                 mov     eax, [ebp+var_2C]\nPAGE:004DD377                 jmp     short loc_4DD3F2\nPAGE:004DD379 ; ---------------------------------------------------------------------------\nPAGE:004DD379\nPAGE:004DD379 loc_4DD379:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+2C↑j\nPAGE:004DD379                                         ; NtReadVirtualMemory(x,x,x,x,x)+36↑j ...\nPAGE:004DD379                 mov     eax, 0C0000005h\nPAGE:004DD37E                 jmp     short loc_4DD3F2\nPAGE:004DD380 ; ---------------------------------------------------------------------------\nPAGE:004DD380\nPAGE:004DD380 loc_4DD380:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+22↑j\nPAGE:004DD380                 mov     ebx, [ebp+NumberOfBytesRead] ; ebx = NumberOfBytesRead\nPAGE:004DD383\nPAGE:004DD383 loc_4DD383:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+4A↑j\nPAGE:004DD383                                         ; NtReadVirtualMemory(x,x,x,x,x)+67↑j\nPAGE:004DD383                 xor     eax, eax\nPAGE:004DD385                 mov     [ebp+var_28], eax ; [ebp+var_28] = 0\nPAGE:004DD388                 mov     [ebp+var_1C], eax\nPAGE:004DD38B                 cmp     esi, eax\nPAGE:004DD38D                 jz      short loc_4DD3D2 ; ebx = NumberOfBytesRead\nPAGE:004DD38F                 push    eax             ; HandleInformation\nPAGE:004DD390                 lea     eax, [ebp+Object] ; eax = [ebp+Object] 的地址\nPAGE:004DD390                                         ;\nPAGE:004DD390                                         ; 函数执行成功后[ebp+Object]会指向一个对象体。\nPAGE:004DD390                                         ; 此处返回的是 进程结构体 EPROCESS\nPAGE:004DD393                 push    eax             ; Object\nPAGE:004DD394                 push    dword ptr [ebp+AccessMode] ; AccessMode\nPAGE:004DD397                 push    _PsProcessType  ; ObjectType\nPAGE:004DD39D                 push    10h             ; DesiredAccess\nPAGE:004DD39F                 push    [ebp+ProcessHandle] ; Handle\nPAGE:004DD3A2                 call    _ObReferenceObjectByHandle@24 ; ObReferenceObjectByHandle(x,x,x,x,x,x)\nPAGE:004DD3A7                 mov     [ebp+var_1C], eax\nPAGE:004DD3AA                 test    eax, eax\nPAGE:004DD3AC                 jnz     short loc_4DD3D2 ; ebx = NumberOfBytesRead\nPAGE:004DD3AE                 lea     eax, [ebp+var_28] ; 取临时变量的地址\nPAGE:004DD3B1                 push    eax             ; 从右向左 压入第一个参数 其值是一个地址 。\nPAGE:004DD3B2                 push    dword ptr [ebp+AccessMode] ; 其值为 CPU的工作模式\nPAGE:004DD3B5                 push    esi             ; 压入 NumberOfBytesToRead 也就是从指定进程读取的请求字节数\nPAGE:004DD3B5                                         ;\nPAGE:004DD3B5                                         ; 注意区分 NumberOfBytesRead  和 NumberOfBytesToRead\nPAGE:004DD3B6                 push    [ebp+Buffer]    ; Address\nPAGE:004DD3B9                 push    [edi+_KTHREAD.ApcState.Process] ; 当前线程的进程KPROCESS\nPAGE:004DD3BC                 push    [ebp+BaseAddress] ; int\nPAGE:004DD3BF                 push    [ebp+Object]    ; 目标进程的KPROCESS\nPAGE:004DD3C2                 call    _MmCopyVirtualMemory@28 ; NTSTATUS\nPAGE:004DD3C2                                         ; MmCopyVirtualMemory(\nPAGE:004DD3C2                                         ;     IN PEPROCESS FromProcess,\nPAGE:004DD3C2                                         ;     IN CONST VOID *FromAddress,\nPAGE:004DD3C2                                         ;     IN PEPROCESS ToProcess,\nPAGE:004DD3C2                                         ;     OUT PVOID ToAddress,\nPAGE:004DD3C2                                         ;     IN SIZE_T BufferSize,\nPAGE:004DD3C2                                         ;     IN KPROCESSOR_MODE PreviousMode,\nPAGE:004DD3C2                                         ;     OUT PSIZE_T NumberOfBytesCopied\nPAGE:004DD3C2                                         ;     )\nPAGE:004DD3C7                 mov     [ebp+var_1C], eax ; 如果成功的话返回值为0 var_1C = 0\nPAGE:004DD3CA                 mov     ecx, [ebp+Object] ; Object\nPAGE:004DD3CD                 call    @ObfDereferenceObject@4 ; 这个例程减少指定对象的引用计数，如果计数变为0，则执行 任何(whatever) 清除操作。\nPAGE:004DD3D2\nPAGE:004DD3D2 loc_4DD3D2:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+97↑j\nPAGE:004DD3D2                                         ; NtReadVirtualMemory(x,x,x,x,x)+B6↑j\nPAGE:004DD3D2                 test    ebx, ebx        ; ebx = NumberOfBytesRead\nPAGE:004DD3D4                 jz      short loc_4DD3EF\nPAGE:004DD3D6                 mov     [ebp+ms_exc.registration.TryLevel], 1\nPAGE:004DD3DD                 mov     eax, [ebp+var_28] ; var_28 指向了 传输到指定缓冲区的实际字节数。\nPAGE:004DD3E0                 mov     [ebx], eax      ; 传输到指定缓冲区的实际字节数 赋给 NumberOfBytesRead\nPAGE:004DD3E2                 jmp     short loc_4DD3EB\nPAGE:004DD3E4 ; ---------------------------------------------------------------------------\nPAGE:004DD3E4\nPAGE:004DD3E4 loc_4DD3E4:                             ; DATA XREF: .text:stru_402EF0↑o\nPAGE:004DD3E4                 xor     eax, eax\nPAGE:004DD3E6                 inc     eax\nPAGE:004DD3E7                 retn\nPAGE:004DD3E8 ; ---------------------------------------------------------------------------\nPAGE:004DD3E8\nPAGE:004DD3E8 loc_4DD3E8:                             ; DATA XREF: .text:stru_402EF0↑o\nPAGE:004DD3E8                 mov     esp, [ebp+ms_exc.old_esp]\nPAGE:004DD3EB\nPAGE:004DD3EB loc_4DD3EB:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+EC↑j\nPAGE:004DD3EB                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh\nPAGE:004DD3EF\nPAGE:004DD3EF loc_4DD3EF:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+DE↑j\nPAGE:004DD3EF                 mov     eax, [ebp+var_1C] ; 一切正常执行的话 eax = 0 既宏定义 STATUS_SUCCESS\nPAGE:004DD3F2\nPAGE:004DD3F2 loc_4DD3F2:                             ; CODE XREF: NtReadVirtualMemory(x,x,x,x,x)+81↑j\nPAGE:004DD3F2                                         ; NtReadVirtualMemory(x,x,x,x,x)+88↑j\nPAGE:004DD3F2                 call    __SEH_epilog\nPAGE:004DD3F7                 retn    14h\nPAGE:004DD3F7 ; &#125; // starts at 4DD2F6\nPAGE:004DD3F7 _NtReadVirtualMemory@20 endp\nPAGE:004DD3F7\nPAGE:004DD3F7 ; ---------------------------------------------------------------------------\n</code></pre>\n</div></details>\n<p>主要调用了 MmCopyVirtualMemory 函数。</p>\n<h3 id=\"逆向分析-mmcopyvirtualmemory\"><a class=\"anchor\" href=\"#逆向分析-mmcopyvirtualmemory\">#</a> 逆向分析 MmCopyVirtualMemory</h3>\n<details class=\"primary\"><summary>MmCopyVirtualMemory (点击展开)</summary><div>\n<pre><code>; int __stdcall MmCopyVirtualMemory(PEX_RUNDOWN_REF FromProcess, int, PRKPROCESS, volatile void *Address, SIZE_T Length, KPROCESSOR_MODE AccessMode, int NumberOfBytesRead)\nPAGE:004DD258 _MmCopyVirtualMemory@28 proc near       ; CODE XREF: IopCheckHardErrorsDisabled(x)+73↑p\nPAGE:004DD258                                         ; LpcpCopyRequestData(x,x,x,x,x,x,x):loc_4CEE57↑p ...\nPAGE:004DD258\nPAGE:004DD258 FromProcess     = dword ptr  8\nPAGE:004DD258 FromAddress     = dword ptr  0Ch\nPAGE:004DD258 ToProcess       = dword ptr  10h\nPAGE:004DD258 Address         = dword ptr  14h\nPAGE:004DD258 Length          = dword ptr  18h\nPAGE:004DD258 AccessMode      = byte ptr  1Ch\nPAGE:004DD258 NumberOfBytesRead= dword ptr  20h\nPAGE:004DD258\nPAGE:004DD258                 mov     edi, edi\nPAGE:004DD25A                 push    ebp\nPAGE:004DD25B                 mov     ebp, esp\nPAGE:004DD25D                 cmp     [ebp+Length], 0 ; NumberOfBytesToRead 判断  从指定进程读取的请求字节数，是否为0\nPAGE:004DD261                 jnz     short loc_4DD26A\nPAGE:004DD263                 xor     eax, eax\nPAGE:004DD265                 jmp     loc_4DD2ED      ;  为 0 就直接返回了\nPAGE:004DD26A ; ---------------------------------------------------------------------------\nPAGE:004DD26A\nPAGE:004DD26A loc_4DD26A:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+9↑j\nPAGE:004DD26A                 push    ebx\nPAGE:004DD26B                 mov     ebx, [ebp+FromProcess] ; ebx = 要读取的进程的 EPROCESS 结构体。\nPAGE:004DD26E                 mov     ecx, ebx\nPAGE:004DD270                 mov     eax, large fs:124h\nPAGE:004DD276                 cmp     ebx, [eax+_KTHREAD.ApcState.Process] ; 判断要读取的进程 是否是当前进程\nPAGE:004DD279                 jnz     short loc_4DD27E\nPAGE:004DD27B                 mov     ecx, [ebp+ToProcess]\nPAGE:004DD27E\nPAGE:004DD27E loc_4DD27E:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+21↑j\nPAGE:004DD27E                 add     ecx, 80h ; '€'  ; 取 目标EPROCESS 的 RundownProtect 成员的值\nPAGE:004DD284                 mov     [ebp+FromProcess], ecx\nPAGE:004DD287                 call    @ExAcquireRundownProtection@4 ; 获得rundown保护\nPAGE:004DD28C                 test    al, al          ; 判断是否成功\nPAGE:004DD28E                 jnz     short loc_4DD297 ; 如果成功就跳走\nPAGE:004DD290                 mov     eax, 0C000010Ah ; 返回  STATUS_PROCESS_IS_TERMINATING\nPAGE:004DD295                 jmp     short loc_4DD2EC ; 如果失败，函数执行失败 返回\nPAGE:004DD297 ; ---------------------------------------------------------------------------\nPAGE:004DD297\nPAGE:004DD297 loc_4DD297:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+36↑j\nPAGE:004DD297                 cmp     [ebp+Length], 1FFh ; 判读要读取的字节大小是否超过0x1FF\nPAGE:004DD29E                 push    esi\nPAGE:004DD29F                 push    edi\nPAGE:004DD2A0                 mov     edi, [ebp+NumberOfBytesRead] ; edi =  指向NumberOfBytesRead的地址\nPAGE:004DD2A0                                         ;\nPAGE:004DD2A0                                         ; 在 NtReadVirtualMemory  中传来的此值是一个地址。\nPAGE:004DD2A0                                         ; 应该是返回用的\nPAGE:004DD2A3                 jbe     short loc_4DD2C8 ; 小于等于则跳转\nPAGE:004DD2A5                 push    edi             ; 压入 指向NumberOfBytesRead的地址\nPAGE:004DD2A6                 push    dword ptr [ebp+AccessMode] ; AccessMode\nPAGE:004DD2A9                 push    [ebp+Length]    ; Length\nPAGE:004DD2AC                 push    [ebp+Address]   ; ToAddress\nPAGE:004DD2AF                 push    [ebp+ToProcess] ; ToProcess\nPAGE:004DD2B2                 push    [ebp+FromAddress] ; FromAddress\nPAGE:004DD2B5                 push    ebx             ; FromProcess\nPAGE:004DD2B6                 call    _MiDoMappedCopy@28 ; NTSTATUS\nPAGE:004DD2B6                                         ; MiDoMappedCopy (\nPAGE:004DD2B6                                         ;     IN PEPROCESS FromProcess,\nPAGE:004DD2B6                                         ;     IN CONST VOID *FromAddress,\nPAGE:004DD2B6                                         ;     IN PEPROCESS ToProcess,\nPAGE:004DD2B6                                         ;     OUT PVOID ToAddress,\nPAGE:004DD2B6                                         ;     IN SIZE_T BufferSize,\nPAGE:004DD2B6                                         ;     IN KPROCESSOR_MODE PreviousMode,\nPAGE:004DD2B6                                         ;     OUT PSIZE_T NumberOfBytesRead\nPAGE:004DD2B6                                         ;     )\nPAGE:004DD2BB                 mov     esi, eax\nPAGE:004DD2BD                 cmp     esi, 0C00000A1h\nPAGE:004DD2C3                 jnz     short loc_4DD2E0\nPAGE:004DD2C5                 and     dword ptr [edi], 0\nPAGE:004DD2C8\nPAGE:004DD2C8 loc_4DD2C8:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+4B↑j\nPAGE:004DD2C8                 push    edi             ; 压入 指向NumberOfBytesRead的地址\nPAGE:004DD2C9                 push    dword ptr [ebp+AccessMode] ; AccessMode\nPAGE:004DD2CC                 push    [ebp+Length]    ; Length\nPAGE:004DD2CF                 push    [ebp+Address]   ; ToAddress\nPAGE:004DD2D2                 push    [ebp+ToProcess] ; ToProcess\nPAGE:004DD2D5                 push    [ebp+FromAddress] ; FromAddress\nPAGE:004DD2D8                 push    ebx             ; FromProcess\nPAGE:004DD2D9                 call    _MiDoPoolCopy@28 ; NTSTATUS\nPAGE:004DD2D9                                         ; MiDoPoolCopy (\nPAGE:004DD2D9                                         ;      IN PEPROCESS FromProcess,\nPAGE:004DD2D9                                         ;      IN CONST VOID *FromAddress,\nPAGE:004DD2D9                                         ;      IN PEPROCESS ToProcess,\nPAGE:004DD2D9                                         ;      OUT PVOID ToAddress,\nPAGE:004DD2D9                                         ;      IN SIZE_T BufferSize,\nPAGE:004DD2D9                                         ;      IN KPROCESSOR_MODE PreviousMode,\nPAGE:004DD2D9                                         ;      OUT PSIZE_T NumberOfBytesRead\nPAGE:004DD2D9                                         ;      )\nPAGE:004DD2DE                 mov     esi, eax\nPAGE:004DD2E0\nPAGE:004DD2E0 loc_4DD2E0:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+6B↑j\nPAGE:004DD2E0                 mov     ecx, [ebp+FromProcess] ; RunRef\nPAGE:004DD2E3                 call    @ExReleaseRundownProtection@4 ; ExReleaseRundownProtection(x)\nPAGE:004DD2E8                 pop     edi\nPAGE:004DD2E9                 mov     eax, esi\nPAGE:004DD2EB                 pop     esi\nPAGE:004DD2EC\nPAGE:004DD2EC loc_4DD2EC:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+3D↑j\nPAGE:004DD2EC                 pop     ebx\nPAGE:004DD2ED\nPAGE:004DD2ED loc_4DD2ED:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+D↑j\nPAGE:004DD2ED                 pop     ebp\nPAGE:004DD2EE                 retn    1Ch\nPAGE:004DD2EE _MmCopyVirtualMemory@28 endp\n</code></pre>\n</div></details>\n<p>这个函数会  <code>cmp     [ebp+Length], 1FFh </code> ; 判读要读取的字节大小是否超过 0x1FF，如果没有超过就会调用  <code>_MiDoPoolCopy</code>  函数，超过的话就会调用  <code>_MiDoMappedCopy</code> 。</p>\n<p><code>_MiDoMappedCopy</code>  有些地方没逆懂，但关键地方都一样。详细看  <code>_MiDoPoolCopy</code>  了。</p>\n<h3 id=\"逆向分析-_midopoolcopy\"><a class=\"anchor\" href=\"#逆向分析-_midopoolcopy\">#</a> 逆向分析 _MiDoPoolCopy</h3>\n<details class=\"primary\"><summary>_MiDoPoolCopy (点击展开)</summary><div>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n</div></details>\n<h3 id=\"逆向分析-kestackattachprocess\"><a class=\"anchor\" href=\"#逆向分析-kestackattachprocess\">#</a> 逆向分析 KeStackAttachProcess</h3>\n<details class=\"primary\"><summary>KeStackAttachProcess (点击展开)</summary><div>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n</div></details>\n<h3 id=\"逆向分析-kiattachprocess\"><a class=\"anchor\" href=\"#逆向分析-kiattachprocess\">#</a> 逆向分析 KiAttachProcess</h3>\n<details class=\"primary\"><summary>KiAttachProcess (点击展开)</summary><div>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n</div></details>\n<h3 id=\"逆向分析-kiswapprocess\"><a class=\"anchor\" href=\"#逆向分析-kiswapprocess\">#</a> 逆向分析 KiSwapProcess</h3>\n<details class=\"primary\"><summary>KiSwapProcess (点击展开)</summary><div>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n</div></details>\n<h3 id=\"函数调用流程中的各个函数总结\"><a class=\"anchor\" href=\"#函数调用流程中的各个函数总结\">#</a> 函数调用流程中的各个函数总结</h3>\n<details class=\"info\"><summary>NtReadVirtualMemory实现路径 (点击展开)</summary><div>\n<ol>\n<li>\n<p><code>NtReadVirtualMemory</code>  做了一些验证后调用了  <code>MmCopyVirtualMemory</code></p>\n</li>\n<li>\n<p><code>MmCopyVirtualMemory</code>  在这个函数中判断了缓冲区的大小，如果缓冲区大小大于池移动阈值，则尝试通过直接映射写入内存。这里根据情况调用  <code>MiDoMappedCopy</code>  和  <code>MiDoPoolCopy</code> 。</p>\n</li>\n<li>\n<p><code>MiDoMappedCopy</code>  函数有很多结构体还没学，暂时逆不懂，先逆  <code>MiDoPoolCopy</code>  了。  <code>MiDoPoolCopy</code>  函数在读取内存的方法是先在内核层申请一份和要读取的字节大小一样的内存，然后调用了  <code>KeStackAttachProcess</code>  函数。</p>\n<ul>\n<li>这里先说  <code>KeStackAttachProcess</code>  函数了，这个函数首先判断了要附加的进程是不是当前进程，然后又判断当前线程是不是已经处于挂靠状态了，如果处于挂靠状态的话，把原来的 APC 状态保存到 ApcState 变量中，否则的话就把原来的 APC 状态保存到线程结构体的 KTHREAD 的  <code>SavedApcState</code>  成员中。  这里是判断之后调用  <code>KiAttachProcess </code> 函数时传递的参数不一样来实现的。</li>\n</ul>\n<p>如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token operator\">-></span>ApcStateIndex <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">// 已经处于挂靠状态</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>            <span class=\"token function\">KiAttachProcess</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">,</span> Process<span class=\"token punctuation\">,</span> OldIrql<span class=\"token punctuation\">,</span> ApcState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 会把原来的 APC 状态赋给 ApcState 变量，是上层函数返回的变量。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 没有处于挂靠状态</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token function\">KiAttachProcess</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">,</span> Process<span class=\"token punctuation\">,</span> OldIrql<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>Thread<span class=\"token operator\">-></span>SavedApcState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 传递当前线程的 SavedApcState，用它来接收以前的 APC 状态。</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            ApcState<span class=\"token operator\">-></span>Process <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 标识一下，在 KeStackAttachProcess 中会判断</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>\n<p>在 <code>KiAttachProcess </code> 函数中，先把当前线程 KTEHREAD 的 ApcState 成员保存了一份赋值给了一个指针变量 ，这个指针变量是这个函数的参数，如果线程已将处于挂靠状态，那么这个指针变量就是上层函数的临时变量，如果没有处于挂靠状态那么这个指针变量就是当前线程 KTHREAD 的 <code>SavedApcState</code>  成员。<br />\n然后把当前线程 KTHREAD 的  <code>ApcState</code>  保存到了这个指针变量中，<strong>这一步既保存了没挂靠前的 APC 状态</strong>，之后初始化新的线程 KTHREAD 的  <code>ApcState</code>  成员。<br />\n然后判断目标进程的状态是否在内存中，如果在内存中，就把所有处于 ready 状态的线程，移动到全局就绪链表中，然后调用了  <code>KiSwapProcess</code>  函数后就返回了。<br />\n如果进程的状态不是在内存中，则判断其状态是不是 ProcessOutOfMemory 既不在内存中，如果是则设置其状态为正在转移，然后把进程 KPROCESS 的  <code>SwapListEntry</code>  成员挂入到  <code>KiProcessInSwapListHead</code>  中。<br />\n<strong> <code>SwapListEntry</code>  成员在《Windows 内核原理与实现》一书中有介绍：  <code>KiProcessInSwapListHead</code>  这是等待被插入的进程链表，它是一个单链表。当一个进程要被换出内存时，通过此成员加入到以  <code>KiProcessOutSwapListHead</code>  为链头的单链表中；当一个进程要被换入内存时，通过此成员加入到以  <code>KiProcessInSwapListHead</code>  为链头的单链表中。</strong><br />\n如果状态不是 ProcessOutOfMemory 的话，会直接执行这一步： 清除前一个进程中的活动处理器位，并设置被附加进程中的活动处理器位。<br />\n绕后调用了  <code>KiSwapThread</code>  函数</p>\n<ul>\n<li>调用  <code>KiSwapProcess</code>  函数：这个函数主要更新了 GDT 中的 LDT 描述符和 IDT 中的 int 2h, 并交换 CR3 来将地址空间交换到另一个进程。 它还将 I/O 权限映射交换到新进程。</li>\n<li>调用  <code>KiSwapThread</code> ，主动调用线程切换，既把目标进程的线程激活，使其在内存中，直到线程切换切回来，因为 APC 的状态已经更换成了目标进程，而 Cr3 是取线程的 APC 状态中的进程 KPROCESS 中的  <code>DirectoryTableBase</code>  成员， 所以切换回来后，线程的 Cr3 也就改了，至此挂靠完成了。真是巧妙呀。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>挂靠后又回到了  <code>MiDoPoolCopy</code>  函数中，然后就开始复制内存了，把目标进程空间的内存，复制到了内核空间。然后调用了  <code>KeUnstackDetachProcess</code>  解除了挂靠状态， <code>KeUnstackDetachProcess</code>  最终也是调用了  <code>KiSwapProcess</code>  函数不在细说了。解除挂靠后又挂靠了回了原来的自己的进程，然后把在内核空间的内存数据复制到了，原来线程空间指定的缓存区中，然后就解除挂靠了，之后又释放了在内核空间申请的内存空间，统计了一下复制了多少字节数后返回了。</p>\n</li>\n</ol>\n</div></details>\n<h2 id=\"ntwritevirtualmemory-流程分析\"><a class=\"anchor\" href=\"#ntwritevirtualmemory-流程分析\">#</a> NtWriteVirtualMemory 流程分析</h2>\n<p>此函数的调用流程与  <code>NtReadVirtualMemory</code>  一样。</p>\n<p>NtReadVirtualMemory -&gt; MmCopyVirtualMemory -&gt; MiDoMappedCopy 或者 MiDoPoolCopy</p>\n<details class=\"info\"><summary>（点击展开）</summary><div>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>PAGE:004DD400 ; NTSTATUS __stdcall NtWriteVirtualMemory (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T NumberOfBytesToWrite, PSIZE_T NumberOfBytesWritten)</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>PAGE:004DD400 _NtWriteVirtualMemory@20 proc near      ; DATA XREF: .text:0042D9C4↑o</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>PAGE:004DD400</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>PAGE:004DD400 var_2C          &#x3D; dword ptr -2Ch</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>PAGE:004DD400 NumberOfBytesRead&#x3D; dword ptr -28h</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>PAGE:004DD400 Object          &#x3D; dword ptr -24h</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>PAGE:004DD400 AccessMode      &#x3D; byte ptr -20h</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>PAGE:004DD400 Status          &#x3D; dword ptr -1Ch</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>PAGE:004DD400 ms_exc          &#x3D; CPPEH_RECORD ptr -18h</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>PAGE:004DD400 ProcessHandle   &#x3D; dword ptr  8</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>PAGE:004DD400 BaseAddress     &#x3D; dword ptr  0Ch</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>PAGE:004DD400 Buffer          &#x3D; dword ptr  10h</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>PAGE:004DD400 NumberOfBytesToWrite&#x3D; dword ptr  14h</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>PAGE:004DD400 NumberOfBytesWritten&#x3D; dword ptr  18h</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>PAGE:004DD400</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>PAGE:004DD400 ; __unwind &#123; &#x2F;&#x2F;__SEH_prolog</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>PAGE:004DD400                 push    1Ch</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>PAGE:004DD402                 push    offset stru_402F08</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>PAGE:004DD407                 call    __SEH_prolog</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>PAGE:004DD40C                 mov     eax, large fs:124h</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>PAGE:004DD412                 mov     edi, eax        ; edi &#x3D; 当先线程的 KTHREAD</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>PAGE:004DD414                 mov     al, [edi+_KTHREAD.PreviousMode]</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>PAGE:004DD41A                 mov     [ebp+AccessMode], al</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>PAGE:004DD41D                 mov     esi, [ebp+NumberOfBytesToWrite] ; esi &#x3D; NumberOfBytesToWrite</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>PAGE:004DD420                 test    al, al          ; 与操作 判断 al 是否等于 0，既当前模式是否是内核模式</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>PAGE:004DD422                 jz      short loc_4DD48A</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>PAGE:004DD424                 mov     eax, [ebp+BaseAddress]</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>PAGE:004DD427                 lea     edx, [eax+esi]  ; edx &#x3D; BaseAddress + NuberOfBytesToWrite</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>PAGE:004DD42A                 cmp     edx, eax</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>PAGE:004DD42C                 jb      short loc_4DD483</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>PAGE:004DD42E                 mov     eax, [ebp+Buffer]</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>PAGE:004DD431                 lea     ecx, [eax+esi]</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>PAGE:004DD434                 cmp     ecx, eax</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>PAGE:004DD436                 jb      short loc_4DD483</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>PAGE:004DD438                 mov     eax, _MmHighestUserAddress</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>PAGE:004DD43D                 cmp     edx, eax</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>PAGE:004DD43F                 ja      short loc_4DD483</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>PAGE:004DD441                 cmp     ecx, eax</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>PAGE:004DD443                 ja      short loc_4DD483 ; if ( (BaseAddress + NuberOfBytesToWrite &gt; BaseAddress) ||</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>PAGE:004DD443                                         ; (Buffer + NuberOfBytesToWrite &gt; Buffer) ||</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>PAGE:004DD443                                         ; (BaseAddress + NuberOfBytesToWrite) &gt; MM_HIGHEST_USER_ADDRESS) ||</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>PAGE:004DD443                                         ; (Buffer + NuberOfBytesToWrite) &gt; MM_HIGHEST_USER_ADDRESS))</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>PAGE:004DD443                                         ;</pre></td></tr><tr><td data-num=\"44\"></td><td><pre>PAGE:004DD443                                         ; )&#123;</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>PAGE:004DD443                                         ;    return ……</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>PAGE:004DD443                                         ; &#125;</pre></td></tr><tr><td data-num=\"47\"></td><td><pre>PAGE:004DD445                 mov     ebx, [ebp+NumberOfBytesWritten]</pre></td></tr><tr><td data-num=\"48\"></td><td><pre>PAGE:004DD448                 test    ebx, ebx        ; 判断 NumberOfBytesWritten 是否为 空 因为是可选参数</pre></td></tr><tr><td data-num=\"49\"></td><td><pre>PAGE:004DD44A                 jz      short loc_4DD48D ; 如果为空就跳转</pre></td></tr><tr><td data-num=\"50\"></td><td><pre>PAGE:004DD44C                 and     [ebp+ms_exc.registration.TryLevel], 0</pre></td></tr><tr><td data-num=\"51\"></td><td><pre>PAGE:004DD450                 mov     eax, _MmUserProbeAddress ; _MmUserProbeAddress &#x3D; 0x7FFF0000 保护页的起始地址</pre></td></tr><tr><td data-num=\"52\"></td><td><pre>PAGE:004DD455                 cmp     ebx, eax        ; 比较一下</pre></td></tr><tr><td data-num=\"53\"></td><td><pre>PAGE:004DD457                 jb      short loc_4DD45F ; 小于就跳转</pre></td></tr><tr><td data-num=\"54\"></td><td><pre>PAGE:004DD459                 mov     dword ptr [eax], 0</pre></td></tr><tr><td data-num=\"55\"></td><td><pre>PAGE:004DD45F</pre></td></tr><tr><td data-num=\"56\"></td><td><pre>PAGE:004DD45F loc_4DD45F:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+57↑j</pre></td></tr><tr><td data-num=\"57\"></td><td><pre>PAGE:004DD45F                 mov     eax, [ebx]      ; 判读一下这个值是否可读可写</pre></td></tr><tr><td data-num=\"58\"></td><td><pre>PAGE:004DD461                 mov     [ebx], eax      ; ProbeForWriteUlong_ptr (Address) &#123;</pre></td></tr><tr><td data-num=\"59\"></td><td><pre>PAGE:004DD461                                         ;     if ((Address) &gt;&#x3D; (ULONG_PTR * const) MM_USER_PROBE_ADDRESS) &#123;</pre></td></tr><tr><td data-num=\"60\"></td><td><pre>PAGE:004DD461                                         ;         *(volatile ULONG_PTR * const) MM_USER_PROBE_ADDRESS &#x3D; 0;</pre></td></tr><tr><td data-num=\"61\"></td><td><pre>PAGE:004DD461                                         ;     &#125;</pre></td></tr><tr><td data-num=\"62\"></td><td><pre>PAGE:004DD461                                         ;</pre></td></tr><tr><td data-num=\"63\"></td><td><pre>PAGE:004DD461                                         ;     *(volatile ULONG_PTR *)(Address) &#x3D; *(volatile ULONG_PTR *)(Address);</pre></td></tr><tr><td data-num=\"64\"></td><td><pre>PAGE:004DD461                                         ; &#125;</pre></td></tr><tr><td data-num=\"65\"></td><td><pre>PAGE:004DD463                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh</pre></td></tr><tr><td data-num=\"66\"></td><td><pre>PAGE:004DD467                 jmp     short loc_4DD48D</pre></td></tr><tr><td data-num=\"67\"></td><td><pre>PAGE:004DD469 ; ---------------------------------------------------------------------------</pre></td></tr><tr><td data-num=\"68\"></td><td><pre>PAGE:004DD469</pre></td></tr><tr><td data-num=\"69\"></td><td><pre>PAGE:004DD469 loc_4DD469:                             ; DATA XREF: .text:stru_402F08↑o</pre></td></tr><tr><td data-num=\"70\"></td><td><pre>PAGE:004DD469                 mov     eax, [ebp+ms_exc.exc_ptr]</pre></td></tr><tr><td data-num=\"71\"></td><td><pre>PAGE:004DD46C                 mov     eax, [eax]</pre></td></tr><tr><td data-num=\"72\"></td><td><pre>PAGE:004DD46E                 mov     eax, [eax]</pre></td></tr><tr><td data-num=\"73\"></td><td><pre>PAGE:004DD470                 mov     [ebp+var_2C], eax</pre></td></tr><tr><td data-num=\"74\"></td><td><pre>PAGE:004DD473                 xor     eax, eax</pre></td></tr><tr><td data-num=\"75\"></td><td><pre>PAGE:004DD475                 inc     eax</pre></td></tr><tr><td data-num=\"76\"></td><td><pre>PAGE:004DD476                 retn</pre></td></tr><tr><td data-num=\"77\"></td><td><pre>PAGE:004DD477 ; ---------------------------------------------------------------------------</pre></td></tr><tr><td data-num=\"78\"></td><td><pre>PAGE:004DD477</pre></td></tr><tr><td data-num=\"79\"></td><td><pre>PAGE:004DD477 loc_4DD477:                             ; DATA XREF: .text:stru_402F08↑o</pre></td></tr><tr><td data-num=\"80\"></td><td><pre>PAGE:004DD477                 mov     esp, [ebp+ms_exc.old_esp]</pre></td></tr><tr><td data-num=\"81\"></td><td><pre>PAGE:004DD47A                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh</pre></td></tr><tr><td data-num=\"82\"></td><td><pre>PAGE:004DD47E                 mov     eax, [ebp+var_2C]</pre></td></tr><tr><td data-num=\"83\"></td><td><pre>PAGE:004DD481                 jmp     short loc_4DD4FC</pre></td></tr><tr><td data-num=\"84\"></td><td><pre>PAGE:004DD483 ; ---------------------------------------------------------------------------</pre></td></tr><tr><td data-num=\"85\"></td><td><pre>PAGE:004DD483</pre></td></tr><tr><td data-num=\"86\"></td><td><pre>PAGE:004DD483 loc_4DD483:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+2C↑j</pre></td></tr><tr><td data-num=\"87\"></td><td><pre>PAGE:004DD483                                         ; NtWriteVirtualMemory (x,x,x,x,x)+36↑j ...</pre></td></tr><tr><td data-num=\"88\"></td><td><pre>PAGE:004DD483                 mov     eax, 0C0000005h</pre></td></tr><tr><td data-num=\"89\"></td><td><pre>PAGE:004DD488                 jmp     short loc_4DD4FC</pre></td></tr><tr><td data-num=\"90\"></td><td><pre>PAGE:004DD48A ; ---------------------------------------------------------------------------</pre></td></tr><tr><td data-num=\"91\"></td><td><pre>PAGE:004DD48A</pre></td></tr><tr><td data-num=\"92\"></td><td><pre>PAGE:004DD48A loc_4DD48A:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+22↑j</pre></td></tr><tr><td data-num=\"93\"></td><td><pre>PAGE:004DD48A                 mov     ebx, [ebp+NumberOfBytesWritten]</pre></td></tr><tr><td data-num=\"94\"></td><td><pre>PAGE:004DD48D</pre></td></tr><tr><td data-num=\"95\"></td><td><pre>PAGE:004DD48D loc_4DD48D:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+4A↑j</pre></td></tr><tr><td data-num=\"96\"></td><td><pre>PAGE:004DD48D                                         ; NtWriteVirtualMemory (x,x,x,x,x)+67↑j</pre></td></tr><tr><td data-num=\"97\"></td><td><pre>PAGE:004DD48D                 xor     eax, eax</pre></td></tr><tr><td data-num=\"98\"></td><td><pre>PAGE:004DD48F                 mov     [ebp+NumberOfBytesRead], eax ; NumberOfBytesRead &#x3D; 0</pre></td></tr><tr><td data-num=\"99\"></td><td><pre>PAGE:004DD492                 mov     [ebp+Status], eax</pre></td></tr><tr><td data-num=\"100\"></td><td><pre>PAGE:004DD495                 cmp     esi, eax        ; esi &#x3D; NumberOfBytesToWrite</pre></td></tr><tr><td data-num=\"101\"></td><td><pre>PAGE:004DD495                                         ; 判断要写入的字节数是否为 0</pre></td></tr><tr><td data-num=\"102\"></td><td><pre>PAGE:004DD497                 jz      short loc_4DD4DC</pre></td></tr><tr><td data-num=\"103\"></td><td><pre>PAGE:004DD499                 push    eax             ; HandleInformation</pre></td></tr><tr><td data-num=\"104\"></td><td><pre>PAGE:004DD49A                 lea     eax, [ebp+Object]</pre></td></tr><tr><td data-num=\"105\"></td><td><pre>PAGE:004DD49D                 push    eax             ; Object</pre></td></tr><tr><td data-num=\"106\"></td><td><pre>PAGE:004DD49E                 push    dword ptr [ebp+AccessMode] ; AccessMode</pre></td></tr><tr><td data-num=\"107\"></td><td><pre>PAGE:004DD4A1                 push    _PsProcessType  ; ObjectType</pre></td></tr><tr><td data-num=\"108\"></td><td><pre>PAGE:004DD4A7                 push    20h ; &#39; &#39;       ; DesiredAccess</pre></td></tr><tr><td data-num=\"109\"></td><td><pre>PAGE:004DD4A9                 push    [ebp+ProcessHandle] ; Handle</pre></td></tr><tr><td data-num=\"110\"></td><td><pre>PAGE:004DD4AC                 call    _ObReferenceObjectByHandle@24 ; ObReferenceObjectByHandle (x,x,x,x,x,x)</pre></td></tr><tr><td data-num=\"111\"></td><td><pre>PAGE:004DD4B1                 mov     [ebp+Status], eax ; Status &#x3D; ObReferenceObjectByHandle (ProcessHandle,</pre></td></tr><tr><td data-num=\"112\"></td><td><pre>PAGE:004DD4B1                                         ;                                            PROCESS_VM_WRITE,</pre></td></tr><tr><td data-num=\"113\"></td><td><pre>PAGE:004DD4B1                                         ;                                            PsProcessType,</pre></td></tr><tr><td data-num=\"114\"></td><td><pre>PAGE:004DD4B1                                         ;                                            PreviousMode,</pre></td></tr><tr><td data-num=\"115\"></td><td><pre>PAGE:004DD4B1                                         ;                                            (PVOID *)&amp;Process,</pre></td></tr><tr><td data-num=\"116\"></td><td><pre>PAGE:004DD4B1                                         ;                                            NULL);</pre></td></tr><tr><td data-num=\"117\"></td><td><pre>PAGE:004DD4B4                 test    eax, eax        ; 判断是否执行成功</pre></td></tr><tr><td data-num=\"118\"></td><td><pre>PAGE:004DD4B6                 jnz     short loc_4DD4DC</pre></td></tr><tr><td data-num=\"119\"></td><td><pre>PAGE:004DD4B8                 lea     eax, [ebp+NumberOfBytesRead]</pre></td></tr><tr><td data-num=\"120\"></td><td><pre>PAGE:004DD4BB                 push    eax             ; NumberOfBytesRead</pre></td></tr><tr><td data-num=\"121\"></td><td><pre>PAGE:004DD4BC                 push    dword ptr [ebp+AccessMode] ; AccessMode</pre></td></tr><tr><td data-num=\"122\"></td><td><pre>PAGE:004DD4BF                 push    esi             ; Length</pre></td></tr><tr><td data-num=\"123\"></td><td><pre>PAGE:004DD4C0                 push    [ebp+BaseAddress] ; Address</pre></td></tr><tr><td data-num=\"124\"></td><td><pre>PAGE:004DD4C3                 push    [ebp+Object]    ; 目标进程 KPROCESS</pre></td></tr><tr><td data-num=\"125\"></td><td><pre>PAGE:004DD4C6                 push    [ebp+Buffer]    ; int</pre></td></tr><tr><td data-num=\"126\"></td><td><pre>PAGE:004DD4C9                 push    [edi+_KTHREAD.ApcState.Process] ; 当前线程的进程 KPROCESS</pre></td></tr><tr><td data-num=\"127\"></td><td><pre>PAGE:004DD4CC                 call    _MmCopyVirtualMemory@28 ; NTSTATUS</pre></td></tr><tr><td data-num=\"128\"></td><td><pre>PAGE:004DD4CC                                         ; MmCopyVirtualMemory (</pre></td></tr><tr><td data-num=\"129\"></td><td><pre>PAGE:004DD4CC                                         ;     IN PEPROCESS FromProcess,</pre></td></tr><tr><td data-num=\"130\"></td><td><pre>PAGE:004DD4CC                                         ;     IN CONST VOID *FromAddress,</pre></td></tr><tr><td data-num=\"131\"></td><td><pre>PAGE:004DD4CC                                         ;     IN PEPROCESS ToProcess,</pre></td></tr><tr><td data-num=\"132\"></td><td><pre>PAGE:004DD4CC                                         ;     OUT PVOID ToAddress,</pre></td></tr><tr><td data-num=\"133\"></td><td><pre>PAGE:004DD4CC                                         ;     IN SIZE_T BufferSize,</pre></td></tr><tr><td data-num=\"134\"></td><td><pre>PAGE:004DD4CC                                         ;     IN KPROCESSOR_MODE PreviousMode,</pre></td></tr><tr><td data-num=\"135\"></td><td><pre>PAGE:004DD4CC                                         ;     OUT PSIZE_T NumberOfBytesCopied</pre></td></tr><tr><td data-num=\"136\"></td><td><pre>PAGE:004DD4CC                                         ;     )</pre></td></tr><tr><td data-num=\"137\"></td><td><pre>PAGE:004DD4D1                 mov     [ebp+Status], eax</pre></td></tr><tr><td data-num=\"138\"></td><td><pre>PAGE:004DD4D4                 mov     ecx, [ebp+Object] ; Object</pre></td></tr><tr><td data-num=\"139\"></td><td><pre>PAGE:004DD4D7                 call    @ObfDereferenceObject@4 ; ObfDereferenceObject (x)</pre></td></tr><tr><td data-num=\"140\"></td><td><pre>PAGE:004DD4DC</pre></td></tr><tr><td data-num=\"141\"></td><td><pre>PAGE:004DD4DC loc_4DD4DC:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+97↑j</pre></td></tr><tr><td data-num=\"142\"></td><td><pre>PAGE:004DD4DC                                         ; NtWriteVirtualMemory (x,x,x,x,x)+B6↑j</pre></td></tr><tr><td data-num=\"143\"></td><td><pre>PAGE:004DD4DC                 test    ebx, ebx</pre></td></tr><tr><td data-num=\"144\"></td><td><pre>PAGE:004DD4DE                 jz      short loc_4DD4F9</pre></td></tr><tr><td data-num=\"145\"></td><td><pre>PAGE:004DD4E0                 mov     [ebp+ms_exc.registration.TryLevel], 1</pre></td></tr><tr><td data-num=\"146\"></td><td><pre>PAGE:004DD4E7                 mov     eax, [ebp+NumberOfBytesRead]</pre></td></tr><tr><td data-num=\"147\"></td><td><pre>PAGE:004DD4EA                 mov     [ebx], eax</pre></td></tr><tr><td data-num=\"148\"></td><td><pre>PAGE:004DD4EC                 jmp     short loc_4DD4F5</pre></td></tr><tr><td data-num=\"149\"></td><td><pre>PAGE:004DD4EE ; ---------------------------------------------------------------------------</pre></td></tr><tr><td data-num=\"150\"></td><td><pre>PAGE:004DD4EE</pre></td></tr><tr><td data-num=\"151\"></td><td><pre>PAGE:004DD4EE loc_4DD4EE:                             ; DATA XREF: .text:stru_402F08↑o</pre></td></tr><tr><td data-num=\"152\"></td><td><pre>PAGE:004DD4EE                 xor     eax, eax</pre></td></tr><tr><td data-num=\"153\"></td><td><pre>PAGE:004DD4F0                 inc     eax</pre></td></tr><tr><td data-num=\"154\"></td><td><pre>PAGE:004DD4F1                 retn</pre></td></tr><tr><td data-num=\"155\"></td><td><pre>PAGE:004DD4F2 ; ---------------------------------------------------------------------------</pre></td></tr><tr><td data-num=\"156\"></td><td><pre>PAGE:004DD4F2</pre></td></tr><tr><td data-num=\"157\"></td><td><pre>PAGE:004DD4F2 loc_4DD4F2:                             ; DATA XREF: .text:stru_402F08↑o</pre></td></tr><tr><td data-num=\"158\"></td><td><pre>PAGE:004DD4F2                 mov     esp, [ebp+ms_exc.old_esp]</pre></td></tr><tr><td data-num=\"159\"></td><td><pre>PAGE:004DD4F5</pre></td></tr><tr><td data-num=\"160\"></td><td><pre>PAGE:004DD4F5 loc_4DD4F5:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+EC↑j</pre></td></tr><tr><td data-num=\"161\"></td><td><pre>PAGE:004DD4F5                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh</pre></td></tr><tr><td data-num=\"162\"></td><td><pre>PAGE:004DD4F9</pre></td></tr><tr><td data-num=\"163\"></td><td><pre>PAGE:004DD4F9 loc_4DD4F9:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+DE↑j</pre></td></tr><tr><td data-num=\"164\"></td><td><pre>PAGE:004DD4F9                 mov     eax, [ebp+Status]</pre></td></tr><tr><td data-num=\"165\"></td><td><pre>PAGE:004DD4FC</pre></td></tr><tr><td data-num=\"166\"></td><td><pre>PAGE:004DD4FC loc_4DD4FC:                             ; CODE XREF: NtWriteVirtualMemory (x,x,x,x,x)+81↑j</pre></td></tr><tr><td data-num=\"167\"></td><td><pre>PAGE:004DD4FC                                         ; NtWriteVirtualMemory (x,x,x,x,x)+88↑j</pre></td></tr><tr><td data-num=\"168\"></td><td><pre>PAGE:004DD4FC                 call    __SEH_epilog</pre></td></tr><tr><td data-num=\"169\"></td><td><pre>PAGE:004DD501                 retn    14h</pre></td></tr><tr><td data-num=\"170\"></td><td><pre>PAGE:004DD501 ; &#125; &#x2F;&#x2F;starts at 4DD400</pre></td></tr><tr><td data-num=\"171\"></td><td><pre>PAGE:004DD501 _NtWriteVirtualMemory@20 endp</pre></td></tr><tr><td data-num=\"172\"></td><td><pre>PAGE:004DD501</pre></td></tr><tr><td data-num=\"173\"></td><td><pre>PAGE:004DD501 ; ---------------------------------------------------------------------------</pre></td></tr></table></figure></div></details>\n<p>传递的参数不一样，就造成了不一样的效果。</p>\n<p>分完就会发现读写的操作完全是一个逆过程。</p>\n<h1 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h1>\n<p>NtReadVirtualMemory 流程解析：</p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>NtWriteVirtualMemory 流程解析：</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<p>分析其不同：<br />\nNtReadVirtualMemory</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>NtWriteVirtualMemory</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<h2 id=\"实践\"><a class=\"anchor\" href=\"#实践\">#</a> 实践</h2>\n<p>重写函数</p>\n<p>R0 R3 ?</p>\n",
            "tags": [
                "进程挂靠",
                "跨进程读写内存",
                "APC",
                "逆向分析NtReadVirtualMemory",
                "逆向分析NtWriteVIrtualMemory"
            ]
        }
    ]
}