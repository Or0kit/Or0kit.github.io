{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"linux\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Linux/Linux%E4%B8%AD%E7%9A%84su%E4%B8%8Esu-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://or0kit.github.io/Linux/Linux%E4%B8%AD%E7%9A%84su%E4%B8%8Esu-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "Linux中的su与su -命令的区别",
            "date_published": "2021-04-20T14:26:01.000Z",
            "content_html": "<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p>详情见<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5oYTk3LmNvbS80MDAxLmh0bWw=\"> http://www.ha97.com/4001.html</span></p>\n<h2 id=\"区别\"><a class=\"anchor\" href=\"#区别\">#</a> 区别</h2>\n<p>su 命令和 su - 命令最大的本质区别就是：前者只是切换了 root 身份，但 Shell 环境仍然是普通用户的 Shell；而后者连用户和 Shell 环境一起切换成 root 身份了。只有切换了 Shell 环境才不会出现 PATH 环境变量错误。su 切换成 root 用户以后，pwd 一下，发现工作目录仍然是普通用户的工作目录；而用 su - 命令切换以后，工作目录变成 root 的工作目录了。用 echo $PATH 命令看一下 su 和 su - 以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用 su - 命令。</p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://or0kit.github.io/Linux/linux%E8%BF%9B%E9%98%B6/",
            "url": "https://or0kit.github.io/Linux/linux%E8%BF%9B%E9%98%B6/",
            "title": "linux进阶学习",
            "date_published": "2021-02-19T06:54:11.000Z",
            "content_html": "<h1 id=\"网络配置\"><a class=\"anchor\" href=\"#网络配置\">#</a> 网络配置</h1>\n<h2 id=\"ifconfig-详解\"><a class=\"anchor\" href=\"#ifconfig-详解\">#</a> ifconfig 详解</h2>\n<p>ifconfig 命令可以显示或配置网络设备 (网络接口卡) , 也可以修改这些配置。<br />\n用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永久保存，那就要修改网卡的配置文件了。</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>DEVICE=“ens33” 　　# 网卡名称<br />\n // UP：表示 “接口已启用”。<br />\n// BROADCAST ：表示 “主机支持广播”。<br />\n// RUNNING：表示 “接口在工作中”。<br />\n// MULTICAST：表示 “主机支持多播”。<br />\n// MTU:1500（最大传输单元）：1500 字节<br />\n //inet ：网卡的 IP 地址。<br />\n//netmask ：网络掩码。<br />\n//broadcast ：广播地址。<br />\n// 网卡的 IPv6 地址<br />\n // 连接类型：Ethernet (以太网) HWaddr (硬件 mac 地址)<br />\n//txqueuelen (网卡设置的传送队列长度)<br />\n// RX packets 接收时，正确的数据包数。<br />\n// RX bytes 接收的数据量。<br />\n// RX errors 接收时，产生错误的数据包数。<br />\n// RX dropped 接收时，丢弃的数据包数。<br />\n// RX overruns 接收时，由于速度过快而丢失的数据包数。<br />\n// RX frame 接收时，发生 frame 错误而丢失的数据包数。<br />\n// TX packets 发送时，正确的数据包数。<br />\n// TX bytes 发送的数据量。<br />\n// TX errors 发送时，产生错误的数据包数。<br />\n// TX dropped 发送时，丢弃的数据包数。<br />\n// TX overruns 发送时，由于速度过快而丢失的数据包数。<br />\n// TX carrier 发送时，发生 carrier 错误而丢失的数据包数。<br />\n//collisions 冲突信息包的数目。</p>\n<p>lo: 表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。</p>\n<p>ifconfig 的配置针对当前起作用，, 当服务器进行重启启动，配置的 IP 和掩码等信息都会丢失因为 ifconfig 的没有把配置写入到配置文件，当系统重新启动中，会重新加载网络配置文件，因此配置会丢失</p>\n<p>ifconfig 命令 参数具体见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWlmY29uZmlnLmh0bWw=\"> https://www.runoob.com/linux/linux-comm-ifconfig.html</span></p>\n<h2 id=\"网络配置文件\"><a class=\"anchor\" href=\"#网络配置文件\">#</a> 网络配置文件</h2>\n<p>网络接口配置文件均存放在 /etc/sysconfig/network-scripts/ 目录下</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/sysconfig/network-scripts/ifcfg-ens33 </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>none</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>3693f084-6c9a-4b4e-82ef-62377f4c3502</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.100</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token assign-left variable\">PREFIX</span><span class=\"token operator\">=</span><span class=\"token number\">24</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.198</span>.10.1</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">#################################</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>下面介绍改配置文件中的每一行的含义。</pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">#################################</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>:网卡设备名</pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token assign-left variable\">HWADDR</span><span class=\"token operator\">=</span>:网卡的物理地址</pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>:网卡的类型</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>:网卡的UUID</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span>:IP地址</pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span>:子网掩码</pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span>:网关</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span>:DNS</pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>:该网卡是否激活</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token assign-left variable\">NM_CONTROLLED</span><span class=\"token operator\">=</span>:网络是否由NetworkManager进行管理</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>：启动远程协议为静态设置</pre></td></tr></table></figure><h2 id=\"路由的查看及配置\"><a class=\"anchor\" href=\"#路由的查看及配置\">#</a> 路由的查看及配置</h2>\n<p>路由 (route) 就是分组在因特网上从一台计算机传输到另一台计算机的实际路径。<br />\n因特网上的每个路由器都存储有一张表，称为路由表 (routing table), 路由器正是依据路由表的内容将各个 IP 分组转发到正确的去处。</p>\n<p>路由，路由器，路由表的区别:</p>\n<p>路由：既可以指计算机之间的传输路径，又可以指传输这一动态过程<br />\n路由器：设备，即完成路由这一动态过程的设备<br />\n路由表：信息，是储存在路由器中的用来路由的信息</p>\n<p>查看路由命令：<br />\n <code>netstat -r</code></p>\n<p><code>route -n</code></p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p>查看本机路由信息<br />\n <code>route -n</code></p>\n<p>添加一条默认路由，临时生效 (重启后就会失效)<br />\n <code>route add default qw 192.168.10.1</code></p>\n<p>删除一条默认路由<br />\n <code>route del default gw 192.168.10.1</code></p>\n<p>添加一条静态路由，发往 192.168.8.62 这个网段的全部要经过网关 192.168.1.1<br />\n <code>route add-net 192.168.8.0 netmask 255.255.255.0 gw 192.168.1.1</code></p>\n<p>删除一条静态路由，删除的时候可以不写网关<br />\n <code>route del -net 192.168.8.0 netmask 255.255.255.0 gw 192.168.1.1</code></p>\n<p>设置包转发功能:</p>\n<p>开启 Liunx 的路由转发功能:<br />\n 编辑 /etc/sysctl.conf 设置 net.pv4.p forward=1</p>\n<p>临时配置：<br />\n <code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</code></p>\n<h2 id=\"dns\"><a class=\"anchor\" href=\"#dns\">#</a> DNS</h2>\n<p>Linux 下查看本地的 DNS:<br />\n1.cat /etc/resolv.conf<br />\n2.nslookup <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span></p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<h3 id=\"dns-查询工具\"><a class=\"anchor\" href=\"#dns-查询工具\">#</a> DNS 查询工具</h3>\n<ol>\n<li>\n<p>nslookup 是一个能够查询互联网域名服务器信息的程序。<br />\n他有两种工作模式，即 &quot;交互模式&quot; 和 &quot;非交互模式&quot;<br />\n在&quot; 交互模式 &quot; 下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。<br />\n而在 “非交互模式 &quot; 下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p>\n</li>\n<li>\n<p>Dig 是一个在类 Unix 命令行模式下查询 DNS 包括 NSi 录，A 记录，MX 记录等相关信息的工具。</p>\n</li>\n</ol>\n<p>dig 命令:<br />\n 查询一台主机，但是默认情况下，Dig 的输出信息很详细<br />\n最常用的查询是 A 记录，TXT (文本注释) , MXi 录，NS 记录</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<h3 id=\"dns域名解析中添加的各项解析记录\"><a class=\"anchor\" href=\"#dns域名解析中添加的各项解析记录\">#</a> DNS 域名解析中添加的各项解析记录</h3>\n<p>A 记录： 将域名指向一个 IPv4 地址（例如：100.100.100.100），需要增加 A 记录</p>\n<p>CNAME 记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。这个域名一般是主机服务商提供的一个域名</p>\n<p>MX 记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置 MX 记录。建立邮箱时，一般会根据邮箱服务商提供的 MX 记录填写此记录</p>\n<p>NS 记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置 NS 记录</p>\n<p>TXT 记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做 SPF（反垃圾邮件）记录</p>\n<p>AAAA 记录： 将主机名（或域名）指向一个 IPv6 地址（例如：ff03:0:0:0:0:0:0:c1），需要添加 AAAA 记录</p>\n<p>SRV 记录： 添加服务记录服务器服务记录时会添加此项，SRV 记录了哪台计算机提供了哪个服务。格式为：服务的名字。协议的类型（例如：_example-server._tcp）。</p>\n<p>SOA 记录： SOA 叫做起始授权机构记录，NS 用于标识多台域名解析服务器，SOA 记录用于在众多 NS 记录中那一台是主服务器</p>\n<p>PTR 记录： PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名</p>\n<p>显性 URL 转发记录： 将域名指向一个 http (s) 协议地址，访问域名时，自动跳转至目标地址。例如：将 www.liuht.cn 显性转发到 www.itbilu.com 后，访问 www.liuht.cn 时，地址栏显示的地址为：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pdGJpbHUuY29t\">www.itbilu.com</span>。</p>\n<p>隐性 UR 转发记录 L： 将域名指向一个 http (s) 协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将 www.liuht.cn 显性转发到 www.itbilu.com 后，访问 www.liuht.cn 时，地址栏显示的地址仍然是：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saXVodC5jbg==\">www.liuht.cn</span>。</p>\n<p><em><strong>Reference:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmx1ZXN0b3JtL3AvMTAzNDUzMzQuaHRtbA==\">https://www.cnblogs.com/bluestorm/p/10345334.html</span></strong></em></p>\n<h1 id=\"iptables详解\"><a class=\"anchor\" href=\"#iptables详解\">#</a> iptables 详解</h1>\n<h2 id=\"防火墙类型\"><a class=\"anchor\" href=\"#防火墙类型\">#</a> 防火墙类型</h2>\n<h3 id=\"包过滤防火墙\"><a class=\"anchor\" href=\"#包过滤防火墙\">#</a> 包过滤防火墙</h3>\n<p>在 Linux 系统下，包过滤功能是内建于核心的 (作为一个核心模块，或者直接内建) , 同时还有一些可以运用于数据包之上的技巧，不过最常用的依然是查看包头以决定包的命运。包过滤防火墙将对每一个接收到的包做出允许或拒绝的决定。具体地讲，它针对每一个数据包的包头，按照包过滤规则进行判定，与规则相匹配的包依据路由信息继续转发，否则就丢弃。包过滤是在 IP 层实现的，包过滤根据数据包的源 P 地址、目的 IP 地址、协议类型 (TCP 包 UDP 包、ICMP 包)、源端口、目的端口等包头信息及数据包传输方向等信息来判断是否允许数据包通过。 包过滤也包括与服务相关的过滤，这是指基于特定的服务进行包过滤，由于绝大多数服务的监听都驻留在特定 TCP/UDP 端口，因此，为阻断所有进入特定服务的链接，防火墙只需将所有包含特定 TCP/UDP 目的端口的包丢弃即可</p>\n<h3 id=\"状态检测防火墙\"><a class=\"anchor\" href=\"#状态检测防火墙\">#</a> 状态检测防火墙</h3>\n<p>状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝。这种技术提供了高度安全的解决方案，同时具有较好的适应性和扩展性。状态检测防火墙基本保持了简单包过滤防火墙的优点，性能比较好，同时对应用是透明的，在此基础上，对于安全性有了大幅提升。这种防火墙摒弃了简单包过滤防火墙仅仅考察进出网络的数据包，不关心数据包状态的缺点，在防火墙的核心部分建立状态连接表，维护了连接，将进出网络的数据当成一个个的事件来处理。可以这样说，状态检测包过滤防火墙规范了网络层和传输层行为，而应用代理型防火墙则是规范了特定的应用协议上的行为。</p>\n<h2 id=\"iptables介绍\"><a class=\"anchor\" href=\"#iptables介绍\">#</a> iptables 介绍</h2>\n<p>netfilter/iptables (简称为 iptables) 组成 Linux 平台下的包过滤防火墙，与大多数的 Linux 软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换 (NAT) 等功能。</p>\n<p>其实 iptables 服务不是真正的防火墙，只是用来定义防火墙规则功能的 &quot;防火墙管理工具&quot;, 将定义好的规则交由内核中的 netfilter 即网络过滤器来读取，从而真正实现防火墙功能。</p>\n<h2 id=\"iptables基本信息\"><a class=\"anchor\" href=\"#iptables基本信息\">#</a> iptables 基本信息</h2>\n<p>规则 (rules) 其实就是网络管理员预定义的条件，规则一般的定义为 &quot;如果数据包头符合这样的条件，就这样处理这个数据包&quot;</p>\n<p>规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议 (如 TCP, UDP,ICMP) 和服务类型 (如 HTTP, FTP 和 SMTP) 等。</p>\n<p>当数据包与规则匹配时，iptables 就根据规则所定义的方法来处理这些数据包，如放行 (accept) 、拒绝 (reject) 和丢弃 (drop) 等。</p>\n<p>配置防火墙的主要工作就是添加、修改和删除这些规则。</p>\n<h2 id=\"表与链介绍\"><a class=\"anchor\" href=\"#表与链介绍\">#</a> 表与链介绍</h2>\n<ul>\n<li>\n<p>表 (tables) 提供特定的功能，iptables 内置了 4 个表，即 filter 表、nat 表、mangle 表和 raw 表，分别用于实现包过滤，网络地址转换、包重构 (修改) 和数据跟踪处理，这些表具有一定的优先级: raw--&gt;mangle--&gt;nat--&gt;filter</p>\n</li>\n<li>\n<p>链 (chains) 是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。</p>\n</li>\n</ul>\n<h2 id=\"规则链\"><a class=\"anchor\" href=\"#规则链\">#</a> 规则链</h2>\n<h3 id=\"一些需要知道的规则链\"><a class=\"anchor\" href=\"#一些需要知道的规则链\">#</a> 一些需要知道的规则链</h3>\n<ol>\n<li>INPUT - 进来的数据包应用此规则链中的策略</li>\n<li>OUTPUT - 外出的数据包应用此规则链中的策略</li>\n<li>FORWARD - 转发数据包时应用此规则链中的策略</li>\n<li>PREROUTING - 对数据包作路由选择前应用此链中的规则 (记住！所有的数据包进来的时候都先由这个链处理)</li>\n<li>POSTROUTING - 对数据包作路由选择后应用此链中的规则 (所有的数据包出来的时候都先由这个链处理)</li>\n</ol>\n<p><span class=\"label\">完整的规则链</span></p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>规则表的先后顺序:<br />\nraw-&gt;mangle-&gt;nat-&gt;filter</p>\n<p>规则链的先后顺序:<br />\n 入站顺序 PREROUTING-&gt;INPUT<br />\n 出站顺序：OUTPUT-&gt;POSTROUTING<br />\n 转发顺序：PREROUTING-&gt;FORWARD-&gt;POSTROUTING</p>\n<h2 id=\"iptables传输数据包的过程\"><a class=\"anchor\" href=\"#iptables传输数据包的过程\">#</a> iptables 传输数据包的过程</h2>\n<p>当一个数据包进入网卡时，它首先进入 PREROUTING 链，内核根据数据包目的 IP 判断是否需要转送出去。</p>\n<p>如果数据包就是进入本机的，它就会向下移动，到达 INPUT 链。数据包到了 INPUT 链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过 OUTPUT 链，然后到达 POSTROUTING 链输出。</p>\n<p>如果数据包是要转发出去的，且内核允许转发，数据包就会经过 FORWARD 链，然后到达 POSTROUTING 链输出。</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<h2 id=\"iptables命令\"><a class=\"anchor\" href=\"#iptables命令\">#</a> iptables 命令</h2>\n<p>iptables 格式:<br />\niptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>详细解释见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdmF0aGUvcC82OTczNjU2Lmh0bWw=\"> https://www.cnblogs.com/vathe/p/6973656.html</span><br />\n 有人总结的挺全的就不造轮子了（懒）。</p>\n<h2 id=\"iptables常识与常用命令\"><a class=\"anchor\" href=\"#iptables常识与常用命令\">#</a> iptables 常识与常用命令</h2>\n<p>CentOS7 默认的防火墙不是 iptables, 而是 firewalle.<br />\n 如果你没有安装 iptables 的话，你可以使用以下命令进行安装<br />\n systemctl stop firewalld<br />\nsystemctl disable firewalld<br />\nsystemctl mask firewalld<br />\n 上面的意思是先屏蔽掉原有的 firewall 防火墙，下面我们就开始安装 iptables，至于为什么要安装 IPtables 我就不讲了<br />\n yum install iptables iptables-services -y</p>\n<p>设置规则<br />\n #查看 iptables 现有规则<br />\n iptables -L -n<br />\n# 先允许所有，不然有可能会杯具<br />\n iptables -P INPUT ACCEPT<br />\n# 清空所有默认规则<br />\n iptables -F<br />\n# 清空所有自定义规则<br />\n iptables -X<br />\n# 所有计数器归 0<br />\niptables -Z<br />\n# 允许来自于 lo 接口的数据包 (本地访问)<br />\niptables -A INPUT -i lo -j ACCEPT<br />\n# 开放 22 端口<br />\n iptables -A INPUT -p tcp --dport 22 -j ACCEPT<br />\n# 开放 21 端口 (FTP)<br />\niptables -A INPUT -p tcp --dport 21 -j ACCEPT<br />\n# 开放 80 端口 (HTTP)<br />\niptables -A INPUT -p tcp --dport 80 -j ACCEPT<br />\n# 开放 443 端口 (HTTPS)<br />\niptables -A INPUT -p tcp --dport 443 -j ACCEPT<br />\n# 允许 ping<br />\niptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT<br />\n# 允许接受本机请求之后的返回数据 RELATED, 是为 FTP 设置的<br />\n iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT<br />\n# 其他入站一律丢弃<br />\n iptables -P INPUT DROP<br />\n# 所有出站一律绿灯<br />\n iptables -P OUTPUT ACCEPT<br />\n# 所有转发一律丢弃<br />\n iptables -P FORWARD DROP</p>\n<p>其他规则设定<br />\n #如果要添加内网 ip 信任（接受其所有 TCP 请求）<br />\niptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT<br />\n# 过滤所有非以上规则的请求<br />\n iptables -P INPUT DROP<br />\n# 要封停一个 IP，使用下面这条命令：<br />\niptables -I INPUT -s ... -j DROP<br />\n# 要解封一个 IP，使用下面这条命令:<br />\niptables -D INPUT -s ... -j DROP</p>\n<p>#保存上述规则<br />\n service iptables save<br />\n 开启 iptables 服务<br />\n #注册 iptables 服务<br />\n #相当于以前的 chkconfig iptables on<br />\nsystemctl enable iptables.service<br />\n# 开启服务<br />\n systemctl start iptables.service<br />\n# 查看状态<br />\n systemctl status iptables.service</p>\n<h1 id=\"linux进程\"><a class=\"anchor\" href=\"#linux进程\">#</a> Linux 进程</h1>\n<p>推荐一篇博客，《<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTg0NTEtMS5odG1s\">关于 Linux 进程你所需要知道的一起</span>》</p>\n<h2 id=\"top命令实时的查看进程的状态\"><a class=\"anchor\" href=\"#top命令实时的查看进程的状态\">#</a> top 命令：实时的查看进程的状态</h2>\n<p>top 是一个前台程序，所以是可以交互的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常用交互命令</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">q</td>\n<td style=\"text-align:left\">退出程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">l</td>\n<td style=\"text-align:left\">切换显示平均负载和启动时间的信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">P</td>\n<td style=\"text-align:left\">根据 CPU 使用百分比大小进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">M</td>\n<td style=\"text-align:left\">根据驻留内存大小进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">忽略闲置和僵死的进程，这是一个开关式命令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k</td>\n<td style=\"text-align:left\">终止一个进程，系统提示输入 PID 及发送的信号值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ps命令\"><a class=\"anchor\" href=\"#ps命令\">#</a> ps 命令</h2>\n<p>ps -ef 显示所有进程的详细信息</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">UID</th>\n<th style=\"text-align:left\">PID</th>\n<th style=\"text-align:left\">PPID</th>\n<th style=\"text-align:left\">C</th>\n<th style=\"text-align:left\">STIME</th>\n<th style=\"text-align:left\">TTY</th>\n<th style=\"text-align:left\">CMD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">用户 ID</td>\n<td style=\"text-align:left\">进程的 ID</td>\n<td style=\"text-align:left\">父进程 ID</td>\n<td style=\"text-align:left\">进程占用 CPU 的百分比</td>\n<td style=\"text-align:left\">进程启动的时间</td>\n<td style=\"text-align:left\">该进程在那个终端上运行。若与终端无关，则显示？若为 pts/0 等，则表示由网络连和参数接主机进程。</td>\n<td style=\"text-align:left\">命令的名称和参数</td>\n</tr>\n</tbody>\n</table>\n<p>ps -aux 显示所有进程信息</p>\n<p><img data-src=\"image009.png\" alt=\"\" /><br />\n<img data-src=\"image010.png\" alt=\"\" /></p>\n<p>ps -A 显示所有的进程信息<br />\n ps -u root 显示指定用户的进程信息<br />\n ps -l 显示目前属于本次登陆得 PID 相关信息</p>\n<p><code>ps -ef|grep sshd|grep -v &quot;grep&quot;</code>  配合管道符与 grep，显示 sshd 的进程信息。</p>\n<h2 id=\"kill-命令\"><a class=\"anchor\" href=\"#kill-命令\">#</a> kill 命令</h2>\n<p>kill 命令：用于删除执行的程序或工作，通过向进程发送指定的信号来结束进程。</p>\n<p>用法：kill  [信号] PID</p>\n<p>常用信号：<br />\n2  结束进程，不是强制性的，&quot;Ctrl + C&quot; 发出的就是 kill -2 信号<br />\n 3  退出<br />\n 9  杀死进程，强制结束进程。</p>\n<h1 id=\"端口\"><a class=\"anchor\" href=\"#端口\">#</a> 端口</h1>\n<p>在 Linux 操作系统下，系统共定义了 65536 个可用的端口。<br />\n对于 0-1023 端口，都需要 root 身份才能启用，这些端口主要用于系统一些常见的通信服务中。比如: 21 ftp 服务、22 ssh 服务、80 http 服务等...<br />\n 端口的开启和关闭也就是软件服务的启动和关闭</p>\n<h2 id=\"chkconfig命令\"><a class=\"anchor\" href=\"#chkconfig命令\">#</a> chkconfig 命令</h2>\n<p>chkconfig 来判断服务是开启还是关闭状态<br />\n例如 chkconfig --list sshd</p>\n<h2 id=\"netstat命令\"><a class=\"anchor\" href=\"#netstat命令\">#</a> netstat 命令</h2>\n<p>netstat 命令：用于显示 tcp, udp 的端口和进程情况<br />\n用法:<br />\nnetstat [选项]<br />\n-a 显示所有<br />\n - t 仅显示 tcp 相关选项<br />\n - u 仅显示 udp 相关选项<br />\n - n 拒绝显示别名，能显示数字的全部转化为数字<br />\n - l 仅列出在 Listen (监听) 的服务状态<br />\n - p 显示建立相关链接的程序名</p>\n<p>常用命令:<br />\nnetstat-antlp // 查看当前所有 tcp 端口<br />\n netstat-antulp|grep 80 // 查看所有 80 端口使用情况</p>\n<h1 id=\"linux计划任务\"><a class=\"anchor\" href=\"#linux计划任务\">#</a> linux 计划任务</h1>\n<p>计划任务，就是在约定好的时间执行已经计划好的工作。<br />\n未来的某时间点执行一次某任务或者周期性的运行某个任务，执行结果会通过邮形式发送给用户。</p>\n<h2 id=\"安全与计划任务\"><a class=\"anchor\" href=\"#安全与计划任务\">#</a> 安全与计划任务</h2>\n<p>挖矿病毒：<br />\n使用 top 查看 CPU，显示进程占 cpu99% 以上。杀掉进程后，到了晚上还是会自动运行进程。<br />\n检测定时任务，发现有一个异常的定时任务</p>\n<h2 id=\"at命令\"><a class=\"anchor\" href=\"#at命令\">#</a> at 命令</h2>\n<p>at 命令 一次性计划任务<br />\n默认自带 at<br />\n <code>yum install at -y</code>     下载 at</p>\n<p>开启服务:<br />\nservice atd start</p>\n<p>用法:<br />\nat (选项)<br />\n 选项<br />\n - f: 指定包含具体指令的任务文件；<br />\n-q: 指定新任务的队列名称；<br />\n-l: 显示待执行任务的列表；<br />\n-d: 删除指定的待执行任务；<br />\n-m: 任务执行完成后向用户发送 E-mail;</p>\n<p><span class=\"label\">实例</span></p>\n<p>at 10:00    确切时间<br />\n at now +10 minutes  十分钟后执行<br />\n at 17:04 04/04/2018  2018483817:04 执行<br />\n at 17:04 04/04/2018  2018483817:04 执行</p>\n<p>at 1am tomorrow 明天上午一点运行作业<br />\n at-c id    根据作业 ID 查看执行细节<br />\n atq        查看待处理的任务<br />\n atrm id    删除 id 的任务</p>\n<h2 id=\"crondtab命令\"><a class=\"anchor\" href=\"#crondtab命令\">#</a> crondtab 命令</h2>\n<p>crondtab 命令 周期性计划任务</p>\n<p>crond 是 linux 下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。</p>\n<p>Linux 系统上系统服务是默认启动的，使用者控制计划任务命令:crontab 命令。</p>\n<p>crontab 其实是一个命令，用来读取和修改名为 crontab 的文件。/etc/crontab 文件包含了要定时执行的程序列表。</p>\n<p>安装 crontab: 默认自带<br />\n <code>yum install crontabs</code></p>\n<p>服务命令:</p>\n<p>service crond start // 启动服务 service crond stop // 关闭服务 service crond restart// 重启服务 service crond reload // 重新载入配置</p>\n<p>crontab 命令 周期性计划任务</p>\n<p>1、命令格式:</p>\n<p>crontab [-u user] file<br />\ncrontab [-u user] 【选项】</p>\n<p>常用选项:</p>\n<p>-e: 编辑计划任务 edit<br />\n-l: 查看计划任务 display<br />\n-u: 指定用户</p>\n<p>常用命令:</p>\n<p>crontab -l 列出当前用户的计划任务<br />\n crontab -r 删除当前用户所有的计划任务<br />\n crontab -e 编辑当前用户的计划任务<br />\n crontab-e -u root 编辑 root 用户的计划任务</p>\n<p>第一列：分钟 (0-59)<br />\n 第二列：小时 (0-23)<br />\n 第三列：天 (1-31)<br />\n 第四列：月 (1-12)<br />\n 第五列：周 (0-6) 0 表示周日</p>\n<p>&quot;<em>&quot; 表示所有的取值，就是</em> / 1&quot;<br />\n&quot;/&quot; 表示每的意思<br />\n */5&quot; 表示每 5 个单位<br />\n &quot;-&quot; 表示从某个数字到某个数字<br />\n &quot;,&quot; 表示分散的数字</p>\n<p><img data-src=\"crontab.png\" alt=\"\" /></p>\n<p><span class=\"label\">实例</span><br />\n<img data-src=\"image011.png\" alt=\"\" /></p>\n<h1 id=\"日志服务\"><a class=\"anchor\" href=\"#日志服务\">#</a> 日志服务</h1>\n<h2 id=\"基础信息\"><a class=\"anchor\" href=\"#基础信息\">#</a> 基础信息</h2>\n<p>在 CentOS 6.x 中，日志服务已经由 rsyslogd 取代了原先的 syslogd.<br />\nrsyslogd 相比 syslogd 具有一些新的特点:<br />\n 基于 TCP 网络协议传输日志信息。<br />\n更安全的网络传输方式。<br />\n有日志信息的即时分析框架。<br />\n后台数据库。<br />\n在配置文件中可以写简单的逻辑判断。<br />\n与 syslog 配置文件相兼容。</p>\n<p>查看 rsyslogd 服务是否启动<br />\n <code>ps aux|grep &quot;rsyslogd&quot;|grep -v &quot;grep&quot;</code> <br />\n 查询 rsyslogd 服务的自启动状态<br />\n <code>chkconfig --list|grep &quot;rsyslog&quot;</code> <br />\n <code>systemctl list-unit-files|grep &quot;rsyslog&quot;</code></p>\n<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务，但是 apache 日志文件的格式和系统默认日志的格式是一致的。</p>\n<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务，但是 apache 日志文件的格式和系统默认日志的格式是一致的。</p>\n<p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br />\n系统日志文件的保存位置是 /var/log/ 目录</p>\n<p><img data-src=\"image012.png\" alt=\"\" /><br />\n<img data-src=\"image013.png\" alt=\"\" /><br />\n<img data-src=\"image014.png\" alt=\"\" /></p>\n<p>日志服务 rsyslogd 记录的日志文件格式包含以下 4 列:</p>\n<p>1. 事件产生的时间。<br />\n2. 产生事件的服务器的主机名。<br />\n3. 产生事件的服务名或程序名。<br />\n4. 事件的具体信息。</p>\n<p>/var/log/secure 日志文件内容:</p>\n<p><img data-src=\"image015.png\" alt=\"\" /></p>\n<p>/var/log/secure 记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</p>\n<p>/var/log/wtmp 永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件</p>\n<p>/var/tun/ulmp 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。</p>\n<h2 id=\"rsyslogd配置文件\"><a class=\"anchor\" href=\"#rsyslogd配置文件\">#</a> rsyslogd 配置文件</h2>\n<p>rsyslogd 服务的配置文件是 /etc/rsyslog.conf , 其中主要定义了服务的名称、日志等级和日志记录位置。</p>\n<p>该配置文件的基本格式如下所示:</p>\n<p>authpriv.*                  /var/log/secure<br />\n# 服务名称 [连接符号] 日志等级   日志记录位置</p>\n<h2 id=\"日志等级\"><a class=\"anchor\" href=\"#日志等级\">#</a> 日志等级</h2>\n<p><img data-src=\"image016.png\" alt=\"\" /></p>\n<p>详细见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbmJsb2dzLmNvbS9rbGI1NjEvcC8xMjAxNDI2OC5odG1s\"> https://cnblogs.com/klb561/p/12014268.html</span></p>\n<h2 id=\"连接符\"><a class=\"anchor\" href=\"#连接符\">#</a> 连接符</h2>\n<p>连接符号:</p>\n<ol>\n<li>&quot;.&quot; 代表只要比后面的等级高的 (包含该等级) 日志都记录。比如，&quot;<span class=\"exturl\" data-url=\"aHR0cDovL2Nyb24uaW5mbw==\">cron.info</span>&quot; 代表 cron 服务产生的日志，只要日志等级大于等于 info 级别，就记录。</li>\n<li>&quot;.=&quot; 代表只记录所需等级的日志，其他等级的日志都不记录。比如，&quot;*.=emerg&quot; 代表人和日志服务产生的日志，只要等级是 emerg 等级，就记录。这种用法极少见，了解就好。</li>\n<li>&quot;.!&quot; 代表不等于，也就是除该等级的日志外，其他等级的日志都记录。</li>\n</ol>\n<h2 id=\"日志记录位置\"><a class=\"anchor\" href=\"#日志记录位置\">#</a> 日志记录位置</h2>\n<p>日志记录位置：当前日志输出到哪个日志文件中保存</p>\n<p>日志文件的绝对路径。例如: &quot;/ar/log/secure&quot;</p>\n<p>系统设备文件。如 &quot;/dev/lpo&quot; 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</p>\n<p>用户名。如果是 &quot;root&quot; , 把日志发送给 root 用户 (用户要在线) &quot;*&quot; 代表发送给所有在线用户，如 &quot;mail**&quot; 就会把 mail 服务产生的所有级别的日志发送给所有在线用户。发给多个在线用户，则用户名之间用 &quot;,&quot; 分隔。</p>\n<p>忽略或丢弃日志。如果接收日志的对象是 &quot;~&quot; , 则代表这个日志不会被记录，而被直接丢弃。如 &quot;local3.*~&quot; 代表忽略 local3 服务类型所有的日志都不记录。</p>\n<h2 id=\"日志管理\"><a class=\"anchor\" href=\"#日志管理\">#</a> 日志管理</h2>\n<p>日志管理:</p>\n<p>日志维护的最主要的工作就是把旧的日志文件删除，从而腾出空间保存新的日志文件。</p>\n<p>logrotate 就是用来进行日志轮替的，就是把旧的日志文件移动并改名，同时创建一个新的空日志文件用来记录新日志，当旧日志文件超出保存的范围时就删除。</p>\n<p>日志文件的命名规则:</p>\n<ol>\n<li>服务加日期</li>\n<li>服务加数字</li>\n</ol>\n<p>查看日志备份文件<br />\n ls /var/log</p>\n<p>logrotate 令可以进行日志转储 (轮替)</p>\n<p>logrotate 命令会依据 /etc/logrotate.conf 配置文件的配置，来判断配置文件中的日志是否符合日志轮替的条件 (比如，日志备份时间已经满一周) , 如果符合，日志就会进行轮替。</p>\n<p>/etc/logrotate.conf 配置文件的<br />\n cat /etc/logrotate.conf<br />\n 详细讲解</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzExMDYuaHRtbA==\">http://c.biancheng.net/view/1106.html</span></p>\n<h1 id=\"系统服务\"><a class=\"anchor\" href=\"#系统服务\">#</a> 系统服务</h1>\n<p>什么是系统服务？<br />\n 服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。<br />\n我们把这些应用程序称作服务，也就是 Service.<br />\nLinux 中常见的服务有那些，这些服务怎么分类，服务如何启动，服务如何自启动，服务如何查看？</p>\n<p>服务 Service, Daemon 这个词也经常伴随着出现。<br />\nDaemon 翻 i 成 &quot;守护进程&quot;<br />\n 守护进程：就是为了实现服务、功能的进程。<br />\n比如，apache 服务就是服务 (Service) , 它是用来实现 Web 服务的。<br />\n那么，启动 apache 服务的进程是哪个进程呢？<br />\nhttpd 这个守护进程 (Daemon) 。<br />\n在 Linux 中就是通过启动 httpd 进程来启动 apache 服务的。<br />\n也就是说，守护进程就是服务在后台运行的真实进程。</p>\n<p><img data-src=\"image017.png\" alt=\"\" /></p>\n<p>Linux 中的服务按照安装方法不同可以分为 RPM 包默认安装的服务和源码包安装的服务两大类。</p>\n<p>区别:</p>\n<p>RPM 包安装到系统默认位置，可以被服务管理命令识别；但是源码包安装到手工指定位置，当然就不能被服务管理命令识别了 (可以手工修改为被服务管理命令识别)。</p>\n<h2 id=\"启动服务\"><a class=\"anchor\" href=\"#启动服务\">#</a> 启动服务</h2>\n<p>启动服务方式:</p>\n<p>1) 使用 /etc/init.d/ 目录中的启动脚本来启动独立的服务</p>\n<p>2) 使用 service 命令来启动独立的服务</p>\n<p>1) 使用 /etc/init.d/ 目录中的启动脚本来启动独立的服务</p>\n<p>所有独立服务的启动脚本都存放在 /etc/init.d/ 目录中，调用脚本就可以启动独立的服务了。</p>\n<p>命令格式如下:</p>\n<p>/etc/init.d/ 独立服务名参数参数:</p>\n<p>start: 启动服务；<br />\nstop: 停止服务；<br />\nstatus: 查看服务状态；<br />\nrestart: 重启动服务；</p>\n<p>2) 使用 service 命令来启动独立的服务</p>\n<p>在 CentOS 系统中，我们还可以依赖 service 命令来启动独立的服务。service 命令实际上只是一个脚本，这个脚本仍然需要调用 /etc/init.d/ 中的启动脚本来启动独立的服务。</p>\n<p>service 命令格式如下:</p>\n<p>service 独立服务名 start|stop|restart|..</p>\n<p><code>service --status-all 查看所有服务</code></p>\n<h2 id=\"服务的自启动\"><a class=\"anchor\" href=\"#服务的自启动\">#</a> 服务的自启动</h2>\n<p>使用 chkconfig 服务自启动管理命令</p>\n<p>格式:</p>\n<p>查看所有服务的自启动状态<br />\n chkconfig -list</p>\n<p>设置某服务的自启动状态</p>\n<p>chkconfig [--level 运行级别][独立服务名][on|off]</p>\n<p><img data-src=\"image018.png\" alt=\"\" /></p>\n<p>想把某个已经安装了的服务添加为系统服务，可以执行以下命令：</p>\n<p><code>chkconfig --add 服务名称</code>           (首先，添加为系统服务，注意 add 前面有两个横杠)</p>\n<p><code>chkconfig -leve 启动级别 服务名 on</code></p>\n<h1 id=\"下载与安装\"><a class=\"anchor\" href=\"#下载与安装\">#</a> 下载与安装</h1>\n<h2 id=\"wget\"><a class=\"anchor\" href=\"#wget\">#</a> wget</h2>\n<p>wget 是一个下载文件的工具，它用在命令行下</p>\n<p>语法：wget [选项] url</p>\n<p>选项：</p>\n<p>-V 显示 wget 版本信息并退出。<br />\n-h 打印此帮助<br />\n - O 指定下载文件的别名。</p>\n<p><img data-src=\"image019.png\" alt=\"\" /></p>\n<h2 id=\"rpm\"><a class=\"anchor\" href=\"#rpm\">#</a> rpm</h2>\n<p>Linux rpm 命令用于管理套件，增强了程序安装卸载的管理。</p>\n<p>RPM 的功能：打包、安装、查询、升级、卸载...</p>\n<p>缺点: RPM 无法解决软件包的依赖关系</p>\n<p>RPM 包的命名规范: name-version-release.os.arch.rpm</p>\n<p><img data-src=\"image020.png\" alt=\"\" /></p>\n<p>!{}(image021.png)</p>\n<h2 id=\"yum\"><a class=\"anchor\" href=\"#yum\">#</a> yum</h2>\n<p>yum 基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包和安装</p>\n<p>优点：可以自动处理关联关系，并且一次安装所有依赖的软件包，无须繁琐地一次下载，安装。</p>\n<p>语法 ：<br />\nyum [选项] [包……]</p>\n<p>选项：<br />\n-h 帮助<br />\n - y 当安装过程中提示选择全部为 “yes”<br />\n-q 不显示安装过程</p>\n<p>检测有没有安装 yum<br />\nyum -h<br />\nrpm -qa | grep yum</p>\n<ol>\n<li><span class=\"label info\">相关命令</span></li>\n</ol>\n<p>1・列出所有可更新的软件清单命令: yum check-update<br />\n2 更新所有软件命令: yum update<br />\n3 仅安装指定的软件命令: yum install 包名称<br />\n 4 仅更新指定的软件命令: yum update 包名称<br />\n 5 列出所有可安装的软件清单命令: yum list<br />\n6 删除删除命令: yum remove 包名称<br />\n 7 清除缓存命令:<br />\n 清除缓存目录 (/var/cache/yum) 下的软件包<br />\n命令：yum clean packages</p>\n<p>清除缓存目录 (/var/cache/yum) 下的 headers<br />\n 命令：yum clean headers</p>\n<p>清除缓存目录 (/var/cache/yum) 下旧的 headers<br />\n 命令：yum clean oldheaders</p>\n<p>清除缓存目录 (/var/cache/yum) 下的软件包及旧的 headers<br />\n 命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</p>\n<ol start=\"2\">\n<li><span class=\"label info\">yum list 相关命令</span></li>\n</ol>\n<p><img data-src=\"iamge022.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>安装应用程序</li>\n</ol>\n<p>语法: yum [-y] install 包 1 包 2…… 包 n<br />\nyum install wget    使用安装 wget</p>\n<p>升级软件包</p>\n<p>命令格式: yum update 包 1 包 2…… 包 n<br />\nyum check-update 检测可升级的包</p>\n<p>卸载软件包</p>\n<p>命令格式: yum remove 包 1 包 2…… 包 n<br />\n 注意：卸载时注意依赖关系</p>\n<h1 id=\"文件打包和解压缩\"><a class=\"anchor\" href=\"#文件打包和解压缩\">#</a> 文件打包和解压缩</h1>\n<p>linux 中常用的五种压缩格式: .zip .gz .tar.gz .bz2 .tar.bz2</p>\n<p>打包和压缩:</p>\n<p>打包是指将一大堆文件或目录什么的变成一个总的文件<br />\n压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p>\n<h2 id=\"tar命令\"><a class=\"anchor\" href=\"#tar命令\">#</a> tar 命令</h2>\n<p>Linux 中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另它的工具将这一大堆文件先打成一个包，然后再就原来的压缩程序进行压缩。</p>\n<p>Liunx 下最常用的打包命令是 tar, 使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命通常都是以.tar 结尾的。<br />\n生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法</p>\n<p>语法:<br />\ntar 【选项】 打包文件包 源文件<br />\n选项:<br />\n-c: 打包<br />\n - v: 显示详细过程<br />\n - x: 解打包 / 压缩<br />\n - z: 通过 gzip 压缩 / 解压文件<br />\n - j: 通过 bz2 压缩 / 解压文件<br />\n - C: 解压到指定目录<br />\n - f filename: 指定打包后的文件名 (必选，这个参数是最后一个参数，后面只能接文件名)</p>\n<p>常用命令:<br />\ntar -cf all.tar *.jpg  #将所有.jpg 的文件打成一个名为 all.tar 的包<br />\n tar -xvf all.tar  #解出 all.tar 包中所有文件，-x 是解开的意思</p>\n<p>为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能 -- 就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip.bzip2 等。</p>\n<h2 id=\"解压缩与压缩\"><a class=\"anchor\" href=\"#解压缩与压缩\">#</a> <span class=\"label info\">解压缩与压缩</span></h2>\n<p><img data-src=\"image022.png\" alt=\"\" /></p>\n<h2 id=\"zip\"><a class=\"anchor\" href=\"#zip\">#</a> zip</h2>\n<p>zip 【选项】 【压缩文件】</p>\n<p>选项:<br />\n-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。<br />\n-q 不显示指令执行过程。<br />\n-r 递归处理，将指定目录下的所有文件和子目录一并处理。<br />\n-v 显示指令执行过程或显示版本信息。</p>\n<p>实例</p>\n<p>将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip:</p>\n<p>zip-qr html.zip /home/html</p>\n<h2 id=\"unzip\"><a class=\"anchor\" href=\"#unzip\">#</a> unzip</h2>\n<p>unzip 【选项】 【压缩文件】</p>\n<p>选项:</p>\n<p>-l 显示压缩文件内所包含的文件 - V 执行是时显示详细的信息。<br />\n-q 执行时不显示任何信息。<br />\n-d &lt;目录&gt; 指定文件解压缩后所要存储的目录。</p>\n<p>实例</p>\n<p>解压文件<br />\n <code>unzip abc.zip</code></p>\n<p>查看压缩文件中包含的文件:<br />\n <code>unzip-l abc.zip</code></p>\n<h2 id=\"gzip\"><a class=\"anchor\" href=\"#gzip\">#</a> gzip</h2>\n<ol>\n<li>tar 调用 gzipgzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip.<br />\ntar 中使用 - z 这个参数来调用 gzip 常用命令:</li>\n</ol>\n<p><code>tar-czf all.tar.gz *.jpg</code>   #将所有.jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包 all.tar.gz</p>\n<p><code>tar-xzf all.tar.gz</code>   #将包 all.tar.z 解开</p>\n<ol start=\"2\">\n<li>tar 调用 bzip2bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip</li>\n</ol>\n<p>tar 中使用 - j 这个参数来调用 bzip2</p>\n<p>常用命令:</p>\n<p>tar -cjfall.tar.bz2 *.jpg #将所有.jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p>\n<p>tar -xjf all.tar.bz2  #将上面产生的包解开</p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://or0kit.github.io/Linux/Linux-Reviewing/",
            "url": "https://or0kit.github.io/Linux/Linux-Reviewing/",
            "title": "初学Linux",
            "date_published": "2020-12-31T11:23:08.000Z",
            "content_html": "<h1 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h1>\n<h2 id=\"linux是谁开发的-是用什么语言开发的-unix的开源精神\"><a class=\"anchor\" href=\"#linux是谁开发的-是用什么语言开发的-unix的开源精神\">#</a> Linux 是谁开发的、是用什么语言开发的、Unix 的开源精神</h2>\n<p>1991 年 Linus Torvalds（林纳斯。托瓦兹）写出 Linux 内核的第一个版本；<br />\n1992 年第一个发行版出现；<br />\nGNU/Linux 系统 = Linux 内核 + GNU；发行版有：Red Hat,Debain,Suse,Mandrake,Redflag...<br />\nGNU：即革奴计划，由理查德。斯托曼发起，目标是创建一套完全自由的操作系统；<br />\n其他：EMACS、Copyleft</p>\n<h2 id=\"mbr简介\"><a class=\"anchor\" href=\"#mbr简介\">#</a> MBR 简介</h2>\n<p>一块硬盘最多拥有 4 个主分区 (包括扩展分区)。这是</p>\n<p>ps: 44 页前</p>\n<h1 id=\"linux下的shell相关的操作\"><a class=\"anchor\" href=\"#linux下的shell相关的操作\">#</a> Linux 下的 shell 相关的操作</h1>\n<p>shell 是 Linux 系统的一个重要组成部分。在 Linux 系统中，shell 就是一组介于用户与 Linux 内核之间的系统程序。shell 是用户与 Linux 内核之间的接口。</p>\n<h2 id=\"shell的分类\"><a class=\"anchor\" href=\"#shell的分类\">#</a> shell 的分类</h2>\n<p>hell 有着不同的分类，比如 Bourne shell（sh），Korn shell（ksh）、C shell （csh）、Bourne-again shell（bash）、tcsh。其中最常用的有 csh 和 bash，其提示符如下：<br />\nsh–Bash ：#root $user<br />\ncsh–:#root %user</p>\n<h2 id=\"简单的shell命令\"><a class=\"anchor\" href=\"#简单的shell命令\">#</a> 简单的 shell 命令</h2>\n<p>Linux 命令又称 shell 命令。</p>\n<h3 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h3>\n<p>命令名 【选项】 【参数】</p>\n<p>命令行输入的第一个字必须是一个命令的名字，第二个字是明明令的选项或参数，命令行中的每个字必须有空格隔开。【选项】的方括号表示语法上选项是可有可无的。选项旺旺包括一个或多个英文字母，在字母前面必须有一个减号【减号是必须的，Linux 用它来区分选项和参数，参数是不带减号的】</p>\n<h3 id=\"pwd\"><a class=\"anchor\" href=\"#pwd\">#</a> pwd</h3>\n<p>格式：pwd（print work directory 缩写）</p>\n<p>功能：显示当前目录的绝对路径。</p>\n<h3 id=\"cd\"><a class=\"anchor\" href=\"#cd\">#</a> cd</h3>\n<p>格式：cd 【目录】<br />\n功能：切换到指定目录。</p>\n<p>‘change directory’的缩写</p>\n<p>cd ../   返回到上一级目录<br />\n cd      不带任何参数表示返回到家目录<br />\n cd -    <em><strong>返回上一个目录</strong></em>。</p>\n<h3 id=\"ls\"><a class=\"anchor\" href=\"#ls\">#</a> ls</h3>\n<p>格式：ls 【选项】 【文件 | 目录】<br />\n功能：显示指定目录下的内容。内容包括该目录下的文件和子目录。当不指定目录时，默认显示当前面目录下中的文件和子目录信息。‘list’的缩写。</p>\n<p>主要选项：<br />\n-a 显示所有文件和子目录，包括隐藏文件和隐藏自子目录。Linux 下的隐藏文件和隐藏子目录以‘.’开头。<br />\n-l 显示文件和子目录详细信息，即以长格式显示，包括文件类型、权限、拥有人和拥有组、文件大小、最近一次修改时间、文件名等信息。<br />\n-d 参数应该是目录，只显示目录的信息，而不显示其中所包含的文件机子目录的信息，该选项通常与‘-l’一起使用，后接目录名，功能是以长格式显示目录信息。<br />\n-R 不仅显示指定目录下的文件和子目录信息，而且还递归地显示各子路录下的文件和子目录信息。<br />\n-t 按照时间顺序显示文件，新的文件排在前面。ls 命令默认按照字母顺序排列。<br />\n--help 查看帮助信息。</p>\n<h3 id=\"date\"><a class=\"anchor\" href=\"#date\">#</a> date</h3>\n<p>格式：date【+FORMAT】 或 date 【MMDDhhmm【YY】【YYYY】】<br />\n功能：查看或修改系统时间。</p>\n<p>date 命令显示的内容依次是星期、月份、小时、分钟、秒、时区和年份。</p>\n<h3 id=\"cal\"><a class=\"anchor\" href=\"#cal\">#</a> cal</h3>\n<p>格式：cal【YYYY】<br />\n功能：显示日历<br />\n显示本月的日历。若参数为年份，则显示该年的日历。</p>\n<h3 id=\"who\"><a class=\"anchor\" href=\"#who\">#</a> who</h3>\n<p>格式：who<br />\n 功能：显示当前已登录到系统的所有用户名及其终端名和登录到系统的时间。</p>\n<h3 id=\"clear\"><a class=\"anchor\" href=\"#clear\">#</a> clear</h3>\n<p>格式：clear<br />\n 功能：清楚当前终端的屏幕内容。<br />\n也可以使用快捷组合键 Ctrl + L</p>\n<h2 id=\"获取帮助\"><a class=\"anchor\" href=\"#获取帮助\">#</a> 获取帮助</h2>\n<h3 id=\"whatis\"><a class=\"anchor\" href=\"#whatis\">#</a> whatis</h3>\n<p>格式：whatis 命令名<br />\n功能： 查询某命令的简单功能。</p>\n<p>但该命令信息量较少，且该命令是基于数据库的查询，对于刚安装的命令则查询不到，等到系统更新后才能查到。若要立即查询，则使用 makewhatis 立即生效更新数据库，然后再用该命令进行查询。</p>\n<h3 id=\"-help\"><a class=\"anchor\" href=\"#-help\">#</a> --help</h3>\n<p>格式： 命令名 --help<br />\n 功能：显示指定命令的帮助信息。</p>\n<h3 id=\"man\"><a class=\"anchor\" href=\"#man\">#</a> man</h3>\n<p>格式：man 命令名<br />\n功能：显示指定命令的手册页帮助信息。</p>\n<h3 id=\"info\"><a class=\"anchor\" href=\"#info\">#</a> info</h3>\n<p>格式：info 命令名<br />\n功能：查询命令的用法合作文件的格式。</p>\n<h3 id=\"usrsharedoc\"><a class=\"anchor\" href=\"#usrsharedoc\">#</a> /usr/share/doc</h3>\n<p>帮助文档就位于 /usr/share/doc 目录下。</p>\n<p>以上获取帮助的方法，man 命令是最常使用的。</p>\n<h2 id=\"bash变量\"><a class=\"anchor\" href=\"#bash变量\">#</a> bash 变量</h2>\n<h3 id=\"变量的设置与引用\"><a class=\"anchor\" href=\"#变量的设置与引用\">#</a> 变量的设置与引用</h3>\n<p>变量名 = 值</p>\n<p>引用格式为 “<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>变量名”或者“</mtext></mrow><annotation encoding=\"application/x-tex\">变量名”或者“</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord\">”</span><span class=\"mord cjk_fallback\">或</span><span class=\"mord cjk_fallback\">者</span><span class=\"mord\">“</span></span></span></span>{变量名}”，一般情况下可以不用加大括号，但有些情况下必须要加大括号。</p>\n<p>echo $Atest  将 Atest 当作一个变量；<br />\necho ${A} test  test 将在变量 A 之后。</p>\n<h3 id=\"环境变量\"><a class=\"anchor\" href=\"#环境变量\">#</a> 环境变量</h3>\n<p>系统中影响到 bash 环境的变量被称为环境变量。可以使用 env 或 export 来查阅系统默认的环境变量。</p>\n<p>常用的环境变量</p>\n<ol>\n<li>\n<p>PS1: 系统提示符环境变量。</p>\n</li>\n<li>\n<p>HISTSIZE: 默认保存的历史记录数。</p>\n</li>\n<li>\n<p>PATH: 执行文件查找的路径。<br />\nPATH 的值都是一些目录，目录与目录之间以冒号（:）分隔，由于文件的查找是依序有 PATH 变量内的目录来查找的，所以目录的顺序也很重要。</p>\n</li>\n<li>\n<p>USER: 当前登录的用户。</p>\n</li>\n<li>\n<p>HOME: 当前用户的家目录。</p>\n</li>\n<li>\n<p>EUID: 当前用户的 UID</p>\n</li>\n</ol>\n<h2 id=\"与shell有关的配置文件\"><a class=\"anchor\" href=\"#与shell有关的配置文件\">#</a> 与 shell 有关的配置文件</h2>\n<ol>\n<li>\n<p>/etc/profile 文件、这是系统最重要的 shell 配置文件，也是用户登录系统最先检查的文件，系统的环境变量多定义在此文件中，主要包括 PATH、USER、LANG、MAIL、HOSTNAME、HISTSIZE 和 INPUTRC。</p>\n</li>\n<li>\n<p>~/.bash_profile 文件。每个用户的 bash 环境配置文件，存在于用户目录的家目录下，当系统运行 /etc/profile/ 后，将读取此文件的内容，此文件定义了 USER、EUID、HOME、PATH 等环境变量，此处的 PATH 包括了用户自己定义的路径以及用户的 “bin” 路径</p>\n</li>\n<li>\n<p>~/.bashrc 文件。 前两个文件仅在系统登录时读取。此文件在每次运行 bash 是读取，此文件主要定义的是一些终端设置以及 Shell 提示符等。而不定义环境变量等内容。</p>\n</li>\n<li>\n<p>~/.bash_history 文件。该文件保存了用户的历史记录。</p>\n</li>\n</ol>\n<h2 id=\"历史记录命令\"><a class=\"anchor\" href=\"#历史记录命令\">#</a> 历史记录命令</h2>\n<p>可以利用上下方向键调出已经执行过的 Shell 命令。</p>\n<p>还可以用 history 命令查看 Shell 命令的历史记录</p>\n<p>格式：history【数字】<br />\n功能：查看 Shell 命令的历史记录。如果指定参数则查看最近执行过的指定个数的 Shell 命令</p>\n<p>还有 '!' 也可以调出一执行过的 Shell 命令。<br />\n格式：! 序号<br />\n功能：执行指定序号的 Shell 命令，‘!’ 后面也可以跟字符串来调用已执行过的以该字符串开头的 Shell 命令。</p>\n<p>~<br />\n<font color=\"red\">在 ContOS7 上不知道为什么不能用 '!' 命令，man 命令提示没有 '!' 命令手册</font><br />\n~<br />\n 原来是感叹号与后面的的序号之间没有空格。</p>\n<p>!! 是执行上一条命令</p>\n<h2 id=\"通配符\"><a class=\"anchor\" href=\"#通配符\">#</a> 通配符</h2>\n<p>* : 通配 0 个或多个字符</p>\n<p>？ ：通配任意单个字符</p>\n<p><code>* ？ [] - !</code>  可以组成字符组。</p>\n<p>例子：</p>\n<p>ls *.png 列出所有 PNG 图片</p>\n<p>ls a?    列出首字母是 a, 文件名只有两个字符的所有文件</p>\n<p>ls [abc]* 列出首字母是 a、b、c 的所有文件</p>\n<h2 id=\"别名\"><a class=\"anchor\" href=\"#别名\">#</a> 别名</h2>\n<p>格式： alinas 【别名 =‘标准 Shell 命令行’】<br />\n功能：查看和设置别名</p>\n<p>不加参数时查看别名。</p>\n<h2 id=\"去除特殊符号的意义\"><a class=\"anchor\" href=\"#去除特殊符号的意义\">#</a> 去除特殊符号的意义</h2>\n<p>Linux 系统中有许多符号具有特殊的含义。如！表示去历史记录，$ 表示取变量的值，`` 反引号表示取命令的执行结果，等等。</p>\n<p>三种方法可以去除特殊符号的意义</p>\n<ol>\n<li>反斜杠 \\</li>\n<li>单引号 ('') 使任何特殊字符都不转义，原样输出。</li>\n<li>双引号 (&quot;&quot;) 只有以下四种情况下会转义：<br />\n$(美元符号)-- 取变量的值；<br />\n``(反引号)-- 命令替换；<br />\n\\(反斜杠)-- 单个字符禁止（转义）；<br />\n!(感叹号)-- 历史命令替换。</li>\n</ol>\n<h2 id=\"重定向\"><a class=\"anchor\" href=\"#重定向\">#</a> 重定向</h2>\n<p>Linux 系统中通常利用键盘输入数据，命令执行结果输出到屏幕上。也就是说 Linux 的默认标准输入时键盘，默认标准输出和标准错误输出都是屏幕。<br />\nShell 中，不使用系统默认的输入输出端口，而是重新指定至文件的情况称为重定向。</p>\n<h3 id=\"输出重定向\"><a class=\"anchor\" href=\"#输出重定向\">#</a> 输出重定向</h3>\n<p>输出重定向就是命令的执行结果不显示在标准输出（屏幕）上，而是保存到某一文件中的操作，利用符号 “&gt;” 来显示。</p>\n<p>但命令的错误输出信息还是会显示在屏幕上，正确输出会在文件中。</p>\n<h3 id=\"附加输出重定向\"><a class=\"anchor\" href=\"#附加输出重定向\">#</a> 附加输出重定向</h3>\n<p>与输出重定向相比附加重定向将内容追加到原有内容之后，不会覆盖原内容。利用符号 “&gt;&gt;” 来实现。</p>\n<h3 id=\"错误输出重定向\"><a class=\"anchor\" href=\"#错误输出重定向\">#</a> 错误输出重定向</h3>\n<p>Shell 中的标准输出与错误输出是两个独立的操作。错误输出也可以进行重定向。利用符号 “2&gt;” 来实现。</p>\n<h3 id=\"组合输出重定向\"><a class=\"anchor\" href=\"#组合输出重定向\">#</a> 组合输出重定向</h3>\n<p>若要将正确输出和错误输出重定向至某个文件，而屏幕上不显示任何内容，则可以利用符号 “&amp;&gt;” 来实现组合输出重定向功能。</p>\n<h3 id=\"输入重定向\"><a class=\"anchor\" href=\"#输入重定向\">#</a> 输入重定向</h3>\n<p>输入重定向是从某个文件读入数据，用 “&lt;” 符号来实现。由于大多数命令都已参数的形式在命令行上指定输入文件，所以并不常用。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">符号</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">command &lt;file</td>\n<td style=\"text-align:left\">将 file 文件中的内容作为 command 的输入。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">command &lt;&lt;END</td>\n<td style=\"text-align:left\">从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">command <file1 >file2</td>\n<td style=\"text-align:left\">将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"管道\"><a class=\"anchor\" href=\"#管道\">#</a> 管道</h2>\n<p>学习管道之前我们先了解一下 linux 的命令执行顺序</p>\n<h3 id=\"命令执行顺序控制\"><a class=\"anchor\" href=\"#命令执行顺序控制\">#</a> 命令执行顺序控制</h3>\n<p>通常情况下，我们在终端只能执行一条命令，然后按下回车执行，那么如何执行多条命令呢？</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>顺序执行多条命令：command1<span class=\"token punctuation\">;</span>command2<span class=\"token punctuation\">;</span>command3<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>简单的顺序指令可以通过 <span class=\"token punctuation\">;</span>来实现</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>有条件的执行多条命令：which command1 <span class=\"token operator\">&amp;&amp;</span> command2 <span class=\"token operator\">||</span> command3 <span class=\"token comment\">## which 命令用于查找文件。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">:</span> 如果前一条命令执行成功则执行下一条命令，如果command1执行成功（返回0）,则执行command2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">||</span> :与<span class=\"token operator\">&amp;&amp;</span>命令相反，执行不成功时执行这个命令</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token variable\">$?</span><span class=\"token builtin class-name\">:</span> 存储上一次命令的返回结果</pre></td></tr></table></figure><h3 id=\"管道命令\"><a class=\"anchor\" href=\"#管道命令\">#</a> 管道命令</h3>\n<blockquote>\n<p>管道是一种通信机制，通常用于进程间的通信（也可通过 socket 进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。</p>\n</blockquote>\n<p>管道命令使用 | 作为界定符号，管道命令与上面说的连续执行命令不一样。</p>\n<p>管道命令仅能处理 standard output, 对于 standard error output 会予以忽略。</p>\n<p><code>less,more,head,tail...都是可以接受standard input的命令，所以他们是管道命令</code> <br />\n <code>ls,cp,mv并不会接受standard input的命令，所以他们就不是管道命令了。</code></p>\n<p>管道命令必须要能够接受来自前一个命令的数据成为 standard input 继续处理才行。</p>\n<p>第一个管道命令<br />\n <code>$ ls -al /etc | less</code></p>\n<p>通过管道将 ls -al 的输出作为 下一个命令 less 的输入，方便浏览。</p>\n<h2 id=\"文本处理工具\"><a class=\"anchor\" href=\"#文本处理工具\">#</a> 文本处理工具</h2>\n<h3 id=\"提取文本\"><a class=\"anchor\" href=\"#提取文本\">#</a> 提取文本</h3>\n<h4 id=\"查看文件内容\"><a class=\"anchor\" href=\"#查看文件内容\">#</a> 查看文件内容</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>格式：cat 【选项】 文件列表</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>功能：显示文本文件内容</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>选项说明：-n  表示在每一行前面显示行号。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">more</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>格式：more 文件</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>功能： 分屏显示文本文件的内容。</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>只能向后翻阅</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">less</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>与more命令非常相似，也能分屏显示文本文件的内容。用户可以用上下箭头、Enter键、Space键前后翻阅文本内容。使用Q键退出命令。</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>less比more命令更方便。</pre></td></tr></table></figure><h4 id=\"产看文件摘录\"><a class=\"anchor\" href=\"#产看文件摘录\">#</a> 产看文件摘录</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">head</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>格式：head 【选项】 文件</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>功能：显示文本文件的开头部分，默认显示文件的前十行</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>主要选项说明： <span class=\"token string\">'-n 数字'</span> 表示指定显示的行数</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">tail</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>与head命令非常相似，用于显示文件的结尾部分，默认显示最后10行，也可以用<span class=\"token string\">'-n 数字'</span>选项</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>还可以用<span class=\"token string\">'-f'</span>选项表示跟进文件后续增加，通常用于监控日志文件，便于网络服务的排错处理。</pre></td></tr></table></figure><h4 id=\"按关键字提取文本\"><a class=\"anchor\" href=\"#按关键字提取文本\">#</a> 按关键字提取文本</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">grep</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>按照关键字进行文本的提取及过滤出含有某个关键字的行。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>grep命令通常与管道配合使用，通常的选项及含义如下：</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-i 忽略大小写</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-n 行号显示</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>-v 取反<span class=\"token punctuation\">(</span>相对的结果<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>^  以……开头</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>$  以……结尾</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>-r 以递归方式搜索目录</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>-AX 包括每个匹配项的后X行</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>-BX 包括每个匹配项的前X行</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>--color 以颜色突出显示匹配项</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>-w 精确匹配某个单词</pre></td></tr></table></figure><p><img data-src=\"image010.png\" alt=\"\" /></p>\n<p>正则匹配模式</p>\n<p><img data-src=\"image011.png\" alt=\"\" /></p>\n<p>实例<br />\n<img data-src=\"image012.png\" alt=\"\" /></p>\n<h4 id=\"按列或字段提取文本\"><a class=\"anchor\" href=\"#按列或字段提取文本\">#</a> 按列或字段提取文本</h4>\n<p>按列或字段提取文本的命令常用的包括 cut 和 awk，通常与管道配合使用。</p>\n<ol>\n<li>cut<br />\n 格式：cut -d 字符 -f 数字 file<br />\n 功能：提取文件 file 中以某字符未分割符的某列（或某字段）。其中 - d 后面的字符表示分隔符，-f 后面的数字表示提取的列数。</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/passwd | cut -d : -f 1,3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root:0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bin:1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>daemon:2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>adm:3</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>lp:4</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>sync:5</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>shutdown:6</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>halt:7</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>mail:8</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>operator:11</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>games:12</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>ftp:14</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>【略】</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>显示文件/etc/passwd中以‘:’作为分隔符的第一列和第三列</pre></td></tr></table></figure><p>cut 命令还可以接 - c 选项，表示义字符个数截取。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/passwd | cut -c 1-3</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>roo</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bin</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>dae</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>adm</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>lp:</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>syn</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>shu</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>【略】</pre></td></tr></table></figure><p>表示截取 /etc/passwd 文件中的第 1~3 个字符</p>\n<ol start=\"2\">\n<li>awk<br />\nawk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 Linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk 将会使你的工作变的高大上。awk 是三剑客的老大，利剑出鞘，必会不同凡响。</li>\n</ol>\n<p>简单来说，awk 是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>\n<p>awk '{pattern + action}' {filename}<br />\n 其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。<br />\nfilename 的 {} 实际是不用写的。<br />\nawk 语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk 抽取信息后，才能进行其他文本操作。完整的 awk 脚本通常用来格式化文本文件中的信息。<br />\n通常，awk 是以文件的一行为处理单位的。awk 每接收文件的一行，然后执行相应的命令，来处理文本。</p>\n<p>awk [选项]' 脚本命令文件名</p>\n<p>常用选项:</p>\n<p>-F 指定输入分隔符，默认分割符是空格，如 - F:<br />\n-f file 从脚本文件中读取 awk 脚本指令</p>\n<p>以：为分隔符，显示第 1 和 5 列<br />\n awk -F : '{printf $1,$5}' /etc/passwd</p>\n<p>awk 内置变量:</p>\n<p>FILENAME 文件名<br />\n FNR  浏览文件的记录数<br />\n NF  浏览记录的域的个数 (列数)<br />\n NR  已读的记录数 (行数)<br />\n$n  $0 变量是指整条记录。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext>表示当前行的第一域</mtext><mo stretchy=\"false\">(</mo><mtext>列</mtext><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mtext>以此类推</mtext></mrow><annotation encoding=\"application/x-tex\">1表示当前行的第一域(列) ..以此类推\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord cjk_fallback\">当</span><span class=\"mord cjk_fallback\">前</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">域</span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">列</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">此</span><span class=\"mord cjk_fallback\">类</span><span class=\"mord cjk_fallback\">推</span></span></span></span>NF  表示最后一列的信息</p>\n<p>案例<br />\n<img data-src=\"image015.png\" alt=\"\" /></p>\n<h3 id=\"分析文本\"><a class=\"anchor\" href=\"#分析文本\">#</a> 分析文本</h3>\n<h4 id=\"统计文本信息\"><a class=\"anchor\" href=\"#统计文本信息\">#</a> 统计文本信息</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wc</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>格式：wc 【选项】 文件</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>功能：显示文本文件的行数、字数和字符数</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>主要选项说明：</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-c      仅显示问价的字节数</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>-l      仅显示问价的行数</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>-w      仅显示文件的单词数</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># wc /etc/passwd</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token number\">44</span>  <span class=\"token number\">88</span>  <span class=\"token number\">2302</span>   /etc/passwd</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>wc命令依次显示文件的行数、单词数、字节数及文件名。</pre></td></tr></table></figure><h4 id=\"排序命令\"><a class=\"anchor\" href=\"#排序命令\">#</a> 排序命令</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sort</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sort</span> <span class=\"token punctuation\">[</span>-fbMnrtuk<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>file or stdin<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>参数<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-f ：忽略大小写的差异，例如A 与a 视为编码相同</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>-b ：忽略最前面的空格部分</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>-n ：使用『纯数字』进行排序默认是以文字型态来排序的<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>-r ：反向排序</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>-u ：就是uniq ，相同的资料中，仅出现一行代表</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>-t ：分隔符号，预设是用<span class=\"token punctuation\">[</span>tab<span class=\"token punctuation\">]</span> 键来分隔</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>-k ：以那个区间<span class=\"token punctuation\">(</span>field<span class=\"token punctuation\">)</span> 来进行排序的意思</pre></td></tr></table></figure><h3 id=\"处理文本\"><a class=\"anchor\" href=\"#处理文本\">#</a> 处理文本</h3>\n<h4 id=\"转换字符\"><a class=\"anchor\" href=\"#转换字符\">#</a> 转换字符</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">tr</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Linux <span class=\"token function\">tr</span> 命令用于转换或删除文件中的字符。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">tr</span> 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>语法</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">tr</span> <span class=\"token punctuation\">[</span>-cdst<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>--help<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>--version<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>第一字符集<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>第二字符集<span class=\"token punctuation\">]</span>  </pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">tr</span> <span class=\"token punctuation\">[</span>OPTION<span class=\"token punctuation\">]</span>…SET1<span class=\"token punctuation\">[</span>SET2<span class=\"token punctuation\">]</span> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>参数说明：</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>-c, --complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>-d, --delete：删除指令字符</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>-s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>-t, --truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>--help：显示程序用法信息</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>--version：显示程序本身的版本信息</pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>字符集合的范围：</pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">\\</span>NNN 八进制值的字符 NNN <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> to <span class=\"token number\">3</span> 为八进制值的字符<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">\\</span><span class=\"token punctuation\">\\</span> 反斜杠</pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">\\</span>a Ctrl-G 铃声</pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">\\</span>b Ctrl-H 退格符</pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">\\</span>f Ctrl-L 走行换页</pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">\\</span>n Ctrl-J 新行</pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">\\</span>r Ctrl-M 回车</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">\\</span>t Ctrl-I tab键</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">\\</span>v Ctrl-X 水平制表符</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。</pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">[</span>CHAR*<span class=\"token punctuation\">]</span> ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">[</span>CHAR*REPEAT<span class=\"token punctuation\">]</span> ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止<span class=\"token punctuation\">(</span>REPEAT 的数字采 <span class=\"token number\">8</span> 进位制计算，以 <span class=\"token number\">0</span> 为开始<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">[</span>:alnum:<span class=\"token punctuation\">]</span> ：所有字母字符与数字</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">[</span>:alpha:<span class=\"token punctuation\">]</span> ：所有字母字符</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">[</span>:blank:<span class=\"token punctuation\">]</span> ：所有水平空格</pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">[</span>:cntrl:<span class=\"token punctuation\">]</span> ：所有控制字符</pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">[</span>:digit:<span class=\"token punctuation\">]</span> ：所有数字</pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token punctuation\">[</span>:graph:<span class=\"token punctuation\">]</span> ：所有可打印的字符<span class=\"token punctuation\">(</span>不包含空格符<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token punctuation\">[</span>:lower:<span class=\"token punctuation\">]</span> ：所有小写字母</pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">[</span>:print:<span class=\"token punctuation\">]</span> ：所有可打印的字符<span class=\"token punctuation\">(</span>包含空格符<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">[</span>:punct:<span class=\"token punctuation\">]</span> ：所有标点字符</pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token punctuation\">[</span>:space:<span class=\"token punctuation\">]</span> ：所有水平与垂直空格符</pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token punctuation\">[</span>:upper:<span class=\"token punctuation\">]</span> ：所有大写字母</pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token punctuation\">[</span>:xdigit:<span class=\"token punctuation\">]</span> ：所有 <span class=\"token number\">16</span> 进位制的数字</pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>CHAR<span class=\"token operator\">=</span><span class=\"token punctuation\">]</span> ：所有符合指定的字符<span class=\"token punctuation\">(</span>等号里的 CHAR，代表你可自订的字符<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>将文件testfile中的小写字母全部转换成大写字母，此时，可使用如下命令：</pre></td></tr><tr><td data-num=\"47\"></td><td><pre></pre></td></tr><tr><td data-num=\"48\"></td><td><pre><span class=\"token function\">cat</span> testfile <span class=\"token operator\">|</span><span class=\"token function\">tr</span> a-z A-Z </pre></td></tr><tr><td data-num=\"49\"></td><td><pre>testfile文件中的内容如下：</pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>$ <span class=\"token function\">cat</span> testfile         <span class=\"token comment\">#testfile 原来的内容  </span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>Linux networks are becoming <span class=\"token function\">more</span> and <span class=\"token function\">more</span> common, </pre></td></tr><tr><td data-num=\"53\"></td><td><pre>but scurity is often an overlooked  </pre></td></tr><tr><td data-num=\"54\"></td><td><pre>issue. Unfortunately, <span class=\"token keyword\">in</span> today’s environment all networks </pre></td></tr><tr><td data-num=\"55\"></td><td><pre>are potential hacker targets,  </pre></td></tr><tr><td data-num=\"56\"></td><td><pre>fro0m tp-secret military research networks to small home LANs.  </pre></td></tr><tr><td data-num=\"57\"></td><td><pre>Linux Network Securty focuses on securing Linux <span class=\"token keyword\">in</span> a </pre></td></tr><tr><td data-num=\"58\"></td><td><pre>networked environment, where the  </pre></td></tr><tr><td data-num=\"59\"></td><td><pre>security of the entire network needs to be considered</pre></td></tr><tr><td data-num=\"60\"></td><td><pre>rather than just isolated machines.  </pre></td></tr><tr><td data-num=\"61\"></td><td><pre>It uses a mix of theory and practicl techniques to </pre></td></tr><tr><td data-num=\"62\"></td><td><pre>teach administrators how to <span class=\"token function\">install</span> and  </pre></td></tr><tr><td data-num=\"63\"></td><td><pre>use security applications, as well as how the </pre></td></tr><tr><td data-num=\"64\"></td><td><pre>applcations work and why they are necesary. </pre></td></tr><tr><td data-num=\"65\"></td><td><pre>使用 <span class=\"token function\">tr</span> 命令大小写转换后，得到如下输出结果：</pre></td></tr><tr><td data-num=\"66\"></td><td><pre></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>$ <span class=\"token function\">cat</span> testfile <span class=\"token operator\">|</span> <span class=\"token function\">tr</span> a-z A-Z <span class=\"token comment\">#转换后的输出  </span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>LINUX NETWORKS ARE BECOMING MORE AND MORE COMMON, BUT SCURITY IS OFTEN AN OVERLOOKED  </pre></td></tr><tr><td data-num=\"69\"></td><td><pre>ISSUE. UNFORTUNATELY, IN TODAY’S ENVIRONMENT ALL NETWORKS ARE POTENTIAL HACKER TARGETS,  </pre></td></tr><tr><td data-num=\"70\"></td><td><pre>FROM TP-SECRET MILITARY RESEARCH NETWORKS TO SMALL <span class=\"token environment constant\">HOME</span> LANS.  </pre></td></tr><tr><td data-num=\"71\"></td><td><pre>LINUX NETWORK SECURTY FOCUSES ON SECURING LINUX IN A NETWORKED ENVIRONMENT, WHERE THE  </pre></td></tr><tr><td data-num=\"72\"></td><td><pre>SECURITY OF THE ENTIRE NETWORK NEEDS TO BE CONSIDERED RATHER THAN JUST ISOLATED MACHINES.  </pre></td></tr><tr><td data-num=\"73\"></td><td><pre>IT USES A MIX OF THEORY AND PRACTICL TECHNIQUES TO TEACH ADMINISTRATORS HOW TO INSTALL AND  </pre></td></tr><tr><td data-num=\"74\"></td><td><pre>USE SECURITY APPLICATIONS, AS WELL AS HOW THE APPLCATIONS WORK AND WHY THEY ARE NECESARY. </pre></td></tr><tr><td data-num=\"75\"></td><td><pre>大小写转换，也可以通过<span class=\"token punctuation\">[</span>:lower<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>:upper<span class=\"token punctuation\">]</span>参数来实现。例如使用如下命令：</pre></td></tr><tr><td data-num=\"76\"></td><td><pre></pre></td></tr><tr><td data-num=\"77\"></td><td><pre><span class=\"token function\">cat</span> testfile <span class=\"token operator\">|</span><span class=\"token function\">tr</span> <span class=\"token punctuation\">[</span>:lower:<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>:upper:<span class=\"token punctuation\">]</span> </pre></td></tr><tr><td data-num=\"78\"></td><td><pre>输出结果如下：</pre></td></tr><tr><td data-num=\"79\"></td><td><pre></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>$ <span class=\"token function\">cat</span> testfile <span class=\"token operator\">|</span> <span class=\"token function\">tr</span> <span class=\"token punctuation\">[</span>:lower:<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>:upper:<span class=\"token punctuation\">]</span> <span class=\"token comment\">#转换后的输出  </span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>LINUX NETWORKS ARE BECOMING MORE AND MORE COMMON, BUT SCURITY IS OFTEN AN OVERLOOKED  </pre></td></tr><tr><td data-num=\"82\"></td><td><pre>ISSUE. UNFORTUNATELY, IN TODAY’S ENVIRONMENT ALL NETWORKS ARE POTENTIAL HACKER TARGETS,  </pre></td></tr><tr><td data-num=\"83\"></td><td><pre>FROM TP-SECRET MILITARY RESEARCH NETWORKS TO SMALL <span class=\"token environment constant\">HOME</span> LANS.  </pre></td></tr><tr><td data-num=\"84\"></td><td><pre>LINUX NETWORK SECURTY FOCUSES ON SECURING LINUX IN A NETWORKED ENVIRONMENT, WHERE THE  </pre></td></tr><tr><td data-num=\"85\"></td><td><pre>SECURITY OF THE ENTIRE NETWORK NEEDS TO BE CONSIDERED RATHER THAN JUST ISOLATED MACHINES.  </pre></td></tr><tr><td data-num=\"86\"></td><td><pre>IT USES A MIX OF THEORY AND PRACTICL TECHNIQUES TO TEACH ADMINISTRATORS HOW TO INSTALL AND  </pre></td></tr><tr><td data-num=\"87\"></td><td><pre>USE SECURITY APPLICATIONS, AS WELL AS HOW THE APPLCATIONS WORK AND WHY THEY ARE NECESARY.</pre></td></tr></table></figure><h4 id=\"查找替换\"><a class=\"anchor\" href=\"#查找替换\">#</a> 查找替换</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sed</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>stream editor的缩写，用于对文本流进行查找替换操作，不改变源文件。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Linux <span class=\"token function\">sed</span> 命令是利用脚本来处理文本文件。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">sed</span> 可依照脚本的指令来处理、编辑文本文件。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>语法</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">sed</span> <span class=\"token punctuation\">[</span>-hnV<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>-e<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>-f<span class=\"token operator\">&lt;</span>script文件<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>文本文件<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>参数说明：</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>-e<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>或--expression<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span> 以选项中指定的script来处理输入的文本文件。</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>-f<span class=\"token operator\">&lt;</span>script文件<span class=\"token operator\">></span>或--file<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>script文件<span class=\"token operator\">></span> 以选项中指定的script文件来处理输入的文本文件。</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>-h或--help 显示帮助。</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>-n或--quiet或--silent 仅显示script处理后的结果。</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>-V或--version 显示版本信息。</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>动作说明：</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现<span class=\"token punctuation\">(</span>目前的下一行<span class=\"token punctuation\">)</span>～</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现<span class=\"token punctuation\">(</span>目前的上一行<span class=\"token punctuation\">)</span>；</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 <span class=\"token function\">sed</span> -n 一起运行～</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 <span class=\"token number\">1</span>,20s/old/new/g 就是啦！</pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令：</pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token function\">sed</span> -e 4a<span class=\"token punctuation\">\\</span>newLine testfile </pre></td></tr><tr><td data-num=\"33\"></td><td><pre>首先查看testfile中的内容如下：</pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>$ <span class=\"token function\">cat</span> testfile <span class=\"token comment\">#查看 testfile 中的内容  </span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>HELLO LINUX<span class=\"token operator\">!</span>  </pre></td></tr><tr><td data-num=\"37\"></td><td><pre>Linux is a <span class=\"token function\">free</span> unix-type opterating system.  </pre></td></tr><tr><td data-num=\"38\"></td><td><pre>This is a linux testfile<span class=\"token operator\">!</span>  </pre></td></tr><tr><td data-num=\"39\"></td><td><pre>Linux <span class=\"token builtin class-name\">test</span> </pre></td></tr><tr><td data-num=\"40\"></td><td><pre>使用sed命令后，输出结果如下：</pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>$ <span class=\"token function\">sed</span> -e 4a<span class=\"token punctuation\">\\</span>newline testfile <span class=\"token comment\">#使用 sed 在第四行后添加新字符串  </span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>HELLO LINUX<span class=\"token operator\">!</span> <span class=\"token comment\">#testfile 文件原有的内容  </span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>Linux is a <span class=\"token function\">free</span> unix-type opterating system.  </pre></td></tr><tr><td data-num=\"45\"></td><td><pre>This is a linux testfile<span class=\"token operator\">!</span>  </pre></td></tr><tr><td data-num=\"46\"></td><td><pre>Linux <span class=\"token builtin class-name\">test</span>  </pre></td></tr><tr><td data-num=\"47\"></td><td><pre>newline</pre></td></tr></table></figure><p><img data-src=\"image013.png\" alt=\"\" /><br />\n<img data-src=\"image014.png\" alt=\"\" /></p>\n<h2 id=\"linux中的shell如何切换\"><a class=\"anchor\" href=\"#linux中的shell如何切换\">#</a> Linux 中的 shell 如何切换</h2>\n<p>转载自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plcnJ5XzExMjYvYXJ0aWNsZS9kZXRhaWxzLzg1MjI0NzM3\"> https://blog.csdn.net/jerry_1126/article/details/85224737</span></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>方法一: chsh -s /bin/ksh</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># chsh -s /bin/ksh           # 修改用户默认的 shell 为 ksh</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Changing shell <span class=\"token keyword\">for</span> root.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Shell not changed.</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># egrep 'root' /etc/passwd   # 查看修改是否成功，按 CTRL+D 退出下次生效</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>root:x:0:0:root:/root:/bin/ksh </pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>方法二: <span class=\"token function\">usermod</span> -s /bin/ksh root</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># usermod -s /bin/ksh root</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>其他命令或者相互操作:</pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>查看当前使用的shell</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># echo $SHELL</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>/bin/bash</pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\"># 或者</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># egrep 'root' /etc/passwd</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>root:x:0:0:root:/root:/bin/bash </pre></td></tr><tr><td data-num=\"24\"></td><td><pre>查看所有可用的shell</pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/shells</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>/bin/sh</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>/bin/bash</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>/bin/ksh</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>/bin/zsh</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>/bin/csh</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre> </pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\"># 或者</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre> </pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">[</span>root@host ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># chsh -l</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>/bin/sh</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>/bin/bash</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>/bin/ksh</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>/bin/zsh</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>/bin/csh</pre></td></tr></table></figure><h2 id=\"vi编辑器\"><a class=\"anchor\" href=\"#vi编辑器\">#</a> vi 编辑器</h2>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<h1 id=\"用户-组和权限\"><a class=\"anchor\" href=\"#用户-组和权限\">#</a> 用户、组和权限</h1>\n<p>转载自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhvbmdndWl5YW8vcC85MTY1OTE3Lmh0bWw=\"> https://www.cnblogs.com/zhongguiyao/p/9165917.html</span> 超级详细</p>\n<p>Linux 系统是一个多用户操作系统，从本机或远程登录的多个用户能共同使用同一计算机，同时访问同一设备。<br />\nLinux 系统进行用户和组管理的目的在于保证系统中数据与文件的安全。</p>\n<h2 id=\"用户账户管理\"><a class=\"anchor\" href=\"#用户账户管理\">#</a> 用户账户管理</h2>\n<p>Linux/Unix 是一个用户、多任务的操作系统；在讲 Linux 账号及账户组管理之前，先简单了解一下多用户、多任务操作系统的基本概念。</p>\n<h3 id=\"linux的单用户多任务\"><a class=\"anchor\" href=\"#linux的单用户多任务\">#</a> Linux 的单用户多任务</h3>\n<p>在 Linux 下，当你登录后，你也可以同时开启很多的服务任务和进程，而各自服务都会跑的很好却对其他任务没有任何影响，这种登录一个用户登录系统执行多个服务任务和进程的情况，就称为单用户多任务。</p>\n<h3 id=\"linux的多用户多任务\"><a class=\"anchor\" href=\"#linux的多用户多任务\">#</a> Linux 的多用户多任务</h3>\n<p>有时可能是很多用户同时用同一个系统，如公司几十个运维人员，每台机器都可以和被若干个运维人员登录部署或解决相关故障问题，但并不是所有的运维人员都要做同一件事，所以就有了多任务、多用户的情况。</p>\n<p>值得注意的是：多用户、多任务并不是大家同时挤到一起，在一台机器的键盘和显示器前来操作机器，多用户可能是通过 SSH 客户端工具等远程工具等远程登录服务器来进行，比如对服务器的运程控制，只要具有相关用户的权限，任何人都是可以上去操作访问服务器。</p>\n<h2 id=\"linux系统用户角色划分\"><a class=\"anchor\" href=\"#linux系统用户角色划分\">#</a> linux 系统用户角色划分</h2>\n<p>用户在系统中是分角色的，在 Linux 系统中，由于角色的不同，权限和所完成的任务也不同；值得注意的是用户的角色是通过 UID 和 GID 识别的；特别是 UID，在运维工作中，一个 UID 是唯一标识一个系统用户的账号。</p>\n<p>用户账户：</p>\n<p>超级用户 root（0）<br />\n程序用户（1~499）<br />\n普通用户（500~65535）</p>\n<p>超级用户：</p>\n<pre><code>默认是root用户，其UID和GID均为0。在每台unix/linux操作系统中都是唯一且真实存在的，通过它可以登录系统，可以操作系统中任何文件\n和命令，\n拥有最高的管理权限。在生产环境，一般禁止root账号远程登录SSH连接服务器，以加强系统安全。\n</code></pre>\n<p>普通用户：</p>\n<pre><code>这类用户一般是由具备系统管理员root的权限的运维人员添加的。\n</code></pre>\n<p>程序用户：</p>\n<pre><code>与真实用户区分开来，这类用户的最大特点是安装系统后默认就会存在的，且默认情况不能登录系统，它们是系统正常运行\n必不可少的，他们的存在主要是方便系统管理，满足相应的系统进程都文件属主的要求。例如系统默认的bin、adm、nodoby、mail用户等。\n由于服务器角色的不同，有部分用不到的系统服务被禁止开机执行，因此，在做系统安全优化时，被禁止开机启动了的服务对应的虚拟用户\n也是可以处理掉的(删除或注释)。\n</code></pre>\n<h2 id=\"用户及用户组配置文件介绍\"><a class=\"anchor\" href=\"#用户及用户组配置文件介绍\">#</a> 用户及用户组配置文件介绍</h2>\n<p>Linux 系统中下的账户文件主要有 /etc/passwd、/etc/shadow、/etc/group、/etc/gshadow 四个文件。</p>\n<h3 id=\"与用户相关的配置文件\"><a class=\"anchor\" href=\"#与用户相关的配置文件\">#</a> 与用户相关的配置文件</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>/etc/passwd:  <span class=\"token comment\">#用户的配置文件， 保存用户账户的基本信息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>/etc/shadow  <span class=\"token comment\">#用户影子口令文件</span></pre></td></tr></table></figure><p>用户的配置文件 /etc/passwd<br />\n/etc/passwd 文件中每行定义一个用户账号，有多少行就表示多少个账号，在一行中可以清晰的看出，各内容之间又通过”:” 号划分了 7 个字段，这 7 个字段分别定义了账号的不同属性，passwd 文件实际内容如下:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head -5 /etc/passwd</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root:x:0:0:root:/root:/bin/bash</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bin:x:1:1:bin:/bin:/sbin/nologin</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>daemon:x:2:2:daemon:/sbin:/sbin/nologin</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>adm:x:3:4:adm:/var/adm:/sbin/nologin</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</pre></td></tr></table></figure><p>在 passwd 文件中，第一行内容就是超级用户 root 行，可以看到它的 uid 和 gid 都为 0. 为了方便理解，下面是各字段的描述：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>字段1：帐号名，这是用户登陆时使用的账户名称，在系统中是唯一的，不能重名</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>字段2：密码占位符x；早期的unix系统中，该字段是存放账户和密码的，由于安全原因，后来把这个密码字段内容移到/etc/shadow中了。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>　　　　　　这里可以看到一个字母x，表示该用户的密码是/etc/shadow文件中保护的。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>字段3：<span class=\"token environment constant\">UID</span>；范围是0-65535</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>字段4：GID；范围是0-65535；当添加用户时，默认情况下会同时建立一个与用户同名且<span class=\"token environment constant\">UID</span>和GID相同的组。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>字段5：用户说明；这个字段是对这个账户的说明</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>字段6：宿主目录；用户登陆后首先进入的目录，一般与<span class=\"token string\">\"/home/用户名\"</span>这样的目录</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>字段7：登录Shell   当前用户登陆后所使用的shell，在centos/rhel系统中，默认的shell是bash；如果不希望用户登陆系统，可以通过usermod</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>　　　　　　或者手动修改passwd设置，将该字段设置为/sbin/nologin 即可。大多数内置系统账户都是/sbin/nologin,这表示禁止登陆系统。</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>　　　　　　这是出于安全考虑的。</pre></td></tr></table></figure><h4 id=\"passwd中有关uid的限制说明\"><a class=\"anchor\" href=\"#passwd中有关uid的限制说明\">#</a> passwd 中有关 UID 的限制说明</h4>\n<p>0：当用户的 UID 为 0 时，表示这个账户为超级用户；如果要增加一个系统管理员账户的话，只需将该账户的 UID 改为 0 即可。不建议<br />\n 1~499：这个范围是保留给系统用户使用的 UID<br />\n500~65535：普通账户 UID<br />\n 最后，来看一下 /etc/passwd 的权限：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l /etc/passwd</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>-rw-r--r--. <span class=\"token number\">1</span> root root <span class=\"token number\">1665</span> <span class=\"token number\">4</span>月  <span class=\"token number\">11</span> <span class=\"token number\">14</span>:13 /etc/passwd</pre></td></tr></table></figure><p>因为每个用户登录时都需要取得 UID 和 GID 来判断权限问题，所以 /etc/passwd 的权限为 644，这样一来就会带来安全问题，即所有的用户都可以都 /etc/passwd 文件，即使文件内的密码是加密的，但还是存在一定的被攻击破解的安全隐患。因此，就有了 /etc/shadow 文件。</p>\n<h4 id=\"用户的影子口令文件etcshadow\"><a class=\"anchor\" href=\"#用户的影子口令文件etcshadow\">#</a> 用户的影子口令文件 /etc/shadow</h4>\n<p>由于 passwd 文件必须要被所有的用户读，所以会带来安全隐患。而 shadow 文件就是为了解决这个安全隐患而增加的。</p>\n<p>来看一下 /etc/shadow 的权限：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l /etc/shadow</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>----------. <span class=\"token number\">1</span> root root <span class=\"token number\">1059</span> <span class=\"token number\">4</span>月  <span class=\"token number\">11</span> <span class=\"token number\">14</span>:13 /etc/shadow</pre></td></tr></table></figure><p>其文件内容为：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head -5 /etc/shadow</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root:<span class=\"token variable\">$6</span><span class=\"token variable\">$jmM2rFzPCFbmqBkf</span><span class=\"token variable\">$oz3AUooR3qaV5uXU67HcXlYiE3hNf0sSsunk1eBTDPrGUOM1xYCyesGoj</span>.ZLTIzdiXEdrnnqNyC5g8SsRnxQm.:16338:0:99999:7:::</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bin:*:15615:0:99999:7:::</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>daemon:*:15615:0:99999:7:::</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>adm:*:15615:0:99999:7:::</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>lp:*:15615:0:99999:7:::</pre></td></tr></table></figure><p>和 /etc/passwd 一样，shadow 文件的每一行内容，也是以冒号 (:) 作为分隔符，共 9 个字段，其各个字段的意义如下表：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>字段1：帐号名称</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>字段2：加密的密码</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>字段3：最近更改密码的时间；从1970/1/1到上次修改密码的天数</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>字段4：禁止修改密码的天数；从1970/1/1开始，多少天之内不能修改密码，默认值为0</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>字段5：用户必须更改口令的天数；密码的最长有效天数，默认值为99999</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>字段6：警告更改密码的期限；密码过期之前警告天数，默认值为7；在用户密码过期前多少天提醒用户更改密码</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>字段7：不活动时间；密码过期之后账户宽限时间 <span class=\"token number\">3</span>+5；在用户密码过期之后到禁用账户的天数</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>字段8：帐号失效时间，默认值为空；从1970/1/1日起，到用户被禁用的天数</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>字段9：保留字段（未使用），标志</pre></td></tr></table></figure><p>密码过期：一旦超过密码过期日期，用户成功登陆，Linux 会强迫用户设置一个新密码，设置完成后才开启 Shell 程序<br />\n账户过期：若超过账户过期日期，Linux 会禁止用户登陆系统，即使输入正确密码，也无法登陆</p>\n<h3 id=\"与用户组相关的配置文件\"><a class=\"anchor\" href=\"#与用户组相关的配置文件\">#</a> 与用户组相关的配置文件</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>/etc/group  <span class=\"token comment\">#用户组配置文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>/etc/gshadow  <span class=\"token comment\">#用户组的影子文件</span></pre></td></tr></table></figure><h4 id=\"用户组配置文件etcgroup\"><a class=\"anchor\" href=\"#用户组配置文件etcgroup\">#</a> 用户组配置文件 /etc/group</h4>\n<p>/etc/group 文件是用户组的配置文件，内容包括用户与用户组，并且能显示用户归属哪个用户组，因为一个用户可以归属一个或多个不同的用户组；同一用户组的用户之间具有相似的特性。如果某个用户下有对系统管理有最重要的内容，最好让用户拥有独立的用户组，或者是把用户下的文件的权限设置为完全私有；另外 root 用户组一般不要轻易把普通用户加入进入。</p>\n<p>/etc/group 文件就是记录 GID 与用户组的文件。/etc/group 文件同 /etc/passwd 类似，其文件权限也是 644：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l /etc/group</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>-rw-r--r--. <span class=\"token number\">1</span> root root <span class=\"token number\">832</span> <span class=\"token number\">4</span>月  <span class=\"token number\">11</span> <span class=\"token number\">14</span>:13 /etc/group</pre></td></tr></table></figure><p>/etc/group 的文件内容为：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head -5 /etc/group</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>root:x:0:</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bin:x:1:bin,daemon</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>daemon:x:2:bin,daemon</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>sys:x:3:bin,adm</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>adm:x:4:adm,daemon</pre></td></tr></table></figure><p>group 文件各个字段的详细说明：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>字段1：组账户名称</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>字段2：密码占位符x；通常不需要设置该密码，由于安全原因，该密码被记录在/etc/gshadow中，因此显示为<span class=\"token string\">'x'</span>。这类似/etc/shadow</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>字段3：组账户GID号,用户组ID</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>字段4：本组的成员用户列表；加入这个组的所有用户账号</pre></td></tr></table></figure><h4 id=\"用户组的影子文件etcgshadow\"><a class=\"anchor\" href=\"#用户组的影子文件etcgshadow\">#</a> 用户组的影子文件 /etc/gshadow</h4>\n<p>/etc/gshaow 是 /etc/group 的加密文件，比如用户组的管理密码就是存放在这个文件。/etc/group 和 /etc/gshadow 是互补的两个文件；比如大型服务器，针对很多用户和用户组，定制一些关系结构比较复杂的额权限模型，设置用户组密码是极有必要的。比如不想让一些非用户组成员永久拥有用户组的权限和特性，这时就可以通过密码验证的方式来让某些用户临时拥有一些用户组特性，这时就要用到用户组密码；/etc/gshadow 格式如下，每个用户组独占一行；</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l /etc/gshadow</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>----------. <span class=\"token number\">1</span> root root <span class=\"token number\">682</span> <span class=\"token number\">4</span>月  <span class=\"token number\">11</span> <span class=\"token number\">14</span>:13 /etc/gshadow</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@Web ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head -5 /etc/gshadow</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>root:::</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>bin:::bin,daemon</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>daemon:::bin,daemon</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>sys:::bin,adm</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>adm:::adm,daemon</pre></td></tr></table></figure><p>gshadow 文件中各个字段详细说明：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>字段1：组账号的名称</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>字段2：加密后的密码字符串，这个字段可以空的或者<span class=\"token operator\">!</span>；如果是空的或有！，表示没有密码</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>字段3：本组的管理员列表；这个字段也可为空；如果有多个用户组管理员，用,号分隔</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>字段4：本组的成员列表；加入这个组的所有用户账户；列表中多个用户通过<span class=\"token string\">\",\"</span>分隔</pre></td></tr></table></figure><h2 id=\"常用命令\"><a class=\"anchor\" href=\"#常用命令\">#</a> 常用命令</h2>\n<ol>\n<li>\n<p>su [-] username (后面可以跟 -, 也可以不跟)<br />\n 省略 username 就切换到 root 用户，需要输入 root 的密码。<br />\n当由 root 切换到普通用户时，不需要输入密码当 su 命令加上 - 后，会初始化当前用户的各种环境变量。<br />\n如果不加 - 切换到 root 用户时，当前目录没有变化；而如果加上 - 切换到 root 账户时，当前目录为 root 账户的家目录。</p>\n</li>\n<li>\n<p>sudo 命令<br />\n使用 su 切换身份需要知道 root 账号的密码，这样并不安全。为了提高安全性，我们可以使用 sudo 来执行需要 root 权限的功能。<br />\nsudo 由 root 指定，指定后用户只需输入自己账号的密码就能申请到 root 权限，而无需告诉任何人 root 密码，因此安全了不少。</p>\n</li>\n</ol>\n<p>whoami 命令和 who am i 命令是不同的 2 个命令，whoami 命令：当前执行操作的用户名 who ami 命令：打印登陆当前 Linux 系统的用户名 真实登陆的用户名</p>\n<p>登陆账号 root 使用 su 命令切换到 hello 用户执行一遍命令，就可以看到区别了。</p>\n<p><img data-src=\"image009.png\" alt=\"\" /></p>\n<p>附上思维导图<br />\n<img data-src=\"image002.png\" alt=\"\" /></p>\n<h1 id=\"文件系统\"><a class=\"anchor\" href=\"#文件系统\">#</a> 文件系统</h1>\n<h2 id=\"目录\"><a class=\"anchor\" href=\"#目录\">#</a> 目录</h2>\n<p>/: 根目录，一般根目录下只存放目录，不要存放文件<br />\n /boot: 放置 linux 系统启动时用到的一些文件<br />\n /dev: 存放 linux 系统下的设备文件<br />\n /etc: 系统配置文件存放的目录<br />\n /home: 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，～表示当前用户的家目录<br />\n /usr: 应用程序存放目录<br />\n /var: 放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log</p>\n<h2 id=\"linux文件目录详细信息\"><a class=\"anchor\" href=\"#linux文件目录详细信息\">#</a> Linux 文件目录详细信息</h2>\n<h3 id=\"文件属主和属组\"><a class=\"anchor\" href=\"#文件属主和属组\">#</a> 文件属主和属组</h3>\n<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件 (包括目录文件) 的权限做了不同的规定。<br />\n在 Linux 系统中，用户是按组分类的，一个用户属于一个或多个组。<br />\n对于文件来说，它都有一个特定的所有者，对该文件具有所有权的用户。<br />\n因此，Linux 系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>\n<p>使用命令 ll (ls -l 的缩写) 即可查看目录详细信息</p>\n<p>如图，目录详细信息介绍<br />\n<img data-src=\"image004.png\" alt=\"\" /></p>\n<p>文件类型：<br />\n<img data-src=\"image006.png\" alt=\"\" /></p>\n<p>文件权限<br />\n<img data-src=\"image007.png\" alt=\"\" /><br />\n<img data-src=\"image008.png\" alt=\"\" /></p>\n<details class=\"success\"><summary>Example(点击展开)</summary><div>\n<p>drwxr-xr-x<br />\nd: 目录<br />\n文件属主，可读可写可执行；用户组可读可执行；其他用户可读可执行。</p>\n</div></details>\n<p>硬链接：<br />\n<img data-src=\"image005.png\" alt=\"\" /></p>\n<h3 id=\"相关命令\"><a class=\"anchor\" href=\"#相关命令\">#</a> 相关命令</h3>\n<ol>\n<li>chmod: 修改文件的属性 (九个属性)</li>\n</ol>\n<p>Linux 文件属性有两种设置方法，一种是数字，一种是符号。</p>\n<p>1. 数字类型改变权限 Linux 文件的基本属性就有九个，分别是 owner/group/others 组别的 read/write/execute 属性，-rwxrwxrwx 可以使用数字来代表各个属性:<br />\nr:4<br />\nw:2<br />\nx:1<br />\n 每种身份 (owner/group/others) 各自的三个权限 (r/w/x) 分数是需要累加的，例如 a.txt 的权限为: 【-rwxrwx---】 :<br />\nowner = rwx = 4+2+1 =7<br />\ngroup =rwx =4+2+1=7<br />\nothers=---= 0+0+0 =0<br />\n 所以该文件的权限就是 770</p>\n<p>例如：设置 aaa 的文件权限 <code>chmod 777 aaa</code></p>\n<p>2. 符号类型改变权限<br />\n九个属性分别是 user,group、others<br />\n 三个群体使用 u, g, o 来代表各自，a 则代表 all 即全部<br />\n读写的属性就可以写成了 r,w,x</p>\n<p>操作符</p>\n<table>\n<tr>\n<th>Operator</th>\n<th>说明\n</th></tr>\n<tr>\n<td><tt>+</tt></td>\n<td>为指定的用户类型增加权限\n</td></tr>\n<tr>\n<td><tt>-</tt></td>\n<td>去除指定用户类型的权限\n</td></tr>\n<tr>\n<td><tt>=</tt></td>\n<td>设置指定用户权限的设置，即将用户类型的所有权限重新设置\n</td></tr></table>\n<p>分析一个文件的属性为 [-rwxr-xr-x] 时，基本上就是:<br />\nuser (u): 具有可读、可写、可执行的权限；<br />\ngroup 与 others (g/o): 具有可读与执行的权限。<br />\n使用方法:<br />\n <code>chmod u=rwx,go=rx test.txt</code></p>\n<ol start=\"2\">\n<li>chgrp: 更改文件属组</li>\n</ol>\n<p>语法:<br />\nchgrp [-R] 属组名文件名<br />\n参数选项 - R: 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 - R 的参数，那么该目录下的所有文件的属组都会更改。</p>\n<ol start=\"3\">\n<li>chown: 更改文件属主，也可以同时更改文件属组</li>\n</ol>\n<p>语法:<br />\nchown [-R] 属主名文件名<br />\n chown [-R] 属主名：属组名文件名</p>\n<ol start=\"4\">\n<li>文件默认权限</li>\n</ol>\n<p>umask 就是指定当前用户在建立文件或者目录时候的权限默认值<br />\n查看 umask 值:<br />\numask // 以数字类型显示<br />\n umask-S // 以符号类型显示</p>\n<p>umask 值默认是 022<br />\n 建立文件，最高权限是 666: -rw-w-rw-<br />\n 建立目录，最高权限是 777: drwxrwxrwx</p>\n<p>umask 的数字指的是该默认值需要减掉的权限，创建一个新的文件权限是 644 (666-022) , 创建一个新的目录权限是 755 (777-022)</p>\n<h1 id=\"shell脚本\"><a class=\"anchor\" href=\"#shell脚本\">#</a> Shell 脚本</h1>\n<p>Shell 脚本设计就是根据程序设计的三种基本结构，即顺序、选择和循环，以及 Shell 脚本的语法规则来来编写 Shell 脚本。</p>\n<p>为了能在不同的 Shell 环境下都解释执行 Shell 脚本的第一行最好为： <code>#!/bin/bash</code>  申明该脚本有 bash 来解释，便于移植到其他系统上也以 bash 来解释。</p>\n<h2 id=\"三种执行方法\"><a class=\"anchor\" href=\"#三种执行方法\">#</a> 三种执行方法</h2>\n<ol>\n<li>\n<p>sh 命令<br />\n这种方法不需要把编辑好的脚本权设置为可执行。只需要在当前目录下输入 “sh 脚本名”，回车即可。</p>\n</li>\n<li>\n<p>./ 脚本名</p>\n</li>\n</ol>\n<p>添加可执行权限，然后在当前面目录下键入./ 脚本名，回车即可。</p>\n<ol start=\"3\">\n<li>脚本名</li>\n</ol>\n<p>首先需要添加可执行权限，然后把脚本所在目录添加到搜索路径（./bash_profile 文件）中。</p>\n<p>此后无论在哪里直接执行脚本名就可。</p>\n<h2 id=\"shell命令的执行顺序\"><a class=\"anchor\" href=\"#shell命令的执行顺序\">#</a> Shell 命令的执行顺序</h2>\n<h3 id=\"顺序执行\"><a class=\"anchor\" href=\"#顺序执行\">#</a> 顺序执行</h3>\n<ol>\n<li>顺序分隔符 (😉<br />\n多条命令可以在一行中输出，但各命令应以分号 (;) 隔开。</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /home;ifconfig > 1.txt;echo 666</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">666</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@node home<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span>.txt  hadoop</pre></td></tr></table></figure><ol start=\"2\">\n<li>管道 (|)<br />\n 管道也是顺序执行</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node home<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/passwd |wc -l> 1.txt</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@node home<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat 1.txt </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">43</span></pre></td></tr></table></figure><h3 id=\"逻辑与和逻辑或\"><a class=\"anchor\" href=\"#逻辑与和逻辑或\">#</a> 逻辑与和逻辑或</h3>\n<ol>\n<li>\n<p>逻辑与 (&amp;&amp;)<br />\n 逻辑与 (&amp;&amp;) 可以把两个或两个以上命令联系在一起。<br />\n <code>command1&amp;&amp;command2&amp;&amp;....&amp;&amp;command</code> <br />\n 功能：先运行 1，如果 1 成功则运行 2，否则不运行 2，依次类推。</p>\n</li>\n<li>\n<p>逻辑或 (||)</p>\n</li>\n</ol>\n<p>逻辑或 (||) <code>command1||command2||....||command</code></p>\n<p>先运行命令 1 如果运行不成功则运行命令 2，否则不运行命令 2，依次类推。</p>\n<h2 id=\"脚本中的变量\"><a class=\"anchor\" href=\"#脚本中的变量\">#</a> 脚本中的变量</h2>\n<ol>\n<li>等号</li>\n</ol>\n<p>两个注意点：等号前后不能有空格；当需要将一个带有空格的字符串赋给变量时要用单引号括起来。</p>\n<p>要改变变量的值，可以再次赋值。如要把它设置为只读，可在变量前面加上 readonly</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node home<span class=\"token punctuation\">]</span><span class=\"token comment\"># readonly ct=$(date)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@node home<span class=\"token punctuation\">]</span><span class=\"token comment\"># ct=1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bash: ct: 只读变量</pre></td></tr></table></figure><ol start=\"2\">\n<li>read</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">read</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>格式：read 【选项】 变量名</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>功能：从标准输入设备读入变量的值</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>主要选项说明：</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-p “提示语句”  屏幕上输出的语句</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ./test.sh </span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>hello world</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>2geshuzhi22 <span class=\"token number\">33</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token number\">22</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token number\">33</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat test.sh </span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">#!/bin/bash</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"2geshuzhi\"</span> a b</pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$a</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$b</span></pre></td></tr></table></figure><ol start=\"3\">\n<li>引用命令执行结果</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>变量名<span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>命令<span class=\"token variable\">`</span></span> <span class=\"token punctuation\">(</span>两个反引号<span class=\"token punctuation\">)</span>  或  变量名<span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>命令<span class=\"token variable\">)</span></span></pre></td></tr></table></figure><ol start=\"4\">\n<li>引用（访问）变量与 echo 命令</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>任何变量的引用都是变量前加上‘$’</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">echo</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token punctuation\">[</span>选项<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"显示的信息\"</span> 或 $变量<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>-n 显示后并不自动换行</pre></td></tr></table></figure><ol start=\"5\">\n<li>位置变量与 shift 命令</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">0,1</span>,2,3<span class=\"token punctuation\">..</span>.9 程序名赋给了0</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">shift</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>格式：shift 【n】</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>功能：是第一个命令行参数无效，并把位置变量2的值移给位置变量1，把位置变量3的值移给位置变量2，</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>依次类推。不会改变位置参数0的值</pre></td></tr></table></figure><ol start=\"6\">\n<li>其他 shell 变量</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#变量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>该变量存放传递给shell脚本命令行参数的个数。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat test.sh </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#!/bin/bash</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"2geshuzhi\"</span> a b</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$a</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$b</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$#</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ./test.sh </span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>hello world</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>2geshuzhi <span class=\"token number\">6666</span> <span class=\"token number\">77</span> </pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token number\">6666</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token number\">77</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>?变量</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>该变量里存放Shell脚本中最后一条命令的返回码。Linux中每条命令执行完后都会返回一个值，</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>这个值称为返回码。一般执行成功返回0，不成功返回非0的值。</pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>*<span class=\"token punctuation\">(</span>@<span class=\"token punctuation\">)</span>变量</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>该变量存放所有输入的命令行参数，并且每个参数之间用空格隔开。</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>在Linux系统中使用*或@变量是等价的。</pre></td></tr></table></figure><h2 id=\"流程控制语句\"><a class=\"anchor\" href=\"#流程控制语句\">#</a> 流程控制语句</h2>\n<h3 id=\"if语句\"><a class=\"anchor\" href=\"#if语句\">#</a> if 语句</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>两路分支（若没有else则变成一路分支）</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span>  判断条件</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">then</span> 命令1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">else</span> 命令2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">fi</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>多路分支</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">if</span>  判断条件1</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">then</span> 命令1</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">elif</span> 判断条件1</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">then</span> 命令2</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">else</span> 命令n</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">fi</span></pre></td></tr></table></figure><h3 id=\"测试语句\"><a class=\"anchor\" href=\"#测试语句\">#</a> 测试语句</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>测试语句计算一个表达式的值并返回‘真’或‘假’。该语句有两种语法格式，一种是使用关键字test</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>，另一种是使用方括号。格式如下：</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>格式1：</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">test</span> expression</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>格式2</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">[</span>expression<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><h3 id=\"case语句\"><a class=\"anchor\" href=\"#case语句\">#</a> case 语句</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>执行相匹配的命令。case语句格式如下：</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">case</span> 值 <span class=\"token keyword\">in</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>模式1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    command1</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    command2</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    commandN</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>模式2）</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    command1</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    command2</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    commandN</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">esac</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>匹配发现取值符合某一模式后，其间所有命令开始执行直至 <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>。</pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>下面的脚本提示输入1到4，与每一种模式进行匹配：</pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'输入 1 到 4 之间的数字:'</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'你输入的数字为:'</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token builtin class-name\">read</span> aNum</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">case</span> <span class=\"token variable\">$aNum</span> <span class=\"token keyword\">in</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'你选择了 1'</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'你选择了 2'</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'你选择了 3'</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token number\">4</span><span class=\"token punctuation\">)</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'你选择了 4'</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    *<span class=\"token punctuation\">)</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'你没有输入 1 到 4 之间的数字'</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token keyword\">esac</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>输入不同的内容，会有不同的结果，例如：</pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>输入 <span class=\"token number\">1</span> 到 <span class=\"token number\">4</span> 之间的数字:</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>你输入的数字为:</pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>你选择了 <span class=\"token number\">3</span></pre></td></tr></table></figure><h3 id=\"for语句\"><a class=\"anchor\" href=\"#for语句\">#</a> for 语句</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>for循环一般格式为：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">var</span> <span class=\"token keyword\">in</span> item1 item2 <span class=\"token punctuation\">..</span>. itemN</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    command1</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    command2</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    commandN</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">loop</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The value is: <span class=\"token variable\">$loop</span>\"</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>输出结果：</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>The value is: <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>The value is: <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>The value is: <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>The value is: <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>The value is: <span class=\"token number\">5</span></pre></td></tr></table></figure><h3 id=\"while语句\"><a class=\"anchor\" href=\"#while语句\">#</a> while 语句</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">while</span> condition</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token builtin class-name\">command</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#!/bin/bash</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token assign-left variable\">int</span><span class=\"token operator\">=</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token variable\"><span class=\"token punctuation\">((</span> $int<span class=\"token operator\">&lt;=</span><span class=\"token number\">5</span> <span class=\"token punctuation\">))</span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$int</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token builtin class-name\">let</span> <span class=\"token string\">\"int++\"</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>运行脚本，输出：</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>以上实例使用了 Bash <span class=\"token builtin class-name\">let</span> 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。</pre></td></tr></table></figure><h3 id=\"无限循环\"><a class=\"anchor\" href=\"#无限循环\">#</a> 无限循环</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>无限循环</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>无限循环语法格式：</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token builtin class-name\">command</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>或者</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">while</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token builtin class-name\">command</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>或者</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">))</span></span></pre></td></tr></table></figure><h3 id=\"until-语句\"><a class=\"anchor\" href=\"#until-语句\">#</a> until 语句</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">until</span> 循环执行一系列命令直至条件为 <span class=\"token boolean\">true</span> 时停止。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">until</span> 循环与 <span class=\"token keyword\">while</span> 循环在处理方式上刚好相反。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>一般 <span class=\"token keyword\">while</span> 循环优于 <span class=\"token keyword\">until</span> 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">until</span> 语法格式:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">until</span> condition</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token builtin class-name\">command</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>以下实例我们使用 <span class=\"token keyword\">until</span> 命令来输出 <span class=\"token number\">0</span> ~ <span class=\"token number\">9</span> 的数字：</pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>实例</pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">#!/bin/bash</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">until</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> <span class=\"token variable\">$a</span> -lt <span class=\"token number\">10</span> <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>   <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$a</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>   <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">expr</span> $a + <span class=\"token number\">1</span><span class=\"token variable\">`</span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">#### expr 表达式 表示求表达式的值</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>运行结果：</pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>输出结果为：</pre></td></tr><tr><td data-num=\"33\"></td><td><pre></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token number\">9</span></pre></td></tr></table></figure><h1 id=\"附上思维导图\"><a class=\"anchor\" href=\"#附上思维导图\">#</a> 附上思维导图</h1>\n<p>右键新标签页查看</p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://or0kit.github.io/Linux/linux%E5%91%BD%E4%BB%A4scp--%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E3%80%90%E8%BD%AC%E3%80%91/",
            "url": "https://or0kit.github.io/Linux/linux%E5%91%BD%E4%BB%A4scp--%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E3%80%90%E8%BD%AC%E3%80%91/",
            "title": "linux命令scp--远程拷贝文件【转】",
            "date_published": "2020-12-20T14:57:06.000Z",
            "content_html": "<p>转载自<span class=\"exturl\" data-url=\"aHR0cDovL3lha3NheW9vLmJsb2cuNTFjdG8uY29tLzUxMDkzOC8xNzU3MTk=\"> http://yaksayoo.blog.51cto.com/510938/175719</span></p>\n<h1 id=\"linux下scp的用法\"><a class=\"anchor\" href=\"#linux下scp的用法\">#</a> Linux 下 scp 的用法</h1>\n<p>scp 就是 secure copy，一个在 linux 下用来进行远程拷贝文件的命令。<br />\n有时我们需要获得远程服务器上的某个文件，该服务器既没有配置 ftp 服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过简单的 scp 命令便可达到目的。</p>\n<h1 id=\"一-将本机文件复制到远程服务器上\"><a class=\"anchor\" href=\"#一-将本机文件复制到远程服务器上\">#</a> 一、将本机文件复制到远程服务器上</h1>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#scp /home/administrator/news.txt root@192.168.6.129:/etc/squid</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>/home/administrator/      本地文件的绝对路径</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>news.txt                          要复制到服务器上的本地文件</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>root                                 通过root用户登录到远程服务器（也可以使用其他拥有同等权限的用户）</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">192.168</span>.6.129                远程服务器的ip地址（也可以使用域名或机器名）</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>/etc/squid                       将本地文件复制到位于远程服务器上的路径</pre></td></tr></table></figure><p>如图通过 root 用户登录远程服务器，输入 yes 表示同意建立 ssh 连接</p>\n<p>按提示输入 root 用户的密码</p>\n<p>如图所示建立连接后开始传输文件，显示百分比、实际时间和传送速度等信息</p>\n<h1 id=\"二-将远程服务器上的文件复制到本机\"><a class=\"anchor\" href=\"#二-将远程服务器上的文件复制到本机\">#</a> 二、将远程服务器上的文件复制到本机</h1>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#scp remote@www.abc.com:/usr/local/sin.sh /home/administrator</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>remote                       通过remote用户登录到远程服务器（也可以使用其他拥有同等权限的用户）</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>www.abc.com              远程服务器的域名（当然也可以使用该服务器ip地址）</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>/usr/local/sin.sh           欲复制到本机的位于远程服务器上的文件</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>/home/administrator  将远程文件复制到本地的绝对路径</pre></td></tr></table></figure><p>注意两点：<br />\n1. 如果远程服务器防火墙有特殊限制，scp 便要走特殊端口，具体用什么端口视情况而定，命令格式如下：<br />\n <code>#scp -p 4588 remote@www.abc.com:/usr/local/sin.sh /home/administrator</code> <br />\n2. 使用 scp 要注意所使用的用户是否具有可读取远程服务器相应文件的权限。</p>\n",
            "tags": [
                "Linux"
            ]
        }
    ]
}