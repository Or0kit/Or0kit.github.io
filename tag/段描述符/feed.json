{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"段描述符\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Protect-Mode/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E3%80%81%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Protect-Mode/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E3%80%81%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90/",
            "title": "保护模式--段寄存器结构、段描述符、段选择子",
            "date_published": "2021-07-29T13:25:00.000Z",
            "content_html": "<h1 id=\"段寄存器\"><a class=\"anchor\" href=\"#段寄存器\">#</a> 段寄存器</h1>\n<p>什么是段寄存器，有哪些段寄存器</p>\n<p>当我们用汇编读写某一个地址时： <code>mov dword ptr ds:[0x123456],eax</code> <br />\n 我们真正读写的地址是： <code>ds.base + 0x123456</code> <br />\n <code>ES</code>   <code>CS</code>   <code>SS</code>   <code>DS</code>   <code>FS</code>   <code>GS</code>   <code>LDTR</code>   <code>TR</code>  共 8 个</p>\n<p>代码段寄存器 CS（Code Segment）<br />\n存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由 IP 提供。</p>\n<p>数据段寄存器 DS（Data Segment）<br />\n指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。</p>\n<p>堆栈段寄存器 SS（Stack Segment）<br />\n指出当前堆栈的底部地址，即存放堆栈段的段基址。</p>\n<p>附加段寄存器 ES（Extra Segment）<br />\n指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段。</p>\n<p>FS、GS 是从 80386 开始增加的，没有全称。</p>\n<p>FS,GS 是 80386 起增加的两个辅助段寄存器，在这之前只有一个辅助段寄存器 ES, 增加这两个寄存器是为了减轻 ES 寄存器的负担，并能更好地配合适用于通用寄存器组的基址和变址寄存器。</p>\n<p>寄存器 FS 和 GS 是段寄存器。它们没有处理器定义的目的，而是由操作系统运行它们来赋予目的。<br />\n附加段寄存器，F 为上一个附加段寄存器字母 E 后的字母，没有对应的名称</p>\n<ul>\n<li><strong>FS</strong></li>\n</ul>\n<p>指向一种被称为线程信息块（TEB）的结构，这种结构是由内核在创建线程时创建的，用于支持操作系统相关功能、服务和 API</p>\n<ul>\n<li><strong>GS</strong></li>\n</ul>\n<p>附加段寄存器，G 为上一个附加段寄存器字母 F 后的字母，没有对应的名称</p>\n<p>在 32 位 Windows 上 GS 保留供将来使用</p>\n<p>在 x64 模式下，FS 和 GS 段寄存器已交换</p>\n<p>Win64 使用 GS 的原因是该 FS 寄存器用于 32 位兼容性层（称为 Wow64）</p>\n<p>32 位应用程序永远不会导致 GS 更改，而 64 位应用程序永远不会导致 FS 更改</p>\n<p>注意，在 Win64 和 Wow64 中 GS 是非零的，这可以用来检测一个 32 位应用程序是否在 64 位 Windows 中运行，在一个 “真正 “的 32 位 Windows 中 GS 总是零</p>\n<h2 id=\"段寄存器结构\"><a class=\"anchor\" href=\"#段寄存器结构\">#</a> 段寄存器结构</h2>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>段寄存器中有 16 位是可见部分，有 80 位是不可见部分，一共 96 位。<br />\n可见部分为 16 位的 Selector 部分<br />\n 16 位的 Attribute 为这个段寄存器的属性，它的意义为：表示该段寄存器是可读还是可写还是可执行的。<br />\n32 位的 Base 表示该段是从哪里开始的。<br />\n32 位的 Limit 表示整个段的长度有多少。</p>\n<h2 id=\"段寄存器的读写\"><a class=\"anchor\" href=\"#段寄存器的读写\">#</a> 段寄存器的读写</h2>\n<p>读段寄存器的时候只能够读 16 位。<br />\n比如： <code>mov ax,es</code>  只能读 16 位的可见部分</p>\n<p>读写 LDTR 的指令为： <code>SLDT/LLDT</code></p>\n<p>读写 TR 的指令为： <code>STR/LTR</code></p>\n<p>写段寄存器的时候写的是 96 位。<br />\n比如： <code>mov ds,ax</code>  写时是写 96 位</p>\n<h2 id=\"加载段描述符至段寄存器\"><a class=\"anchor\" href=\"#加载段描述符至段寄存器\">#</a> 加载段描述符至段寄存器</h2>\n<p>除了 MOV 指令，还可以使用 LES、LSS、LDS、LFS、LGS 指令修改段寄存器</p>\n<p>例如：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> buffer<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>__asm<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  les ecx<span class=\"token punctuation\">,</span>fword ptr ds<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>buffer<span class=\"token punctuation\">]</span>  <span class=\"token comment\">// 高 2 个字节给 es, 低四个字节给 ecx</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"段寄存器属性简介\"><a class=\"anchor\" href=\"#段寄存器属性简介\">#</a> 段寄存器属性简介</h2>\n<p>段寄存器 | Selector | Attribute    | Base       | Limit</p>\n<p>GS 寄存器 Windows 并没有使用。</p>\n<h2 id=\"gdt全局描述符表-ldt局部描述符表\"><a class=\"anchor\" href=\"#gdt全局描述符表-ldt局部描述符表\">#</a> GDT (全局描述符表) LDT (局部描述符表)</h2>\n<p><strong>LDT 表在 Windows 中并没有使用。</strong><br />\n当我们执行类似  <code>mov ds,ax</code>  指令时，CPU 会查表，根据  <code>ax</code>  的值来决定查找  <code>GDT</code>  还是  <code>LDT</code> , 查找表的什么位置，查出多少数据。<br />\n <code>gdtr</code>  寄存器中存储了  <code>GDT</code>  表的起始地址和  <code>gdt</code>  表中的长度<br />\n gdtr 是 48 位的寄存器，其中 32 位存储的这张表的位置，16 位存储的这张表的大小。</p>\n<p><strong>在 windbg 中查看</strong></p>\n<pre><code>r gdtr //gdt表的存储位置\nr gdtl //gdt表的大小\n</code></pre>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p>每次从  <code>GDT</code>  表中查表：每 8 个字节为一个<strong>段描述符</strong>。</p>\n<h1 id=\"段选择子\"><a class=\"anchor\" href=\"#段选择子\">#</a> 段选择子</h1>\n<p>段选择子是一个 16 位的段描述符，该描述符指向了定义该段的段描述符.</p>\n<h2 id=\"段选择子和段寄存器的对应关系\"><a class=\"anchor\" href=\"#段选择子和段寄存器的对应关系\">#</a> 段选择子和段寄存器的对应关系</h2>\n<p>对应可见部分的 16 位既段寄存器中的 Selector。</p>\n<h2 id=\"段选择子的结构\"><a class=\"anchor\" href=\"#段选择子的结构\">#</a> 段选择子的结构</h2>\n<p><img data-src=\"image009.png\" alt=\"\" /></p>\n<p>RPL：请求特权级别<br />\n TI：TI=0 查 GDT 表；TI=1 查 LDT 表<br />\n Index：处理器将索引值乘以 8 在加上 GDT 或者 LDT 的基地址，就是要加载的段描述符</p>\n<h1 id=\"段描述符\"><a class=\"anchor\" href=\"#段描述符\">#</a> 段描述符</h1>\n<h2 id=\"段描述符的结构\"><a class=\"anchor\" href=\"#段描述符的结构\">#</a> 段描述符的结构</h2>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<ol>\n<li>\n<p>16 位的 Attribute 对应段寄存器中高四字节从 8 位开始到第 23 位结束。</p>\n</li>\n<li>\n<p>32 位的 Base 包含了三个部分：</p>\n<ul>\n<li>高四字节的第 24 位到第 31 部分</li>\n<li>高四字节的第 0 位到第 7 位</li>\n<li>低四字节的第 16 位到 31 位</li>\n</ul>\n</li>\n<li>\n<p>32 位的 Limit 包括两部分一共二十位（最大值为 FFFFF）：</p>\n<ul>\n<li>高四字节的 16 位到 19 位</li>\n<li>低四个字节的 0 位到 15 位</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"段描述符的属性\"><a class=\"anchor\" href=\"#段描述符的属性\">#</a> 段描述符的属性</h2>\n<p>段寄存器的值是通过段描述符填写的，但段描述符只有 64 位，可是要填写的有 80 位，如何从 64 位变成 80 位呢？</p>\n<h3 id=\"p位\"><a class=\"anchor\" href=\"#p位\">#</a> P 位</h3>\n<p>P 位 位于段描述符的高四个字节的第 15 位（下标为 15）的位置.</p>\n<p>P = 1 段描述符有效<br />\n P = 0 段描述符无效</p>\n<p>当使用指令将段描述符加载至段寄存器的时候，CPU 第一个检测的就是 P 位，当 P 位为 0 时就不做继续的检测了。</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<p>在段描述符中，只要看这一行的数是否小于 8，若小于 8，则证明 P 位 = 0 段描述符无效。</p>\n<h3 id=\"g位\"><a class=\"anchor\" href=\"#g位\">#</a> G 位</h3>\n<p>G 位 位于段描述符的高四个字节的第 23 位（下标为 23）的位置。</p>\n<p>G=0 的时候：表示 Limit 字段单位（粒度）是字节：最大值就是 limit 域。<br />\nG=1 的时候：表示 Limit 字段单位（粒度）是 4KB：最大值就是 limit 域 * 0x4K + 0xFFF。</p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>在段描述符中，只要看这一行的数是否小于 8，若小于 8，则证明 G 位 = 0。</p>\n<h3 id=\"s位\"><a class=\"anchor\" href=\"#s位\">#</a> S 位</h3>\n<p>S 位 位于段描述符的高四个字节的第 12 位（下标为 12）的位置。</p>\n<p>S = 1 时表示： 代码段或者数据段描述符<br />\n S = 0 时表示： 系统段描述符</p>\n<ul>\n<li><strong>十六进制下，从右到左看高字节的第五位，若是偶数则 S 位 = 0，若是奇数则 S 位 = 1。</strong></li>\n</ul>\n<h3 id=\"type域\"><a class=\"anchor\" href=\"#type域\">#</a> type 域</h3>\n<p>type 域 包含段描述符的高四个字节的 8、9、10、11 共四位。</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<h4 id=\"数据段\"><a class=\"anchor\" href=\"#数据段\">#</a> 数据段</h4>\n<p>当 s 位为 1 且当 type 域中的 11 位为 0 时，表示是数据段。<br />\n其中图中的 A、W、E 分别代表不同的意思</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>E 位表示拓展位，为 0 表示向上拓展，为 1 表示向下拓展。<br />\n向上拓展：有效范围为 <code>fs.Base ~ fs.Base+Limit</code> <br />\n 向下拓展：有效范围除了 <code>fs.Base ~ fs.Base+Limit</code></p>\n<h4 id=\"代码段\"><a class=\"anchor\" href=\"#代码段\">#</a> 代码段</h4>\n<p>当 s 位为 1 且当 type 域中的 11 位为 1 时，表示是代码段。<br />\n其中图中的 A、R、C 分别代表不同的意思</p>\n<p>A 代表是否访问过，未访问过为 0，访问过为 1。<br />\nR 代表是否可读位，表示该段是否可以读。<br />\nC 代表一致位：C = 1 表示一致代码段 ，C = 0 表示非一致代码段</p>\n<h4 id=\"系统描述符\"><a class=\"anchor\" href=\"#系统描述符\">#</a> 系统描述符</h4>\n<p>当 s 位为 0 的时候，表示该段描述符为系统描述符。系统描述符有分为以下类型：</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<h3 id=\"dpl\"><a class=\"anchor\" href=\"#dpl\">#</a> DPL</h3>\n<ul>\n<li><strong>描述：</strong></li>\n</ul>\n<p>DPL 存储在段描述符中，规定了访问所在段描述符所需要的特权级别是多少<br />\n DPL 数值越大，访问所在段描述符所需要的权限越低<br />\n注意：在 Windows 中，DPL 只会出现两种情况，要么全为 0，要么全为 1</p>\n<p><strong>十六进制下，从右到左看高字节的第五位，若是 <code>8</code>  或 <code>9</code>  则 DPL=0，若是 <code>E</code>  或 <code>F</code>  则 DPL=3。</strong></p>\n<ul>\n<li><strong>例：</strong></li>\n</ul>\n<p>若 AX 指向的段描述符的 DPL=0，但当前程序的 CPL=3，那么这条指令是不会成功的！</p>\n<h3 id=\"db位\"><a class=\"anchor\" href=\"#db位\">#</a> D\\B 位</h3>\n<p><strong>情况 1：对 CS 段的影响</strong></p>\n<p>D=1：采用 32 位寻址方式<br />\n D=0：采用 16 位寻址方式</p>\n<p><strong>情况 2：对 SS 段的影响</strong></p>\n<p>D=1：隐式堆栈访问指令（如：PUSH POP CALL）使用 32 位堆栈指针寄存器 ESP<br />\nD=0：隐式堆栈访问指令（如：PUSH POP CALL）使用 16 位堆栈指针寄存器 SP</p>\n<p><strong>情况 3：向下拓展的数据段</strong></p>\n<p>D=1：段上限为 4GB<br />\nD=0：段上限为 64KB</p>\n<p><img data-src=\"image010.png\" alt=\"\" /></p>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTE2MTc5L2FydGljbGUvZGV0YWlscy85MTU1MDYzMQ==\">https://blog.csdn.net/qq_36916179/article/details/91550631</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTE2MTc5L2FydGljbGUvZGV0YWlscy85MTYyMTk0Nw==\">https://blog.csdn.net/qq_36916179/article/details/91621947</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTg4NDQ4L2FydGljbGUvZGV0YWlscy8xMDI1NjMzMjU=\">https://blog.csdn.net/qq_41988448/article/details/102563325</span></p>\n",
            "tags": [
                "段寄存器结构",
                "段描述符",
                "段选择子",
                "GDT表"
            ]
        }
    ]
}