{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"apc的备用队列\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Apc/APC%E6%9C%BA%E5%88%B6-02APC%E7%9A%84%E5%A4%87%E7%94%A8%E9%98%9F%E5%88%97/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Apc/APC%E6%9C%BA%E5%88%B6-02APC%E7%9A%84%E5%A4%87%E7%94%A8%E9%98%9F%E5%88%97/",
            "title": "APC机制-02APC的备用队列",
            "date_published": "2022-02-25T11:22:59.000Z",
            "content_html": "<h1 id=\"楔子\"><a class=\"anchor\" href=\"#楔子\">#</a> 楔子</h1>\n<p>要点回顾：在上一节中我们讲过，如果想让线程做什么事情，就给它的 APC 队列里面挂一个 APC。</p>\n<p>发现在  <code>KTHREAD</code>  结构体中除了  <code>ApcState</code>  还有其他与 APC 相关的成员</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kd&gt; dt _KTHREAD</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>nt!_KTHREAD</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   ...</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   +0x034 ApcState         : _KAPC_STATE</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   ...</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  ...</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   +0x14c SavedApcState    : _KAPC_STATE</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  ...</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   +0x165 ApcStateIndex    : UChar</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   +0x166 ApcQueueable     : UChar</pre></td></tr></table></figure><p>以下内容就是为了弄清楚这些成员的作用。</p>\n<h2 id=\"savedapcstate的意义\"><a class=\"anchor\" href=\"#savedapcstate的意义\">#</a> SavedApcState 的意义</h2>\n<p>线程 APC 队列中的 APC 函数都是与进程相关联的，具体点说：A 进程的 T 线程中的所有 APC 函数，要访问的内存地址都是 A 进程的。</p>\n<p>但线程是可以挂靠到其他的进程：比如 A 进程的线程 T，通过修改 Cr3 (改为 B 进程的页目录基址)，就可以访问 B 进程地址空间，即所谓 “进程挂靠”。</p>\n<p>当 T 线程挂靠 B 进程后，APC 队列中存储的却仍然是原来的 APC！具体点说，比如某个 APC 函数要读取一个地址为 0x12345678 的数据，如果此时进行读取，读到的将是 B 进程的地址空间，这样逻辑就错误了！</p>\n<p>为了避免混乱，在 T 线程挂靠 B 进程时，会将 ApcState 中的值暂时存储到 SavedApcState 中，等回到原进程 A 时，再将 APC 队列恢复。</p>\n<p>所以，  <code>SavedApcState</code>  又称为备用 APC 队列。</p>\n<h2 id=\"挂靠环境下apcstate的意义\"><a class=\"anchor\" href=\"#挂靠环境下apcstate的意义\">#</a> 挂靠环境下 ApcState 的意义</h2>\n<p>在挂靠的环境下，也是可以向线程 APC 队列插入 APC 的，那这种情况下，使用的是哪个 APC 队列呢？</p>\n<p>当 A 进程的 T 线程挂靠 B 进程时，A 是 T 的所属进程，B 是 T 的挂靠进程。</p>\n<p><code>ApcState</code>     \tB 进程相关的 APC 函数</p>\n<p><code>SavedApcState</code> \tA 进程相关的 APC 函数</p>\n<p>在正常情况下，当前进程就是所属进程 A，如果是挂靠情况下，当前进程就是挂靠进程 B。</p>\n<p>当前进程与当前线程，有相关的 API 获取，查看这些函数，可以发现他们的本质都是取 fs:[0x124] 接着又取 0x44 。</p>\n<h2 id=\"apcstatepointer\"><a class=\"anchor\" href=\"#apcstatepointer\">#</a> ApcStatePointer</h2>\n<p>为了操作方便，_KTHREAD 结构体中定义了一个指针数组  <code>ApcStatePointer</code>  ，长度为 2。</p>\n<p>正常情况下</p>\n<div class=\"note primary no-icon\">\n<p>ApcStatePointer [0]  指向  <code>ApcState</code> <br />\nApcStatePointer [1]  指向  <code>SavedApcState</code></p>\n</div>\n<p>挂靠情况下：</p>\n<div class=\"note primary no-icon\">\n<p>ApcStatePointer [0]  指向  <code>SavedApcState</code> <br />\nApcStatePointer [1]  指向  <code>ApcState</code></p>\n</div>\n<h2 id=\"apcstateindex\"><a class=\"anchor\" href=\"#apcstateindex\">#</a> ApcStateIndex</h2>\n<p>ApcStateIndex 用来标识当前线程处于什么状态：</p>\n<p><code>0</code>  正常状态<br />\n <code>1</code>  挂靠状态</p>\n<h2 id=\"apcstatepointer-与-apcstateindex组合寻址\"><a class=\"anchor\" href=\"#apcstatepointer-与-apcstateindex组合寻址\">#</a> ApcStatePointer 与 ApcStateIndex 组合寻址</h2>\n<p>正常情况下，向 ApcState 队列中插入 APC 时：</p>\n<p>ApcStatePointer [0]  指向  <code>ApcState</code>  此时 ApcStateIndex 的值为 0<br />\nApcStatePointer [ApcStateIndex]  指向  <code>ApcState</code></p>\n<p>挂靠情况下，向 ApcState 队列中插入 APC 时：<br />\nApcStatePointer [1]  指向  <code>ApcState</code>  此时 ApcStateIndex 的值为 1<br />\nApcStatePointer [ApcStateIndex]  指向  <code>ApcState</code></p>\n<p>总结：<br />\n无论什么环境下，ApcStatePointer [ApcStateIndex] 指向的都是  <code>ApcState</code>  。<br />\n <code>ApcState</code>  则总是表示线程<strong>当前</strong>使用的 apc 状态。</p>\n<h2 id=\"apcqueueable\"><a class=\"anchor\" href=\"#apcqueueable\">#</a> ApcQueueable</h2>\n<p><strong>ApcQueueable 用于表示是否可以向线程的 APC 队列中插入 APC。</strong></p>\n<p>当线程正在执行退出的代码时，会将这个值设置为 0 ，如果此时执行插入 APC 的代码 (KeInsertQueueApc 后面会讲), 在插入函数中会判断这个值的状态，如果为 0，则插入失败。</p>\n<h2 id=\"作业\"><a class=\"anchor\" href=\"#作业\">#</a> 作业</h2>\n<p>分析 API  <code>NtReadVirtualMemory</code>  。<br />\n目的是了解挂靠到底做了什么、APC 是如何备份的、什么时候备份、什么时候还原的。</p>\n<p>回去写进程的挂靠和跨进程读写内存了。</p>\n<p><a href=\"https://or0kit.github.io/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%92%8C%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/\">https://or0kit.github.io/ 进程与线程 - 进程挂靠和跨进程读写内存 /</a></p>\n",
            "tags": [
                "APC的备用队列"
            ]
        }
    ]
}