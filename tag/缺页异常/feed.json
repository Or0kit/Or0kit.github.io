{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"缺页异常\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/MemoryManagement/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-05%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/MemoryManagement/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-05%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8/",
            "title": "内存管理-05无处不在的缺页异常",
            "date_published": "2022-04-16T07:17:03.000Z",
            "content_html": "<h1 id=\"缺页异常的由来\"><a class=\"anchor\" href=\"#缺页异常的由来\">#</a> 缺页异常的由来</h1>\n<p>先来复习一下 PTE：</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>P 位  代表当前页面是否有效。</p>\n<p>当 CPU 访问一个地址，其 PTE 的 P 位为 0，此时会产生缺页异常；</p>\n<p>在 windows 中，缺页异常是时刻在发生的。</p>\n<p>Windows 利用缺页异常机制让我们更加有效的访问内存。</p>\n<p>海哥原话：当我们的物理内存大小只有 2MB 时，当我们需要用到某个物理页的时候，将对应物理页的 P 位置 1，当我们不再需要使用该物理页时，再将其 P 位置 0，这样的内存使用效率是非常低的。</p>\n<p>因此 windows 不是这样设计的 —— 只有正在使用的线性地址，才会被挂上物理页，当物理页在一段时间内不被使用或不够用的情况下，操作系统会将当前物理页中的数据拷贝至硬盘中，然后将当前物理页供给 “别人” 使用，当需要再次用到该物理页的数据时，则将 “别人” 的数据再拷贝出来，将 “自己 &quot; 的数据从硬盘中拷回，被拷至硬盘中的物理页数据会被写入到一个文件中，也就是我们平时常说的<strong>虚拟内存</strong></p>\n<p>也就是 C 盘中的  <code>pagefile.sys</code>  文件。</p>\n<p>当物理页占用情况较为紧张时，这个文件用于存放物理页的临时数据作为备份。</p>\n<h1 id=\"virtualalloc-函数\"><a class=\"anchor\" href=\"#virtualalloc-函数\">#</a> VirtualAlloc 函数</h1>\n<p>保留与提交的误区</p>\n<p>还是这个函数，前面我们已经验证过了。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>LPVOID VirtualAlloc<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tLPVOID lpAddress<span class=\"token punctuation\">,</span> \t<span class=\"token comment\">// 要分配的内存区域的地址</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tDWORD dwSize<span class=\"token punctuation\">,</span> \t\t<span class=\"token comment\">// 分配的大小</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tDWORD flAllocationType<span class=\"token punctuation\">,</span> \t<span class=\"token comment\">// 类型：MEM_RESERVE MEM_COMMIT</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tDWORD flProtect \t<span class=\"token comment\">// 该内存的初始保护属性</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>MEM_RESERVE：保留线性地址</p>\n<p>MEM_COMMIT：可以有物理页，但不是立即有或者一直有</p>\n<h1 id=\"无处不在的缺页\"><a class=\"anchor\" href=\"#无处不在的缺页\">#</a> 无处不在的缺页</h1>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<ol>\n<li>当物理页被放入页面文件时，PTE 结构如图 a 所示</li>\n<li>当该进程再次读取该物理页对应的线性地址时，由于 P 位为 0，因此会触发缺页异常处理程序</li>\n<li>在 windows xp 中，缺页异常处理程序位于 IDT [0xE]</li>\n<li>此时，缺页异常处理程序会再次查询当前 PTE 的属性，若 1-4 位，5-9 位，12-31 位都有值，说明当前 PTE 是有效的，但是物理页被存放到了页面文件中</li>\n<li>然后，缺页异常处理程序根据 PTE 中得到的值去查询 pagefile.sys，将原来的物理页的内容挂入新的物理页，然后将 P 位置 1，再将新的物理页的物理地址挂入 PTE 的第 12-31 位</li>\n<li>在用户看来，两次读取同一个线性地址，中间这一系列复杂过程是透明的，而只能观察到两次都成功读取了同一个值</li>\n</ol>\n<h1 id=\"execute_writecopy写拷贝\"><a class=\"anchor\" href=\"#execute_writecopy写拷贝\">#</a> EXECUTE_WRITECOPY（写拷贝）</h1>\n<p>描述：当程序正常加载一个 EXE 或者 DLL 时，其 VadRoot 中的内存属性为 Mapped EXE，权限为 EXECUTE_WRITECOPY，当试图对其某一内容进行修改时，无法对其它进程中的同一个模块产生影响</p>\n<p>原理：</p>\n<p>当试图对其某一内容进行修改时，系统会检查其线性地址对应的物理页的 PTE 属性，若 R/W 属性为 0 时，触发缺页异常<br />\n缺页异常处理程序检查 VadRoot 中对应线性地址所在空间的 MMVAD_FLAGS 中的 Protection 成员，若值位 0x111 时，表示权限为 EXECUTE_WRITECOPY<br />\n 此时，缺页异常处理程序将当前线性地址对应的物理页内容进行拷贝，将其写入一个新的物理页，然后将当前进程需要修改的线性地址挂入新的物理页上，然后对需要修改的内容进行写入</p>\n<p>解决方法：可通过编写驱动程序先将需要修改的线性地址对应的物理页的 PTE 的 R/W 位置为 1，再对需要修改的地方进行修改。</p>\n<p>以前写过过写拷贝全局监控函数的。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTg4NDQ4L2FydGljbGUvZGV0YWlscy8xMTI2NDczODg=\">https://blog.csdn.net/qq_41988448/article/details/112647388</span></p>\n",
            "tags": [
                "缺页异常"
            ]
        }
    ]
}