{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"扩展pe头属性说明\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/WindowsPE/windowsPE%E7%BB%93%E6%9E%84/",
            "url": "https://or0kit.github.io/Bin/WindowsPE/windowsPE%E7%BB%93%E6%9E%84/",
            "title": "windowsPE结构",
            "date_published": "2020-11-26T08:59:49.000Z",
            "content_html": "<h1 id=\"win32下的pe文件\"><a class=\"anchor\" href=\"#win32下的pe文件\">#</a> win32 下的 PE 文件:</h1>\n<p>PE 是 Portable Execute 的缩写，是可移植可执行的意思，只要文件的数据结构遵循 PE 结构，就属于 PE 文件，windows 中常见的 PE 文件有</p>\n<p><code>*.sys</code>  驱动类文件</p>\n<p><code>*.dll</code>  动态链接库文件</p>\n<p><code>*.exe</code>  可执行文件</p>\n<p><code>*.ocx</code>  对象类别扩充组建</p>\n<p><code>*.obj</code>  目标文件等.</p>\n<p>同样，linux 中使用的是 ELF 格式，和 windows 的 PE 格式有一定的差别，如:</p>\n<p>可重定位文件 <code>*.o</code></p>\n<p>可执行文件如 <code>/bin/ls</code>  等</p>\n<p>共享目标文件 <code>*.so</code></p>\n<p>核心转储文件 core</p>\n<p>都遵循 <code>ELF</code>  数据结构。 unix 从 system v4 开始也使用 <code>ELF</code>  了，而他们的始祖都是 unix system v3 的中 COFF. 如下图:</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<h1 id=\"pe文件结构\"><a class=\"anchor\" href=\"#pe文件结构\">#</a> PE 文件结构</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0xNDU5MTIuaHRt\">源自看雪论坛</span></p>\n<img data-src=\"/Bin/WindowsPE/windowsPE%E7%BB%93%E6%9E%84/pe.gif\" class=\"\" title=\"PE文件架构\">\n<p>win32 中 PE 的逻辑图:</p>\n<p>一个标准的 PE 文件由 DOS 头，stub,NT 头 (包含 PE 标识，标准 PE 头和可选 PE 头三个成员), 节表，节的内容以及一些为了内存对齐而填充的 0.</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<h2 id=\"dos头\"><a class=\"anchor\" href=\"#dos头\">#</a> DOS 头</h2>\n<p>DOS 头就是一堆数据，但它们是一个有序的有含义的组合在一起的结构体。<br />\nDOS 头是为了兼容 DOS 程序而设的，现在基本已经用不上了，仅有两个有意义的字段，所以还是很简单的。<br />\nDOS 头对应的结构体名称叫 IMAGE_DOS_HEADER</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">0x00</span> WORD   e_magic                <span class=\"token operator\">*</span>                <span class=\"token comment\">//\"MZ 标记\" 用于判断是否为可执行文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">0x3C</span> DWORD  e_lfanew<span class=\"token punctuation\">;</span>              <span class=\"token operator\">*</span>                <span class=\"token comment\">//PE 头相对于文件的偏移，用于定位 PE 文件</span></pre></td></tr></table></figure><h2 id=\"win32中pe的nt头\"><a class=\"anchor\" href=\"#win32中pe的nt头\">#</a> win32 中 PE 的 NT 头</h2>\n<p>NT 头是 PE 文件中标准 PE 头和可选 PE 头的总体称谓，还包含一个 PE 标识。下面是它在 Visual C++ 6.0 中 WINNT.h 中的定义:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IMAGE_NT_HEADERS64</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    DWORD Signature<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    IMAGE_FILE_HEADER FileHeader<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    IMAGE_OPTIONAL_HEADER64 OptionalHeader<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span> IMAGE_NT_HEADERS64<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PIMAGE_NT_HEADERS64<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IMAGE_NT_HEADERS</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    DWORD Signature<span class=\"token punctuation\">;</span>                        <span class=\"token comment\">//PE 标识</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    IMAGE_FILE_HEADER FileHeader<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 标准 PE 头 (也称文件头)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    IMAGE_OPTIONAL_HEADER32 OptionalHeader<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 可选 PE 头</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span> IMAGE_NT_HEADERS32<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>PIMAGE_NT_HEADERS32<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>第一个是 64bit 的 NT 头定义，第二个是 32bit 的。这里只探讨 32bit 的。标准 PE 头也叫文件头，这不重要，知道是那么个东西就行了，高端名词主要是为了严谨而取出来的，但是很多时候很晦涩，通俗易懂更易让人接受.</p>\n<h3 id=\"标准pe头\"><a class=\"anchor\" href=\"#标准pe头\">#</a> 标准 PE 头</h3>\n<p><strong>这些内容源自滴水的课件</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">0x00</span> WORD    Machine<span class=\"token punctuation\">;</span>              <span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 程序运行的 CPU 型号：0x0 任何处理器 / 0x14C 386 及后续处理器\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">0x02</span> WORD    NumberOfSections<span class=\"token punctuation\">;</span>     <span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 文件中存在的节的总数，如果要新增节或者合并节 就要修改这个值.\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">0x04</span> DWORD   TimeDateStamp<span class=\"token punctuation\">;</span>        <span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 时间戳：文件的创建时间 (和操作系统的创建时间无关)，编译器填写的.\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">0x08</span> DWORD   PointerToSymbolTable<span class=\"token punctuation\">;</span> \t\t\t\t\t\t\t\t\t\t\t\t\t</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">0x0C</span> DWORD   NumberOfSymbols<span class=\"token punctuation\">;</span> \t\t\t\t\t\t\t\t\t\t\t\t\t</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">0x10</span> WORD    SizeOfOptionalHeader<span class=\"token punctuation\">;</span> <span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 可选 PE 头的大小，32 位 PE 文件默认 E0h 64 位 PE 文件默认为 F0h  大小可以自定义.\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">0x12</span> WORD    Characteristics<span class=\"token punctuation\">;</span>      <span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 每个位有不同的含义，可执行文件值为 10F 即 0 1 2 3 8 位置 1</span></pre></td></tr></table></figure><h3 id=\"可选pe头\"><a class=\"anchor\" href=\"#可选pe头\">#</a> 可选 PE 头</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>WORD    Magic<span class=\"token punctuation\">;</span>        <span class=\"token operator\">*</span>\t\t\t<span class=\"token comment\">// 说明文件类型：10B 32 位下的 PE 文件     20B 64 位下的 PE 文件\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>BYTE    MajorLinkerVersion<span class=\"token punctuation\">;</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>BYTE    MinorLinkerVersion<span class=\"token punctuation\">;</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>DWORD   SizeOfCode<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 所有代码节的和，必须是 FileAlignment 的整数倍 编译器填的  没用\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>DWORD   SizeOfInitializedData<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 已初始化数据大小的和，必须是 FileAlignment 的整数倍 编译器填的  没用\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>DWORD   SizeOfUninitializedData<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 未初始化数据大小的和，必须是 FileAlignment 的整数倍 编译器填的  没用\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>DWORD   AddressOfEntryPoint<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 程序入口\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>DWORD   BaseOfCode<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 代码开始的基址，编译器填的   没用\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>DWORD   BaseOfData<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 数据开始的基址，编译器填的   没用\t\t\t\t\t\t\t\t\t</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>DWORD   ImageBase<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 内存镜像基址</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>DWORD   SectionAlignment<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 内存对齐</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>DWORD   FileAlignment<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t    <span class=\"token comment\">// 文件对齐</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>WORD    MajorOperatingSystemVersion<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>WORD    MinorOperatingSystemVersion<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>WORD    MajorImageVersion<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>WORD    MinorImageVersion<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>WORD    MajorSubsystemVersion<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>WORD    MinorSubsystemVersion<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>DWORD   Win32VersionValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>DWORD   SizeOfImage<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 内存中整个 PE 文件的映射的尺寸，可以比实际的值大，但必须是 SectionAlignment 的整数倍</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>DWORD   SizeOfHeaders<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 所有头 + 节表按照文件对齐后的大小，否则加载会出错。一定是文件对齐的整数倍</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>DWORD   CheckSum<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 校验和，一些系统文件有要求。用来判断文件是否被修改.</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>WORD    Subsystem<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>WORD    DllCharacteristics<span class=\"token punctuation\">;</span>\t</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>DWORD   SizeOfStackReserve<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 初始化时保留的堆栈大小 </span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>DWORD   SizeOfStackCommit<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 初始化时实际提交的大小 </span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>DWORD   SizeOfHeapReserve<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 初始化时保留的堆大小 </span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>DWORD   SizeOfHeapCommit<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 初始化时实践提交的大小 </span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>DWORD   LoaderFlags<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>DWORD   NumberOfRvaAndSizes<span class=\"token punctuation\">;</span><span class=\"token operator\">*</span>\t\t\t\t<span class=\"token comment\">// 目录项数目</span></pre></td></tr></table></figure><h2 id=\"节表区段节区节段等等\"><a class=\"anchor\" href=\"#节表区段节区节段等等\">#</a> 节表（区段，节区，节段等等）</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">IMAGE_SIZEOF_SHORT_NAME</span>              <span class=\"token expression\"><span class=\"token number\">8</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IMAGE_SECTION_HEADER</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">0x00</span> BYTE Name<span class=\"token punctuation\">[</span>IMAGE_SIZEOF_SHORT_NAME<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">union</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">0x08</span> DWORD PhysicalAddress<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">0x08</span> DWORD VirtualSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span> Misc<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">0x0c</span> DWORD VirtualAddress<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token number\">0x10</span> DWORD SizeOfRawData<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token number\">0x14</span> DWORD PointerToRawData<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token number\">0x18</span> DWORD PointerToRelocations<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token number\">0x1c</span> DWORD PointerToLinenumbers<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token number\">0x20</span> WORD NumberOfRelocations<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token number\">0x22</span> WORD NumberOfLinenumbers<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token number\">0x24</span> DWORD Characteristics<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>1、  <code>Name</code>  8 个字节 一般情况下是以 &quot;\\0&quot; 结尾的 ASCII 吗字符串来标识的名称，内容可以自定义。</p>\n<p>注意：该名称并不遵守必须以 &quot;\\0&quot; 结尾的规律，如果不是以 &quot;\\0&quot; 结尾，系统会截取 8 个字节的长度进行处理。</p>\n<p>2、  <code>Misc</code>  双字 是该节在没有对齐前的真实尺寸，该值可以不准确。</p>\n<p>3、  <code>VirtualAddress</code>  节区在内存中的偏移地址。加上 ImageBase 才是在内存中的真正地址。</p>\n<p>4、  <code>SizeOfRawData</code>   节在文件中对齐后的尺寸。</p>\n<p>5、  <code>PointerToRawData</code>  节区在文件中的偏移。</p>\n<p>6、  <code>PointerToRelocations</code>  在 obj 文件中使用。 对 exe 无意义。</p>\n<p>7、  <code>PointerToLinenumbers</code>  行号表的位置 调试的时候使用。</p>\n<p>8、  <code>NumberOfRelocations</code>  在 obj 文件中使用  对 exe 无意义。</p>\n<p>9、  <code>NumberOfLinenumbers</code>  行号表中行号的数量 调试的时候使用。</p>\n<p>10、  <code>Characteristics</code>  节的属性。</p>\n<h1 id=\"个人笔记\"><a class=\"anchor\" href=\"#个人笔记\">#</a> 个人笔记</h1>\n<p>BYTE 是字节的意思，字节是计算机存储容量的基本单位，一个字节由 8 位二进制数组成。<br />\nbit 是位的意思，位是计算机中存储数据的最小单位，指二进制数中的一个位数，其值为 “0” 或 “1”</p>\n<pre><code>WORD = 2 * BYTE = 16 bit\n\nDWORD = 2 * WORD = 4 * BYTE = 32 bit\n\nQWORD = 2 * WDORD = 4 * WORD = 8 * BYTE = 64 bit\n</code></pre>\n<p>一个 BYTE 以十六进制显示，是一个 2 位十六进制数.<br />\n 一个 WORD 以十六进制显示，是一个 4 位十六进制数.<br />\n 一个 DWORD 以十六进制显示，是一个 8 位十六进制数.<br />\n 一个 QWORD 以十六进制显示，是一个 16 位十六进制数.</p>\n<h2 id=\"看pe文件查找重要信息的位置\"><a class=\"anchor\" href=\"#看pe文件查找重要信息的位置\">#</a> 看 PE 文件，查找重要信息的位置</h2>\n<ul>\n<li>查找 PE 结构的各个位置\n<ul>\n<li>\n<p>DOS 头 -&gt;NT 头<br />\n直接看 0x3c 到 0x3f 的数据，这个值是 PE 标识符的位置，既_IMAGE_NT_HEADER（NT 头）结构中的 Signature，为 50 45 既 ASCII 码字符 PE</p>\n</li>\n<li>\n<p>NT 头中的_IMAGE_FILE_HEADER FileHeader<br />\nNT 头往后查 0x06（0d06），0x06 与 0x07 记录着节区的个数，如果要新增节或者合并节 就要修改这个值。<br />\nNT 头往后查 0x14（0d20）, 0x14 与 0x15 记录着可选 PE 头的大小<br />\n NT 头往后查 0x18（0d24），就是 _IMAGE_OPTIONAL_HEADER（可选 PE 头）的开始</p>\n</li>\n<li>\n<p>NT 头中的_IMAGE_OPTIONAL_HEADER</p>\n<ul>\n<li>+0x00\tWORD    Magic;   说明文件类型：0x010B 32 位下的 PE 文件     0x20B 64 位下的 PE 文件</li>\n<li>+0x10\tDWORD   AddressOfEntryPoint;\t程序入口</li>\n<li>+0x1C\tDWORD   ImageBase;\t\t        内存镜像基址</li>\n<li>+0x20\tDWORD   SectionAlignment;\t\t内存对齐</li>\n<li>+0x24\tDWORD   FileAlignment;\t\t\t文件对齐</li>\n<li>+0x38\tDWORD   SizeOfImage;\t\t\t内存中整个 PE 文件的映射的尺寸，可以比实际的值大，但必须是 SectionAlignment 的整数倍</li>\n<li>+0x3C\tDWORD   SizeOfHeaders;\t\t\t所有头 + 节表按照文件对齐后的大小，否则加载会出错</li>\n</ul>\n</li>\n<li>\n<p>节表</p>\n<ul>\n<li>位置查找：直接找 NT 头，往后查找 0x14 个字节，记下这里的可选 PE 头的大小。<br />\n从 NT 头开头往后查找 0x18 + 记下的 PE 头的大小，这里就是第一个节表的位置。</li>\n<li>每一个节表的大小为 40 字节。</li>\n<li>+0x00        Name             节表的名字 8 个字节</li>\n<li>+0x0C DWORD  VirtualAddress   节区在内存中的偏移地址。加上 ImageBase 才是在内存中的真正地址</li>\n<li>+0x10 DWORD  SizeOfRawData    节在文件中对齐后的大小</li>\n<li>+0x14 DWORD  PointerToRawData 节区在文件中的偏移</li>\n<li>+0x24 DWORD  Characteristics  节的属性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>2020 年 11 月 26 日 21:00:35</p>\n<h2 id=\"真正的程序入口\"><a class=\"anchor\" href=\"#真正的程序入口\">#</a> 真正的程序入口</h2>\n<p><code>2021年5月2日17:16:32</code></p>\n<ul>\n<li>0x10\tDWORD   AddressOfEntryPoint;\t程序入口\n<ul>\n<li>0x1C\tDWORD   ImageBase;\t\t        内存镜像基址</li>\n</ul>\n</li>\n</ul>\n<p>AddressOfEntryPoint 只是相对 ImageBase 的偏移。</p>\n<p>真正的程序开始的地方是 <code>ImageBase + AddressOfEntryPoint</code> <br />\n 这也是 OD 开始断的地方。</p>\n",
            "tags": [
                "PE结构",
                "DOS头属性说明",
                "标准PE头属性说明",
                "扩展PE头属性说明",
                "节表属性说明"
            ]
        }
    ]
}