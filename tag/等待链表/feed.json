{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"等待链表\" tag",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/Core/WindowsXp/Process-Thread/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8%E4%B8%8E%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/",
            "url": "https://or0kit.github.io/Bin/Core/WindowsXp/Process-Thread/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8%E4%B8%8E%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/",
            "title": "进程与线程-等待链表与调度链表",
            "date_published": "2022-01-11T08:43:18.000Z",
            "content_html": "<h1 id=\"楔子\"><a class=\"anchor\" href=\"#楔子\">#</a> 楔子</h1>\n<p>进程结构体 EPROCESS (0x50 和 0x190) 是 2 个链表，里面圈着当前进程所有的线程。</p>\n<p>对进程断链，程序可以正常运行，原因是 CPU 执行与调度是以线程为单位的，进程断链只是影响一些遍历系统进程的 API，并不会影响程序执行。</p>\n<p>对线程断链也是一样的，断链后在 Windbg 或者 OD 中无法看到被断掉的线程，但并不影响其执行 (仍然再跑)。</p>\n<p>为什么程序还可以跑呢？</p>\n<p>肯定是操作系统找到线程的表不是我们断掉的这个。<br />\n接下来我们就要了解操作系统的等待链表与调度链表了，在此之前回顾一下计操相关的知识。</p>\n<h1 id=\"线程的三种状态\"><a class=\"anchor\" href=\"#线程的三种状态\">#</a> 线程的三种状态</h1>\n<h2 id=\"wait-等待-挂起-阻塞\"><a class=\"anchor\" href=\"#wait-等待-挂起-阻塞\">#</a> wait (等待、挂起、阻塞……)</h2>\n<p>导致线程等待的原因有多种，例如调用了 Sleep, WaitForSingleObject 等函数，或者在创建时和运行时让线程挂起的 API，例如 SuspendThread 函数。</p>\n<p>等待线程存储在等待链表头 KiWaitListHead 中， KiWaitListHead 是一个全局变量，在 Windbg 中查看：</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kd&gt; dd KiWaitListHead</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>8055d4a8  8a18ce00 8a06d858</pre></td></tr></table></figure><p>0x80553d88 存储了 KiWaitListHead ，这是一个 _LIST_ENTRY，它属于某个线程 _KTHREAD + 0x60 的位置。</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>+0x060 WaitListEntry    : _LIST_ENTRY</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   +0x060 SwapListEntry    : _SINGLE_LIST_ENTRY</pre></td></tr></table></figure><p>_KTHREAD + 0x60 是一个共用体 union，线程处于等待或者调度状态就会存到这个位置的链表里，如果是等待状态，这个地方就是等待链表；如果是调度状态，这里就是调度链表。</p>\n<h2 id=\"running运行中\"><a class=\"anchor\" href=\"#running运行中\">#</a> running（运行中）</h2>\n<p>一个核只有一个运行中的线程，运行中的线程存储在 KPCR 中。</p>\n<h2 id=\"ready就绪等待调度\"><a class=\"anchor\" href=\"#ready就绪等待调度\">#</a> ready（就绪，等待调度）</h2>\n<p>所有就绪线程根据 32 个不同的优先级，各自存储在 32 个链表中。</p>\n<p>通过全局变量  <code>KiDispatcherReadyListHead</code>  可以查看这 32 个链表的链表头：</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kd&gt; dd KiDispatcherReadyListHead L70</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>8055df80  8055df80 8055df80 8055df88 8055df88</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>8055df90  8055df90 8055df90 8055df98 8055df98</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>8055dfa0  8055dfa0 8055dfa0 8055dfa8 8055dfa8</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>8055dfb0  8055dfb0 8055dfb0 8055dfb8 8055dfb8</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>8055dfc0  8055dfc0 8055dfc0 8055dfc8 8055dfc8</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>8055dfd0  8055dfd0 8055dfd0 8055dfd8 8055dfd8</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>8055dfe0  8055dfe0 8055dfe0 8055dfe8 8055dfe8</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>8055dff0  8055dff0 8055dff0 8055dff8 8055dff8</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>8055e000  8055e000 8055e000 8055e008 8055e008</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>8055e010  8055e010 8055e010 8055e018 8055e018</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>8055e020  8055e020 8055e020 8055e028 8055e028</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>8055e030  8055e030 8055e030 8055e038 8055e038</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>8055e040  8055e040 8055e040 8055e048 8055e048</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>8055e050  8055e050 8055e050 8055e058 8055e058</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>8055e060  8055e060 8055e060 8055e068 8055e068</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>8055e070  8055e070 8055e070 8055e078 8055e078</pre></td></tr></table></figure><p>每两个 4 字节就构成了一个 LIST_ENTRY，我们发现这里 32 个链表都是空的，原因是现在 windbg 把系统挂起了，所有线程都处于等待状态，不能被调度了。</p>\n<p>32 个链表对应 32 个优先级 0-31，默认优先级是 8，优先级越高越优先。我推测空闲线程 IdleThread 的优先级是最低的。</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>那些所谓的进程隐藏、线程隐藏都不可能彻底隐藏起来，比拼的是谁更底层罢了。通过遍历这两个链表就可以找到所有进程和线程了。一旦把这两个链表断链，那么进程和线程就不会被操作系统维护，也就不会运行了。</p>\n",
            "tags": [
                "等待链表",
                "调度链表"
            ]
        }
    ]
}