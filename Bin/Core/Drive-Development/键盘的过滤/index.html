<!-- build time:Wed Mar 22 2023 00:57:29 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Or0kit" href="https://or0kit.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Or0kit" href="https://or0kit.github.io/atom.xml"><link rel="alternate" type="application/json" title="Or0kit" href="https://or0kit.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="键盘过滤,PDO,Windows中从击键到内核的过程,KEYBOARD_INPUT_DATA结构,IRP完成回调函数"><link rel="canonical" href="https://or0kit.github.io/Bin/Core/Drive-Development/%E9%94%AE%E7%9B%98%E7%9A%84%E8%BF%87%E6%BB%A4/"><title>键盘的过滤 - 驱动开发 - 内核学习 - 逆向 | Or0kit = Or0kit</title><meta name="generator" content="Hexo 5.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">键盘的过滤</h1><div class="meta"><span class="item" title="创建时间：2022-07-12 23:11:27"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-07-12T23:11:27+08:00">2022-07-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>14k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>13 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Or0kit</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://storage.live.com/items/70930153B02A575!381?authkey=AGDHHD5Qh4Y5OtQ"></li><li class="item" data-background-image="http://storage.live.com/items/70930153B02A575!383?authkey=AGDHHD5Qh4Y5OtQ"></li><li class="item" data-background-image="http://storage.live.com/items/70930153B02A575!366?authkey=AGDHHD5Qh4Y5OtQ"></li><li class="item" data-background-image="http://storage.live.com/items/70930153B02A575!295?authkey=AGDHHD5Qh4Y5OtQ"></li><li class="item" data-background-image="http://storage.live.com/items/70930153B02A575!393?authkey=AGDHHD5Qh4Y5OtQ"></li><li class="item" data-background-image="http://storage.live.com/items/70930153B02A575!297?authkey=AGDHHD5Qh4Y5OtQ"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Bin/" itemprop="item" rel="index" title="分类于 逆向"><span itemprop="name">逆向</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Bin/Core/" itemprop="item" rel="index" title="分类于 内核学习"><span itemprop="name">内核学习</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Bin/Core/Drive-Development/" itemprop="item" rel="index" title="分类于 驱动开发"><span itemprop="name">驱动开发</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://or0kit.github.io/Bin/Core/Drive-Development/%E9%94%AE%E7%9B%98%E7%9A%84%E8%BF%87%E6%BB%A4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Or0kit"><meta itemprop="description" content=", 临渊羡鱼，不如退而结网"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Or0kit"></span><div class="body md" itemprop="articleBody"><h1 id="键盘过滤"><a class="anchor" href="#键盘过滤">#</a> 键盘过滤</h1><p>键盘过滤可以用来做什么？</p><p>恶意程序会用很多方法结果键盘消息，我们可以使用过滤键盘的驱动进行保护。</p><h1 id="技术原理"><a class="anchor" href="#技术原理">#</a> 技术原理</h1><p>了解编写键盘驱动相关的知识。</p><h2 id="预备知识"><a class="anchor" href="#预备知识">#</a> 预备知识</h2><p>了解什么是 PDO、Windows 中从击键到内核的过程、键盘的硬件原理。</p><h3 id="pdo"><a class="anchor" href="#pdo">#</a> PDO</h3><p>何为 PDO？前面解释过 <code>DO</code> 是 <code>Device Object</code> 的简称， <code>PDO</code> 是 <code>Phsiycal Device Object</code> 的简称，字面上的意义是物理设备。读者暂时可以这样理解：<strong>PDO 是设备栈最下面的那个设备对象。</strong> 这个理解并不精确，但是很实用。</p><h3 id="windows中从击键到内核"><a class="anchor" href="#windows中从击键到内核">#</a> Windows 中从击键到内核</h3><p>了解 Windows 是是如何获得按键的，然后传递给各应用程序。</p><p>在任务管理器中，查看 <code>csrss.exe</code> 进程：</p><p><img data-src="image001.png" alt=""></p><p><code>Csrss.exe</code> 进程有一个线程叫做 <code>win32!RawInputThread</code> ，这个线程通过一个 <code>GUID(GUID_CLASS_KEYBOARD)</code> 来获得键盘设备栈的 <code>PDO</code> 符号链接名。</p><p><code>Win32k!RawInputThread</code> 执行到函数 <code>win32k!OpenDevice</code> , 它的一个参数可以找到键盘设备栈的 PDO 的符号链接名。</p><p><code>Win32k!OpenDevice</code> 有一个 <code>OBJECT_ATTRIBUTES</code> 结构的局部变量，它自己初始化这个局部变量，用传入参数中的键盘设备栈的 <code>PDO</code> 的符号链接名赋值 <code>OBJECT_ATTRIBUTES+0x8</code> 处的 <code>PUNICODE_STRING ObjectName</code> 。</p><p>然后，调用 <code>ZwCreateFile</code> ， <code>ZwCreateFile</code> 完成打开设备的工作，最后通过传入的参数返回得到的句柄。 <code>Win32k!RawInputThread</code> 把得到的句柄保存起来，供后面的 <code>ReadFile</code> ， <code>DeviceIoControl</code> 等使用。</p><p><code>win32k!RawInputThread</code> 在获得了句柄之后，会以这个句柄为参数，调用 <code>nt!ZwReadFile</code> ，向键盘驱动要求读入数据。 <code>nt!ZwReadFile</code> 会创建一个 <code>IRP_MJ_READ</code> 的 IRP 发给键盘驱动，告诉键盘驱动要求读入数据。键盘驱动通常会使这个 <code>IRP Pending</code> ，即 <code>IRP_MJ_READ</code> 不被满足，它会一直被放在那里，等待来自键盘的数据。而发出这个读请求的线程 <code>win32k!RawInputThread</code> 也会等待，等待这个读操作的完成。</p><p>当键盘上有键被按下时，将触发键盘的中断，引起中断服务例程的执行，键盘中断的中断服务例程由键盘驱动提供。键盘驱动从端口读取扫描码，经过一系列的处理之后，把从键盘得到的数据交给 IRP，最后结束这个 IRP。这个 IRP 的结束，将导致 <code>win32k!RawInputThread</code> 线程对这个读操作的等待结束。 <code>win32k!RawInputThread</code> 线程将会对得到的数据做出处理，分发给合适的进程。一旦把输入数据处理完之后， <code>win32k!RawInputThread</code> 线程就会立刻再调用一个 <code>nt!ZwReadFile</code> ，向键盘驱动要求读入数据。于是又开始一个等待，等待键盘上的键被按下。</p><p>简单地说， <code>win32k!RawInputThread</code> 线程总是调用 <code>nt!ZwReadFile</code> 函数要求读入数据，然后等待键盘上的键被按下。当键盘上的键被按下时， <code>win32k!RawInputThread</code> 处理 <code>nt!ZwReadFile</code> 得到的数据，然后 <code>nt!ZwReadFile</code> 要求读入数据，再等待键盘上的键被按下。</p><p>我们一般看到的 <code>PS/2</code> 键盘的设备栈，如果自己没有另外安装其他键盘过滤程序，那么设备栈的情况是这样的：</p><p>最顶层的设备对象是驱动 <code>KbdClass</code> 生成的设备对象。<br>中间层的设备对象是驱动 <code>i8042prt</code> 生成的设备对象。<br>最底层的设备对象是驱动 <code>ACPI</code> 生成的设备对象。</p><p>原理到这里就讲完了。这段描述似乎令人眼花缭乱，但是我们没有必要非常关心其细节，<strong>只要知道我们现在要去绑定的那个设备就是驱动 <code>KbdClass</code> 的设备对象就可以了</strong></p><h3 id="键盘硬件原理"><a class="anchor" href="#键盘硬件原理">#</a> 键盘硬件原理</h3><p>从键盘被敲击到计算机屏幕上出现一个字符，中间有很多复杂的变换。</p><p>一个字符显然并不代表一个键，因为大写和小写的字母是同一个键，只是根据 Shift 键来决定是大写还是小写字母。此外还有许多复杂的功能键，如 Ctrl、Alt 键，另外还有小键盘等。所以键并不用字符来代表，而是给每个键规定了一个扫描码。<strong>键盘驱动程序会读取扫描码并翻译成正确的动作</strong>，但是并非放之所有的键盘而皆准。我们应该知道每个键都对应着扫描码。</p><p>键盘和 CPU 的交互方式是中断和读取端口，这个操作是串行的。发生一次中断，就等于键盘给了 CPU 一次通知，这个通知只能通知一个事件：某个键被按下了，某个键弹起来了。我们可能会以为在按下一个字母键时，CPU 可能会去读取 Shift 键的状态，看应该是大写还是小写字母，结果却完全不是这样的。CPU 只接收通知并读取端口的扫描码，从不主动去 “查看” 任何键。</p><p>为此，一个键实际上需要两个扫描码：一个表示键按下；另一个表示键弹起。根据从网上找到的资料，如果按下的键的扫描码为 X，那么同一个键弹起的扫描码就为 X+0x80。键盘这种设备非常古老，所以貌似 Windosw XP 下端口和中断号都是定死的，即中断号为 0x93，端口为 0x60。每次中断发生时，CPU 都去读取端口 0x60 中的扫描码。0x60 中只保存一个字节，但是扫描码是可以有两个字节的，此时就会发生两次中断，CPU 会先后读到扫描码的两个字节。</p><p>无论如何按键，信息的传递都是一次一个字节串行进行的。</p><h1 id="键盘过滤框架"><a class="anchor" href="#键盘过滤框架">#</a> 键盘过滤框架</h1><p>编写一个键盘过滤驱动框架。</p><h2 id="绑定键盘设备"><a class="anchor" href="#绑定键盘设备">#</a> 绑定键盘设备</h2><p>要过滤一种设备，首先要绑定它。</p><p>现在需要找到所有代表键盘的设备。从前面的原理来看，可以认定的是，如果绑定了驱动 <code>KbdClass</code> 的所有设备对象，那么代表键盘的设备一定在其中。</p><p>现在我们面临的第一个问题是：如何找到一个驱动下的所有设备对象呢？</p><h3 id="获取驱动对象下的所有设备对象"><a class="anchor" href="#获取驱动对象下的所有设备对象">#</a> 获取驱动对象下的所有设备对象</h3><ol><li>直接读取驱动对象下面的 DeviceObject 域。</li></ol><p>一个 <code>DRIVER_OBJECT</code> 下有一个域叫作 <code>DeviceObject</code> ，这看似是一个设备对象的指针，但是由于每个 <code>DeviceObject</code> 中又有一个域叫作 <code>NextDevice</code> ，指向同一个驱动中的下一个设备，所以这里实际上是一个设备链。</p><ol start="2"><li>调用函数 <code>IoEnumerateDeviceObjectList</code> ，这个函数可以枚举出一个驱动下的所有设备。</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>NTSTATUS <span class="token function">IoEnumerateDeviceObjectList</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  PDRIVER_OBJECT DriverObject<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> PDEVICE_OBJECT <span class="token operator">*</span>DeviceObjectList<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  ULONG          DeviceObjectListSize<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> PULONG         ActualNumberDeviceObjects</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>参数</strong><br>[in] <code>DriverObject</code></p><p>指向驱动程序的驱动程序对象的指针。</p><p>[out] <code>DeviceObjectList</code></p><p>指向接收设备对象指针的调用方分配的数组的指针。此参数可以为 NULL。</p><p>[in] <code>DeviceObjectListSize</code></p><p>DeviceObjectList 数组的大小（以字节为单位） 。可以为零。</p><p>[out] <code>ActualNumberDeviceObjects</code></p><p>在驱动程序对象的设备对象列表中找到的设备对象的实际数量。请注意，如果 DeviceObjectList 处的数组太小，则复制到数组中的设备对象指针的数量将少于 ActualNumberDeviceObjects。</p><p><strong>返回值</strong><br>IoEnumerateDeviceObjectList 可以返回以下之一：</p><table><thead><tr><th style="text-align:left">返回码</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">STATUS_SUCCESS</td><td style="text-align:left">对 IoEnumerateDeviceObjectList 的调用成功。</td></tr><tr><td style="text-align:left">STATUS_BUFFER_TOO_SMALL</td><td style="text-align:left">DeviceObjectList 中 的数组太小，无法容纳整个设备对象列表。在这种情况下，IoEnumerateDeviceObjectList 将尽可能多的设备对象指针复制到数组中。</td></tr></tbody></table><p>接下来我们获取键盘的驱动对象。</p><h3 id="获取驱动对象"><a class="anchor" href="#获取驱动对象">#</a> 获取驱动对象</h3><p>我们首先打开驱动对象 <code>KbdClass</code> ，然后绑定它下面的所有设备。</p><p>这里用到一个新的函数 —— <code>ObReferenceObjectByName</code> ，它用于通过一个名字来获得一个对象的指针。</p><p>但是我们需要声明这个未公开的函数，才可以调用它。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">ObReferenceObjectByName</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	IN PUNICODE_STRING ObjectName<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	IN ULONG Attributes<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	IN PACCESS_STATE AccessState OPTIONAL<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	IN ACCESS_MASK DesiredAccess OPTIONAL<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	IN POBJECT_TYPE ObjectType<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	IN KPROCESSOR_MODE AccessMode<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	IN OUT PVOID ParseContext OPTIONAL<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	OUT PVOID<span class="token operator">*</span> Object</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这就不得不提到另一个需要声明的全局变量：</p><p>获取导出全局变量: <code>extern POBJECT_TYPE* IoDriverObjectType;</code> 我在 xp 的源码中看到是这样获取的，有大佬说谭文书上的不对。</p><h3 id="设备扩展"><a class="anchor" href="#设备扩展">#</a> 设备扩展</h3><p>在生成一个过滤设备时，我们可以给这个设备指定一个任意长度的 “设备扩展”，这个扩展中的内容可以任意填写，作为一个自定义的数据结构。</p><p>这样就可以把真实设备的指针保存在设备对象里了，就没有必要像串口过滤的时定义两个数组了。</p><p>在这个键盘过滤中，我们可以专门定义一个结构作为设备扩展，如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 设备扩展</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_DEV_EXT</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token comment">// 结构体大小</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	ULONG ulSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token comment">// 过滤设备对象</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	PDEVICE_OBJECT pFilterDeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">// 绑定的目标设备对象</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	PDEVICE_OBJECT pTargetDeviceObjecct<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">// 返回对象</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	PDEVICE_OBJECT pLowerDeviceObjecct<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">// 自旋锁</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	KSPIN_LOCK IoRequestsSpinLock<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// 事件</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	KEVENT IoInProgressEvent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span>DEV_EXT<span class="token punctuation">,</span> <span class="token operator">*</span> PDEV_EXT<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="绑定设备的代码"><a class="anchor" href="#绑定设备的代码">#</a> 绑定设备的代码</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 获取导出全局变量</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">extern</span> POBJECT_TYPE<span class="token operator">*</span> IoDriverObjectType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 声明未公开函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>NTSTATUS</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">ObReferenceObjectByName</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	IN PUNICODE_STRING ObjectName<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	IN ULONG Attributes<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	IN PACCESS_STATE AccessState OPTIONAL<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	IN ACCESS_MASK DesiredAccess OPTIONAL<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	IN POBJECT_TYPE ObjectType<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	IN KPROCESSOR_MODE AccessMode<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	IN OUT PVOID ParseContext OPTIONAL<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	OUT PVOID<span class="token operator">*</span> Object</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 设备扩展</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_DEV_EXT</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token comment">// 结构体大小</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	ULONG ulSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token comment">// 过滤设备对象</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	PDEVICE_OBJECT pFilterDeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token comment">// 绑定的目标设备对象</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	PDEVICE_OBJECT pTargetDeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token comment">// 返回对象</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	PDEVICE_OBJECT pLowerDeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token comment">// 自旋锁</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	KSPIN_LOCK IoRequestsSpinLock<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">// 事件</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	KEVENT IoInProgressEvent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span>DEV_EXT<span class="token punctuation">,</span> <span class="token operator">*</span> PDEV_EXT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// 绑定设备</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// 获取 KbdClassd 的驱动对象，然后绑定其所有设备对象</span></pre></td></tr><tr><td data-num="35"></td><td><pre>NTSTATUS <span class="token function">kbdAttachDevices</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	IN PDRIVER_OBJECT pDriver<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	IN PUNICODE_STRING pRegPath</pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>	NTSTATUS status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>	UNICODE_STRING uniNtNameString<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>	PDEV_EXT pdevext<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	PDEVICE_OBJECT pFilterDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	PDEVICE_OBJECT pTargetDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>	PDEVICE_OBJECT pLowerDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre>	PDRIVER_OBJECT KbdDriverObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"MyAttach!\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre></pre></td></tr><tr><td data-num="50"></td><td><pre>	<span class="token comment">// 获取 KbdClass 驱动对象</span></pre></td></tr><tr><td data-num="51"></td><td><pre></pre></td></tr><tr><td data-num="52"></td><td><pre>	<span class="token function">RtlInitUnicodeString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uniNtNameString<span class="token punctuation">,</span> KBD_DRIVER_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>	status <span class="token operator">=</span> <span class="token function">ObReferenceObjectByName</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="54"></td><td><pre>		<span class="token operator">&amp;</span>uniNtNameString<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="55"></td><td><pre>		OBJ_CASE_INSENSITIVE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="56"></td><td><pre>		<span class="token operator">*</span>IoDriverObjectType<span class="token punctuation">,</span>		<span class="token comment">// 在 xp 源码中看到就是这样的</span></pre></td></tr><tr><td data-num="57"></td><td><pre>		KernelMode<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="58"></td><td><pre>		<span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>KbdDriverObject</pre></td></tr><tr><td data-num="59"></td><td><pre>	<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">NT_SUCCESS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="61"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>		<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"MyAttach:Couldn't get the [KbdClass DriverObject]\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>		<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>	<span class="token comment">// 解引用</span></pre></td></tr><tr><td data-num="66"></td><td><pre>	<span class="token function">ObDereferenceObject</span><span class="token punctuation">(</span>KbdDriverObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="67"></td><td><pre></pre></td></tr><tr><td data-num="68"></td><td><pre>	<span class="token comment">// 获取 KbdClass 驱动对象下的所有设备对象并绑定</span></pre></td></tr><tr><td data-num="69"></td><td><pre></pre></td></tr><tr><td data-num="70"></td><td><pre>	<span class="token comment">// 设备链中第一个设备</span></pre></td></tr><tr><td data-num="71"></td><td><pre>	pTargetDeviceObject <span class="token operator">=</span> KbdDriverObject<span class="token operator">-></span>DeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre></pre></td></tr><tr><td data-num="73"></td><td><pre>	<span class="token comment">// 遍历设备链</span></pre></td></tr><tr><td data-num="74"></td><td><pre>	<span class="token keyword">while</span> <span class="token punctuation">(</span>pTargetDeviceObject<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="75"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>		<span class="token comment">// 首先生成一个过滤设备</span></pre></td></tr><tr><td data-num="77"></td><td><pre>		status <span class="token operator">=</span> <span class="token function">IoCreateDevice</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="78"></td><td><pre>			IN pDriver<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="79"></td><td><pre>			IN <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DEV_EXT<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="80"></td><td><pre>			IN <span class="token constant">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="81"></td><td><pre>			IN pTargetDeviceObject<span class="token operator">-></span>DeviceType<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="82"></td><td><pre>			IN pTargetDeviceObject<span class="token operator">-></span>Characteristics<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="83"></td><td><pre>			IN FALSE<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="84"></td><td><pre>			OUT <span class="token operator">&amp;</span> pFilterDeviceObject</pre></td></tr><tr><td data-num="85"></td><td><pre>		<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre></pre></td></tr><tr><td data-num="87"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">NT_SUCCESS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="88"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"MyAttach:Couldn't Create Filter Device Object\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>			pFilterDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>			pTargetDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>			<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="94"></td><td><pre></pre></td></tr><tr><td data-num="95"></td><td><pre>		<span class="token comment">// 绑定</span></pre></td></tr><tr><td data-num="96"></td><td><pre>		<span class="token comment">//pLowerDeviceObject 是目标设备 设备栈栈顶的那个设备！</span></pre></td></tr><tr><td data-num="97"></td><td><pre>		status <span class="token operator">=</span> <span class="token function">IoAttachDeviceToDeviceStackSafe</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="98"></td><td><pre>			pFilterDeviceObject<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="99"></td><td><pre>			pTargetDeviceObject<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="100"></td><td><pre>			<span class="token operator">&amp;</span>pLowerDeviceObject</pre></td></tr><tr><td data-num="101"></td><td><pre>		<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="102"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">NT_SUCCESS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="103"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="104"></td><td><pre>			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"MyAtach:Couldn't attach KbdClass Device Object\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="105"></td><td><pre>			<span class="token function">IoDeleteDevice</span><span class="token punctuation">(</span>pFilterDeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="106"></td><td><pre>			pFilterDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="107"></td><td><pre>			<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="108"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="109"></td><td><pre></pre></td></tr><tr><td data-num="110"></td><td><pre>		<span class="token comment">// 设置 设备扩展</span></pre></td></tr><tr><td data-num="111"></td><td><pre>		pdevext <span class="token operator">=</span> <span class="token punctuation">(</span>PDEV_EXT<span class="token punctuation">)</span><span class="token punctuation">(</span>pFilterDeviceObject<span class="token operator">-></span>DeviceExtension<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="112"></td><td><pre>		<span class="token comment">// 初始化设备扩展</span></pre></td></tr><tr><td data-num="113"></td><td><pre>		<span class="token function">DevExtInit</span><span class="token punctuation">(</span>pdevext<span class="token punctuation">,</span> pFilterDeviceObject<span class="token punctuation">,</span> pTargetDeviceObject<span class="token punctuation">,</span> pLowerDeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="114"></td><td><pre></pre></td></tr><tr><td data-num="115"></td><td><pre>		<span class="token comment">// 设置相关属性</span></pre></td></tr><tr><td data-num="116"></td><td><pre>		pFilterDeviceObject<span class="token operator">-></span>DeviceType <span class="token operator">=</span> pLowerDeviceObject<span class="token operator">-></span>DeviceType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="117"></td><td><pre>		pFilterDeviceObject<span class="token operator">-></span>Characteristics <span class="token operator">=</span> pLowerDeviceObject<span class="token operator">-></span>Characteristics<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="118"></td><td><pre>		pFilterDeviceObject<span class="token operator">-></span>StackSize <span class="token operator">=</span> pLowerDeviceObject<span class="token operator">-></span>StackSize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="119"></td><td><pre>		pFilterDeviceObject<span class="token operator">-></span>Flags <span class="token operator">|=</span> pLowerDeviceObject<span class="token operator">-></span>Flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>DO_BUFFERED_IO <span class="token operator">|</span> DO_DIRECT_IO <span class="token operator">|</span> DO_POWER_PAGABLE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="120"></td><td><pre></pre></td></tr><tr><td data-num="121"></td><td><pre>		<span class="token comment">// 获取下一个设备对象</span></pre></td></tr><tr><td data-num="122"></td><td><pre>		pTargetDeviceObject <span class="token operator">=</span> pTargetDeviceObject<span class="token operator">-></span>NextDevice<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="123"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="124"></td><td><pre>	<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="125"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="键盘过滤模块的driverentry"><a class="anchor" href="#键盘过滤模块的driverentry">#</a> 键盘过滤模块的 DriverEntry</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 入口函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre>NTSTATUS <span class="token function">DriverEntry</span><span class="token punctuation">(</span>PDRIVER_OBJECT pDriver<span class="token punctuation">,</span> PUNICODE_STRING pRegPath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	NTSTATUS status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	ULONG i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"我是驱动,我运行了\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">// 设置分发函数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> IRP_MJ_MAXIMUM_FUNCTION<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		pDriver<span class="token operator">-></span>MajorFunction<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> myDispatch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// 单独填写一个 IRP_MJ_POWER 函数， 因为重要的过滤就是读取来的按键信息，其他的都不重要</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	pDriver<span class="token operator">-></span>MajorFunction<span class="token punctuation">[</span>IRP_MJ_READ<span class="token punctuation">]</span>  <span class="token operator">=</span> myReadDispatch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token comment">// 单独写一个 IRP_MJ_POWER 函数</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	pDriver<span class="token operator">-></span>MajorFunction<span class="token punctuation">[</span>IRP_MJ_POWER<span class="token punctuation">]</span> <span class="token operator">=</span> myPowerDispatch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token comment">// PNP (即插即用) 我们要知道什么时候一个绑定过的设备被卸载（比如从机器上拔掉）</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	pDriver<span class="token operator">-></span>MajorFunction<span class="token punctuation">[</span>IRP_MJ_PNP<span class="token punctuation">]</span> <span class="token operator">=</span> myPNPDispatch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token comment">// 卸载函数</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	pDriver<span class="token operator">-></span>DriverUnload <span class="token operator">=</span> myDriverUnload<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token comment">// 绑定所有的键盘设备</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	status <span class="token operator">=</span> <span class="token function">kbdAttachDevices</span><span class="token punctuation">(</span>pDriver<span class="token punctuation">,</span> pRegPath<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="键盘过滤模块的动态卸载"><a class="anchor" href="#键盘过滤模块的动态卸载">#</a> 键盘过滤模块的动态卸载</h2><p>键盘过滤模块的动态卸载和前面的串口过滤稍有不同，这是因为键盘总是处于 “有一个读请求没有完成” 的状态。</p><p>“当键盘上有键被按下时，将触发键盘的中断，引起中断服务例程的执行，键盘中断的中断服务例程由键盘驱动提供。键盘驱动从端口读取扫描码，经过一系列的处理之后，把从键盘得到的数据交给 IRP，然后结束这个 IRP。这个 IRP 的结束，将导致 <code>win32k!RawInputThread</code> 线程对这个读操作的等待结束。 <code>win32k!RawInputThread</code> 线程将会对得到的数据做出处理，分发给合适的进程。一旦把输入数据处理完之后， <code>win32k!RawInputThread</code> 线程会立刻再调用一个 <code>nt!ZwReadFile</code> ，向键盘驱动要求读入数据。于是又开始一个等待，等待键盘上的键被按下。”</p><p>换句话说，就算类似于串口驱动一样等待 5 秒，这个请求也未必会完成（如果没有按键的话）。这样如果卸载了过滤驱动，那么等下次一按键，这个请求就被处理，很可能马上就蓝屏崩溃了。</p><p>下面是对实际中动态卸载的处理。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 解除绑定并删除设备</span></pre></td></tr><tr><td data-num="2"></td><td><pre>VOID <span class="token function">c2pDetach</span><span class="token punctuation">(</span>IN PDEVICE_OBJECT pDeviceObject<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	PDEV_EXT devExt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	BOOLEAN NoRequestsOutstanding <span class="token operator">=</span> FALSE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	devExt <span class="token operator">=</span> <span class="token punctuation">(</span>PDEV_EXT<span class="token punctuation">)</span>pDeviceObject<span class="token operator">-></span>DeviceExtension<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	__try</pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		__try</pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>			<span class="token function">IoDetachDevice</span><span class="token punctuation">(</span>devExt<span class="token operator">-></span>pTargetDeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>			devExt<span class="token operator">-></span>pTargetDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>			<span class="token function">IoDeleteDevice</span><span class="token punctuation">(</span>pDeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>			devExt<span class="token operator">-></span>pFilterDeviceObject <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Detach Finished\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token function">__except</span> <span class="token punctuation">(</span>EXCEPTION_EXECUTE_HANDLER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	__finally <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">// 卸载函数</span></pre></td></tr><tr><td data-num="24"></td><td><pre>VOID <span class="token function">myDriverUnload</span><span class="token punctuation">(</span>PDRIVER_OBJECT pDriver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	PDEVICE_OBJECT pDeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	PDEVICE_OBJECT OldDeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	PDEV_EXT pdevext<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>	LARGE_INTEGER lDelay<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	PRKTHREAD CurrentThread<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>	lDelay <span class="token operator">=</span> <span class="token function">RtlConvertLongToLargeInteger</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> DELAY_ONE_MILLISECOND<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>	CurrentThread <span class="token operator">=</span> <span class="token function">KeGetCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token comment">// 把当前线程设置为低实时模式，一遍让它的运行尽量少影响其他程序</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token function">KeSetPriorityThread</span><span class="token punctuation">(</span>CurrentThread<span class="token punctuation">,</span> LOW_REALTIME_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>	<span class="token comment">// UNREFERENCED_PARAMETER(pDriver);</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"DriverEntry unload..\t\n."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>	<span class="token comment">// 遍历所有设备并一律解除绑定</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	pDeviceObject <span class="token operator">=</span> pDriver<span class="token operator">-></span>DeviceObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	<span class="token keyword">while</span> <span class="token punctuation">(</span>pDeviceObject<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>		<span class="token comment">// 解除绑定并删除设备</span></pre></td></tr><tr><td data-num="47"></td><td><pre>		<span class="token function">c2pDetach</span><span class="token punctuation">(</span>pDeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span>	</pre></td></tr><tr><td data-num="48"></td><td><pre>		pDeviceObject<span class="token operator">-></span>NextDevice<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre></pre></td></tr><tr><td data-num="51"></td><td><pre>	<span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> DriverObject<span class="token operator">-></span>DeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>	<span class="token keyword">while</span> <span class="token punctuation">(</span>gC2pKeyCount<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>		<span class="token comment">// 睡眠 1 毫秒</span></pre></td></tr><tr><td data-num="56"></td><td><pre>		<span class="token function">KeDelayExecutionThread</span><span class="token punctuation">(</span>KernelMode<span class="token punctuation">,</span> FALSE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lDelay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"我是驱动，我卸载了\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>	<span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里的防止未决请求没有完成的方法就是使用 <code>gC2pKeyCount</code> 。</p><p><code>gC2pKeyCount</code> 在这里是一个全局变量，每次有一个读请求到来时， <code>gC2pKeyCount</code> 被加 1；每次完成时，则减 1。于是只有所有请求都完成后，才结束等待；否则就无休止地等待下去。</p><p><strong>实际上，只有一个键被按下时，这个卸载过程才结束。</strong></p><h2 id="键盘过滤的请求处理"><a class="anchor" href="#键盘过滤的请求处理">#</a> 键盘过滤的请求处理</h2><p>在 <code>DriverEntry</code> 中我们设置了相关的分发函数，在这里我们来逐个实现这些函数。</p><h3 id="通常的处理"><a class="anchor" href="#通常的处理">#</a> 通常的处理</h3><p>最通常的处理就是直接发送到真实设备，跳过虚拟设备的处理。这和前面串口过滤用过的方法一样。代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 普通分发函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre>NTSTATUS <span class="token function">myDispatch</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	IN PDEVICE_OBJECT pDevice<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	IN PIRP irp</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token comment">//	其他的分发函数，直接 skip，然后用 IoCallDriver 把 IRP 发送到真实设备的设备对象上</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"Other Disapatch!\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token function">IoSkipCurrentIrpStackLocation</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">return</span> <span class="token function">IoCallDriver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PDEV_EXT<span class="token punctuation">)</span>pDevice<span class="token operator">-></span>DeviceExtension<span class="token punctuation">)</span><span class="token operator">-></span>pLowerDeviceObject<span class="token punctuation">,</span> irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="pnp的处理"><a class="anchor" href="#pnp的处理">#</a> PNP 的处理</h3><p>唯一需要处理的是，当有一个设备被拔出时，解除绑定并删除过滤设备。代码的实现大致如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// PNP 处理</span></pre></td></tr><tr><td data-num="2"></td><td><pre>NTSTATUS <span class="token function">myPNPDispatch</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	IN PDEVICE_OBJECT pDevice<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	IN PIRP irp</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	PDEV_EXT pdevext<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	PIO_STACK_LOCATION pIrpStack<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	NTSTATUS status <span class="token operator">=</span> STATUS_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	KIRQL oldIrql<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	KEVENT event<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token comment">// 获取这真实设备</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	pdevext <span class="token operator">=</span> <span class="token punctuation">(</span>PDEV_EXT<span class="token punctuation">)</span><span class="token punctuation">(</span>pDevice<span class="token operator">-></span>DeviceExtension<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	pIrpStack <span class="token operator">=</span> <span class="token function">IoGetCurrentIrpStackLocation</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token comment">// 获取次功能号</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">switch</span> <span class="token punctuation">(</span>pIrpStack<span class="token operator">-></span>MinorFunction<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token keyword">case</span> IRP_MN_REMOVE_DEVICE<span class="token operator">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>		<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"IRP_MN_REMOVE_DEVICE\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		<span class="token comment">// 首先把请求发下去</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token function">IoSkipCurrentIrpStackLocation</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>		<span class="token function">IoCallDriver</span><span class="token punctuation">(</span>pdevext<span class="token operator">-></span>pLowerDeviceObject<span class="token punctuation">,</span> irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>		<span class="token comment">// 然后接触绑定</span></pre></td></tr><tr><td data-num="26"></td><td><pre>		<span class="token function">IoDetachDevice</span><span class="token punctuation">(</span>pdevext<span class="token operator">-></span>pLowerDeviceObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>		<span class="token comment">// 删除我们生成的虚拟设备</span></pre></td></tr><tr><td data-num="28"></td><td><pre>		<span class="token function">IoDeleteDevice</span><span class="token punctuation">(</span>pDevice<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>		status <span class="token operator">=</span> STATUS_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>	<span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="34"></td><td><pre>		<span class="token comment">// 对于其他类型的 IRP，全部直接下发即可</span></pre></td></tr><tr><td data-num="35"></td><td><pre>		<span class="token function">IoSkipCurrentIrpStackLocation</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>		status <span class="token operator">=</span> <span class="token function">IoCallDriver</span><span class="token punctuation">(</span>pdevext<span class="token operator">-></span>pLowerDeviceObject<span class="token punctuation">,</span> irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>		<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>	<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当 PNP 请求过来时，是没有必要担心还有未完成的 IRP 的。<br>这是因为 Windows 系统要求卸载设备，此时 Windows 自己应该已经处理掉了所有未决的 IRP。</p><p>这是和我们自己要求卸载过滤驱动不同的地方。</p><h3 id="读的处理"><a class="anchor" href="#读的处理">#</a> 读的处理</h3><p>前面见过的所有请求，都是处理完毕之后，直接发送到下层驱动之后就不管了。但是在处理键盘读请求时，这样做是不行的。</p><p>当一个读请求到来时，只是说 Windows 要从键盘驱动读取一个键扫描码值，但是在完成之前显然并不清楚这个值到底是多少。<br>我们要过滤的目的，就是要获得按下了什么键，所以不得不换一种处理方法，<strong>就是把这个请求下发完成之后，再去看这个值是多少。</strong></p><p>要完成请求，可以采用如下的步骤。</p><p>（1）调用 <code>IoCopyCurrentIrpStackLocationToNext</code> 把当前 IRP 栈空间拷贝到下一个栈空间（这和前面的调用 <code>IoSkipCurrentIrpStackLocation</code> 跳过当前栈空间形成对比）。<br>（2）给这个 IRP 设置一个完成函数。完成函数的含义是，如果这个 IRP 完成了，系统就会回调这个函数。<br>（3）调用 <code>IoCallDriver</code> 把请求发送到下一个设备</p><p>另外一个需要解决的问题就是我们前面所需要的一个键计数器。</p><p>即一个请求到来时，我们把全局变量 <code>gC2pKeyCount</code> 加 1，等完成之后再减 1。这个处理比较简单。</p><p>完整的读处理请求如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 读请求</span></pre></td></tr><tr><td data-num="2"></td><td><pre>NTSTATUS <span class="token function">myReadDispatch</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	IN PDEVICE_OBJECT pDevice<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	IN PIRP irp</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	NTSTATUS status <span class="token operator">=</span> STATUS_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	PDEV_EXT pdevext<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	PIO_STACK_LOCATION pIrpStack<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	KEVENT waitevent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token function">KeInitializeEvent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waitevent<span class="token punctuation">,</span> NotificationEvent<span class="token punctuation">,</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// 判断是否到达了 irp 栈的最低端</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>irp<span class="token operator">-></span>CurrentLocation <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		ULONG ReturnedInformation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"Dispatach encountered bogus current location\t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		status <span class="token operator">=</span> STATUS_INVALID_DEVICE_REQUEST<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>		irp<span class="token operator">-></span>IoStatus<span class="token punctuation">.</span>Status <span class="token operator">=</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>		irp<span class="token operator">-></span>IoStatus<span class="token punctuation">.</span>Information <span class="token operator">=</span> ReturnedInformation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		<span class="token function">IoCompleteRequest</span><span class="token punctuation">(</span>irp<span class="token punctuation">,</span> IO_NO_INCREMENT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token keyword">return</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token comment">// 全局变量键计数器加 1</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	gC2pKeyCount<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token comment">// 得到设备扩展，目的是为了获得下一个设备的指针</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	pdevext <span class="token operator">=</span> <span class="token punctuation">(</span>PDEV_EXT<span class="token punctuation">)</span>pDevice<span class="token operator">-></span>DeviceExtension<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>	<span class="token comment">// 设置回调函数并把 IRP 传递下去。之后读的处理也就结束了。剩下的任务是等待读请求完成</span></pre></td></tr><tr><td data-num="33"></td><td><pre>	pIrpStack <span class="token operator">=</span> <span class="token function">IoGetCurrentIrpStackLocation</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	<span class="token comment">// 复制当前 IRP 栈空间</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token function">IoCopyCurrentIrpStackLocationToNext</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token comment">// 设置完成回调函数</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	<span class="token function">IoSetCompletionRoutine</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="38"></td><td><pre>		irp<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="39"></td><td><pre>		myReadComplete<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="40"></td><td><pre>		pDevice<span class="token punctuation">,</span> TRUE<span class="token punctuation">,</span> TRUE<span class="token punctuation">,</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>	<span class="token keyword">return</span> <span class="token function">IoCallDriver</span><span class="token punctuation">(</span>pdevext<span class="token operator">-></span>pLowerDeviceObject<span class="token punctuation">,</span> irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="读完成的处理"><a class="anchor" href="#读完成的处理">#</a> 读完成的处理</h3><p><strong>读请求完成之后，应该获得输出缓冲区，按键信息就在输出缓冲区中，区局变量 <code>gC2pKeyCount</code> 应该减 1。</strong></p><p>如何在缓冲区中获取按键信息呢？ 还需要了解一种数据结构</p><h4 id="keyboard_input_data结构"><a class="anchor" href="#keyboard_input_data结构">#</a> KEYBOARD_INPUT_DATA 结构</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_KEYBOARD_INPUT_DATA</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  USHORT UnitId<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  USHORT MakeCode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  USHORT Flags<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  USHORT Reserved<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  ULONG  ExtraInformation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> KEYBOARD_INPUT_DATA<span class="token punctuation">,</span> <span class="token operator">*</span>PKEYBOARD_INPUT_DATA<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>UnitId</code></p><p>指定键盘设备的单元号。键盘设备名称的格式为 <code>\Device\KeyboardPort</code>   <em>N</em> ，其中后缀<em> N</em> 是设备的单元号。例如，名称为 <code>\Device\KeyboardPort0</code> 的设备的单元号为 <code>0</code> ，名称为 <code>\Device\KeyboardPort1</code> 的设备的单元号为 <code>1</code> 。</p><p><code>MakeCode</code></p><p>指定与按键关联的扫描代码。</p><p><code>Flags</code></p><p>指定以下一个或多个标志的按位或，这些标志指示键是被按下还是释放，以及其他杂项信息。</p><table><thead><tr><th style="text-align:left">价值</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">KEY_MAKE</td><td style="text-align:left">键被按下。</td></tr><tr><td style="text-align:left">KEY_BREAK</td><td style="text-align:left">键被释放了。</td></tr><tr><td style="text-align:left">KEY_E0</td><td style="text-align:left">用于指示特殊键盘功能的扩展扫描码。</td></tr><tr><td style="text-align:left">KEY_E1</td><td style="text-align:left">用于指示特殊键盘功能的扩展扫描码。</td></tr></tbody></table><p><code>Reserved</code></p><p>保留供操作系统使用。</p><p><code>ExtraInformation</code></p><p>指定与键盘事件关联的设备特定信息。</p><hr><p>至于有多少个这样的结构，则取决于输入缓冲区到底有多长。实际上，这种结构的个数应该为：</p><p><code>keys = (irp-&gt;IoStatus.Information) / sizeof(KEYBOARD_INPUT_DATA);</code></p><h4 id="读完成函数完整代码"><a class="anchor" href="#读完成函数完整代码">#</a> 读完成函数完整代码</h4><p>此外，再没有其他的事情需要完成了。所以相关代码比较简单，大致如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>NTSTATUS <span class="token function">myReadComplete</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	IN PDEVICE_OBJECT pDevice<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	IN PIRP irp<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	IN PVOID Context</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	NTSTATUS status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	PIO_STACK_LOCATION pIrpStack<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	ULONG  keys<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	ULONG buf_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	PKEYBOARD_INPUT_DATA pKeyBoardData<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	</pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token comment">// 获取 IRP 堆栈</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	pIrpStack <span class="token operator">=</span> <span class="token function">IoGetCurrentIrpStackLocation</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token comment">// 判断这个 IRP 是否成功</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">NT_SUCCESS</span><span class="token punctuation">(</span>irp<span class="token operator">-></span>IoStatus<span class="token punctuation">.</span>Status<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token comment">// 获取读请求完成后的输出缓冲区</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		pKeyBoardData <span class="token operator">=</span> irp<span class="token operator">-></span>AssociatedIrp<span class="token punctuation">.</span>SystemBuffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>		<span class="token comment">//irp->IoStatus.Information 其实就是完成信息的大小。得到了按下的键的数量</span></pre></td></tr><tr><td data-num="21"></td><td><pre>		keys <span class="token operator">=</span> <span class="token punctuation">(</span>irp<span class="token operator">-></span>IoStatus<span class="token punctuation">.</span>Information<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>KEYBOARD_INPUT_DATA<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"keys:%d\t\n"</span><span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"numkey:%u\t\n"</span><span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>			<span class="token comment">// 按键码不等于字符</span></pre></td></tr><tr><td data-num="27"></td><td><pre>			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"sancode:%x\t\n"</span><span class="token punctuation">,</span> pKeyBoardData<span class="token operator">-></span>MakeCode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>			<span class="token function">DbgPrint</span><span class="token punctuation">(</span><span class="token string">"%s\t\n"</span><span class="token punctuation">,</span> pKeyBoardData<span class="token operator">-></span>Flags <span class="token operator">?</span> <span class="token string">"Up"</span> <span class="token operator">:</span> <span class="token string">"Down"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>pKeyBoardData<span class="token operator">-></span>MakeCode <span class="token operator">==</span> <span class="token number">0x1f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>				<span class="token comment">// 过滤按键，修改为 0x20 </span></pre></td></tr><tr><td data-num="33"></td><td><pre>				<span class="token comment">// 这里也可以做其他的许多事情：键盘记录等等</span></pre></td></tr><tr><td data-num="34"></td><td><pre>				pKeyBoardData<span class="token operator">-></span>MakeCode <span class="token operator">=</span> <span class="token number">0x20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>			</pre></td></tr><tr><td data-num="37"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>	gC2pKeyCount<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>irp<span class="token operator">-></span>PendingReturned<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>		<span class="token function">IoMarkIrpPending</span><span class="token punctuation">(</span>irp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre>	<span class="token keyword">return</span> irp<span class="token operator">-></span>IoStatus<span class="token punctuation">.</span>Status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里的读完成函数我们只是简单的打印了<strong>对应每次按键信息</strong>的结构体 <code>KEYBOARD_INPUT_DATA</code> 中的成员，并且把所有 <code>MakeCode</code> 值为 <code>0x1f</code> 修改为了 <code>0x20</code> , 这样当按下 <code>s</code> 键时会替换成为 <code>d</code> 键。</p><h4 id="从makecode到实际字符"><a class="anchor" href="#从makecode到实际字符">#</a> 从 MakeCode 到实际字符</h4><p>接下来我们将尽力地把按键显示成可以显示的字符。虽然这并不总是可行的（比如按下 <code>Shift</code> 键然后弹起，显然密码框里不会因此被输入一个字符），这涉及扫描码和实际字符是如何对应的。</p><p>所谓的实际字符就是 <code>ASCII</code> 码。大家都知道大写 / 小写字符的 ASCII 码并不相同，但是键是同一个（就是说扫描码是相同的），具体是哪个取决于几个键的状态（包括 <code>Shift</code> 键、 <code>Caps Lock</code> 键）。因此，这个模块在过滤按键的同时，也必须把这几个控制键的状态保存下来。</p><p>请注意 <code>Shift</code> 键和 <code>Caps Lock</code> 键的不同： <code>Shift</code> 键是按下生效，释放则无效了；而 <code>Caps Lock</code> 键是按一次生效，再按一次无效了。因此过滤的方法也不<br>一样。</p><p>具体实现见代码。</p><h1 id="运行结果"><a class="anchor" href="#运行结果">#</a> 运行结果</h1><p>代码放在 github 了， <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09yMGtpdC9GbHRlcjAy">https://github.com/Or0kit/Flter02</span></p><p><img data-src="image002.png" alt=""></p><div class="tags"><a href="/tags/%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4/" rel="tag"><i class="ic i-tag"></i> 键盘过滤</a> <a href="/tags/PDO/" rel="tag"><i class="ic i-tag"></i> PDO</a> <a href="/tags/Windows%E4%B8%AD%E4%BB%8E%E5%87%BB%E9%94%AE%E5%88%B0%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%87%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i> Windows中从击键到内核的过程</a> <a href="/tags/KEYBOARD-INPUT-DATA%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> KEYBOARD_INPUT_DATA结构</a> <a href="/tags/IRP%E5%AE%8C%E6%88%90%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" rel="tag"><i class="ic i-tag"></i> IRP完成回调函数</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-08-06 22:01:23" itemprop="dateModified" datetime="2022-08-06T22:01:23+08:00">2022-08-06</time> </span><span id="Bin/Core/Drive-Development/键盘的过滤/" class="item leancloud_visitors" data-flag-title="键盘的过滤" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/reward.jpg" alt="Or0kit 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Or0kit <i class="ic i-at"><em>@</em></i>Or0kit</li><li class="link"><strong>本文链接：</strong> <a href="https://or0kit.github.io/Bin/Core/Drive-Development/%E9%94%AE%E7%9B%98%E7%9A%84%E8%BF%87%E6%BB%A4/" title="键盘的过滤">https://or0kit.github.io/Bin/Core/Drive-Development/键盘的过滤/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Bin/Core/Drive-Development/%E4%B8%B2%E5%8F%A3%E7%9A%84%E8%BF%87%E6%BB%A4/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;storage.live.com&#x2F;items&#x2F;70930153B02A575!367?authkey&#x3D;AGDHHD5Qh4Y5OtQ" title="过滤驱动-串口的过滤"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 驱动开发</span><h3>过滤驱动-串口的过滤</h3></a></div><div class="item right"><a href="/Bin/Core/Drive-Development/%E7%A3%81%E7%9B%98%E7%9A%84%E8%99%9A%E6%8B%9F/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;storage.live.com&#x2F;items&#x2F;70930153B02A575!385?authkey&#x3D;AGDHHD5Qh4Y5OtQ" title="磁盘的虚拟"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 驱动开发</span><h3>磁盘的虚拟</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">键盘过滤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pdo"><span class="toc-number">2.1.1.</span> <span class="toc-text">PDO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E4%B8%AD%E4%BB%8E%E5%87%BB%E9%94%AE%E5%88%B0%E5%86%85%E6%A0%B8"><span class="toc-number">2.1.2.</span> <span class="toc-text">Windows 中从击键到内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">键盘硬件原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">键盘过滤框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E9%94%AE%E7%9B%98%E8%AE%BE%E5%A4%87"><span class="toc-number">3.1.</span> <span class="toc-text">绑定键盘设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%B1%A1%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">获取驱动对象下的所有设备对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">获取驱动对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%89%A9%E5%B1%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">设备扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">绑定设备的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97%E7%9A%84driverentry"><span class="toc-number">3.2.</span> <span class="toc-text">键盘过滤模块的 DriverEntry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A8%E6%80%81%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.3.</span> <span class="toc-text">键盘过滤模块的动态卸载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">键盘过滤的请求处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">通常的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pnp%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">PNP 的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.4.3.</span> <span class="toc-text">读的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%AE%8C%E6%88%90%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.4.4.</span> <span class="toc-text">读完成的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyboard_input_data%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">KEYBOARD_INPUT_DATA 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%AE%8C%E6%88%90%E5%87%BD%E6%95%B0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">读完成函数完整代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Emakecode%E5%88%B0%E5%AE%9E%E9%99%85%E5%AD%97%E7%AC%A6"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">从 MakeCode 到实际字符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">运行结果</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/" rel="bookmark" title="驱动开发-第一个驱动程序">驱动开发-第一个驱动程序</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E8%B0%83%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/" rel="bookmark" title="驱动开发-调试驱动程序">驱动开发-调试驱动程序</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="bookmark" title="驱动开发-内核编程基础">驱动开发-内核编程基础</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/" rel="bookmark" title="驱动开发-内核空间和内核模块">驱动开发-内核空间和内核模块</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-0%E7%8E%AF%E4%B8%8E3%E7%8E%AF%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95%EF%BC%89/" rel="bookmark" title="驱动开发-0环与3环的通信（常规方法）">驱动开发-0环与3环的通信（常规方法）</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E2%80%94%E4%BD%BF%E7%94%A8SCM%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8/" rel="bookmark" title="驱动开发—使用SCM加载驱动">驱动开发—使用SCM加载驱动</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E8%BF%87%E5%86%99%E6%8B%B7%E8%B4%9D/" rel="bookmark" title="驱动开发-过写拷贝">驱动开发-过写拷贝</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%9F%BA%E4%BA%8EVS+WDK%E7%9A%84%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/" rel="bookmark" title="驱动开发-基于VS+WDK的驱动调试">驱动开发-基于VS+WDK的驱动调试</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80plus/" rel="bookmark" title="驱动开发-内核编程基础plus">驱动开发-内核编程基础plus</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-64%E4%BD%8D%E4%B8%8E32%E4%BD%8D%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%B7%AE%E5%BC%82/" rel="bookmark" title="驱动开发-64位与32位内核开发差异">驱动开发-64位与32位内核开发差异</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="bookmark" title="驱动开发-内核编程常用技巧">驱动开发-内核编程常用技巧</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E9%9A%90%E8%97%8F%E9%A9%B1%E5%8A%A8/" rel="bookmark" title="驱动开发-隐藏驱动">驱动开发-隐藏驱动</a></li><li><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E5%86%85%E6%A0%B8%E9%87%8D%E8%BD%BD/" rel="bookmark" title="驱动开发-内核重载">驱动开发-内核重载</a></li><li><a href="/Bin/Core/Drive-Development/%E4%B8%B2%E5%8F%A3%E7%9A%84%E8%BF%87%E6%BB%A4/" rel="bookmark" title="过滤驱动-串口的过滤">过滤驱动-串口的过滤</a></li><li class="active"><a href="/Bin/Core/Drive-Development/%E9%94%AE%E7%9B%98%E7%9A%84%E8%BF%87%E6%BB%A4/" rel="bookmark" title="键盘的过滤">键盘的过滤</a></li><li><a href="/Bin/Core/Drive-Development/%E7%A3%81%E7%9B%98%E7%9A%84%E8%99%9A%E6%8B%9F/" rel="bookmark" title="磁盘的虚拟">磁盘的虚拟</a></li><li><a href="/Bin/Core/Drive-Development/%E7%A3%81%E7%9B%98%E7%9A%84%E8%BF%87%E6%BB%A4/" rel="bookmark" title="磁盘的过滤">磁盘的过滤</a></li><li><a href="/Bin/Core/Drive-Development/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/" rel="bookmark" title="文件系统的过滤与监控">文件系统的过滤与监控</a></li><li><a href="/Bin/Core/Drive-Development/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%AE%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/" rel="bookmark" title="文件系统微过滤驱动">文件系统微过滤驱动</a></li><li><a href="/Bin/Core/Drive-Development/%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/" rel="bookmark" title="文件过滤驱动总结与扩展">文件过滤驱动总结与扩展</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Or0kit" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Or0kit</p><div class="description" itemprop="description">临渊羡鱼，不如退而结网</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">216</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">49</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">398</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29t" title="https:&#x2F;&#x2F;github.com"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJuYW1l" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourname"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Bin/Core/Drive-Development/%E4%B8%B2%E5%8F%A3%E7%9A%84%E8%BF%87%E6%BB%A4/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Bin/Core/Drive-Development/%E7%A3%81%E7%9B%98%E7%9A%84%E8%99%9A%E6%8B%9F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Bin/" title="分类于 逆向">逆向</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/" title="分类于 内核学习">内核学习</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/WindowsXp/" title="分类于 Xp内核分析">Xp内核分析</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/WindowsXp/SystemCall/" title="分类于 系统调用">系统调用</a></div><span><a href="/Bin/Core/WindowsXp/SystemCall/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-SSDT/" title="系统调用-SSDT">系统调用-SSDT</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Programming/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Programming/MFC/" title="分类于 MFC">MFC</a></div><span><a href="/Programming/MFC/MFC-02%E5%8D%95%E9%80%89%E6%A1%86%E4%B8%8E%E5%A4%8D%E9%80%89%E6%A1%86%E4%BB%B6/" title="MFC-02单选框与复选框件">MFC-02单选框与复选框件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/web/" title="分类于 web">web</a></div><span><a href="/PenetrationTest/Web-Security/HTML_Refresher/" title="HTML_Refresher">HTML_Refresher</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bin/" title="分类于 逆向">逆向</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/" title="分类于 内核学习">内核学习</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/Drive-Development/" title="分类于 驱动开发">驱动开发</a></div><span><a href="/Bin/Core/Drive-Development/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-0%E7%8E%AF%E4%B8%8E3%E7%8E%AF%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95%EF%BC%89/" title="驱动开发-0环与3环的通信（常规方法）">驱动开发-0环与3环的通信（常规方法）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Programming/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Programming/MFC/" title="分类于 MFC">MFC</a></div><span><a href="/Programming/MFC/MFC-04ComboBox%E6%8E%A7%E4%BB%B6/" title="MFC-04ComboBox控件">MFC-04ComboBox控件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bin/" title="分类于 逆向">逆向</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Win32/" title="分类于 Win32">Win32</a></div><span><a href="/Bin/Win32/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84GetProcAddress%E5%87%BD%E6%95%B0/" title="实现自己的GetProcAddress函数">实现自己的GetProcAddress函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/Linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99-psad%E6%A3%80%E6%B5%8B%E5%8F%AF%E7%96%91%E6%B5%81%E9%87%8F/" title="Linux防火墙-psad检测可疑流量">Linux防火墙-psad检测可疑流量</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bin/" title="分类于 逆向">逆向</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Win32/" title="分类于 Win32">Win32</a></div><span><a href="/Bin/Win32/Win%E6%97%A0%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/" title="Win无模块注入代码">Win无模块注入代码</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bin/" title="分类于 逆向">逆向</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/" title="分类于 内核学习">内核学习</a> <i class="ic i-angle-right"></i> <a href="/categories/Bin/Core/Drive-Development/" title="分类于 驱动开发">驱动开发</a></div><span><a href="/Bin/Core/Drive-Development/%E9%94%AE%E7%9B%98%E7%9A%84%E8%BF%87%E6%BB%A4/" title="键盘的过滤">键盘的过滤</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/tag-plugins/" title="Tag Plugins">Tag Plugins</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Or0kit @ Or0kit</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.5m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">22:02</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Bin/Core/Drive-Development/键盘的过滤/",favicon:{show:"╰(*°▽°*)╯正在变强中",hide:"(ー`′ー)快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"/live2dw/assets/koharu.model.json"},display:{superSample:2,width:150,height:300,position:"right",hOffset:0,vOffset:-20},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.8},log:!1})</script></body></html><!-- rebuild by hrmmi -->