{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"恶意代码分析\" category",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-Lab5/",
            "url": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-Lab5/",
            "title": "恶意代码分析实战-Lab5",
            "date_published": "2022-03-15T10:56:17.000Z",
            "content_html": "<h1 id=\"lab5-1\"><a class=\"anchor\" href=\"#lab5-1\">#</a> Lab5-1</h1>\n<p>只用 IDA Pro 分析在文件 Lb05-O1.dl 中发现的恶意代码。这个实验的目标是给你一个用 IDA Pro 动手的经验。如果你已经用 IDA Pro 工作过，你可以选择忽略这些问题，而将精力集中在逆向工程恶意代码上。</p>\n<h2 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题</h2>\n<p>1．D11Main 的地址是什么？<br />\n2．使用 Imports 窗口并浏览到 gethostbyname，导入函数定位到什么地址？<br />\n3．有多少函数调用了 gethostbyname？<br />\n4．将精力集中在位于 0x10001757 处的对 gethostbyname 的调用，你能找出哪个 DNS 请求将被触发吗？<br />\n5．IDA Pro 识别了在 0x10001656 处的子过程中的多少个局部变量？<br />\n6．IDA Pro 识别了在 0x10001656 处的子过程中的多少个参数？<br />\n7．使用 Strings 窗口，来在反汇编中定位字符串 \\cmd.exe/c。它位于哪？<br />\n8．在引用 \\cmd.exe/c 的代码所在的区域发生了什么？<br />\n9．在同样的区域，在 0x100101C8 处，看起来好像 dword＿1008E5C4 是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置 dword＿1008E5C4 的呢？（提示：使用 dword＿1008E5C4 的交叉引用。）<br />\n10. 在位于 0x1000FF58 处的子过程中的几百行指令中，一系列使用 memcmp 来比较字符串的比较。如果对 robotwork 的字符串比较是成功的（当 memcmp 返回 0), 会发生什么？<br />\n11. PSLIST 导出函数做了什么？<br />\n12. 使用图模式来绘制出对 sub_10004E79 的交叉引用图。当进入这个函数时，哪个 API 函数可能被调用？仅仅基于这些 API 函数，你会如何重命名这个函数？<br />\n13. DllMain 直接调用了多少个 WindowsAPI ? 多少个在深度为 2 时被调用？<br />\n14. 在 0×10001358 处，有一个对 Sleep (一个使用一个包含要睡眠的毫秒数的参数的 API 函数）的调用。顺着代码向后看，如果这段代码执行，这个程序会睡眠多久？<br />\n15. 在 0×10001701 处是一个对 socket 的调用。它的 3 个参数是什么？<br />\n16. 使用 MSDN 页面的 socket 和 IDAPro 中的命名符号常量，你能使参数更加有意义吗？在你应用了修改以后，参数是什么？<br />\n17. 搜索 in 指令（opcode 0xED) 的使用。这个指令和一个魔术字符串 VMXh 用来进行 VMware 检测。这在这个恶意代码中被使用了吗？使用对执行 in 指令函数的交叉引用，能发现进一步检测 VMware 的证据吗？<br />\n18. 将你的光标跳转到 0×1001D988 处，你发现了什么？<br />\n19. 如果你安装了 IDAPython 插件（包括 IDAPro 的商业版本的插件）,<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1MYWIwNS0wMS1sbzl3eTM2Yy5weQ==\"> 运行 Lab05-01.py</span>, 一个本书中随恶意代码提供的 IDAPro Python 脚本，(确定光标是在 0x1001D988 处。）在你运行这个脚本后发生了什么？<br />\n20. 将光标放在同一位置，你如何将这个数据转成一个单一的 ASCII 字符串？<br />\n21. 使用一个文本编辑器打开这个脚本。它是如何工作的？</p>\n<p><strong>解：</strong></p>\n<ol>\n<li><code>.text:1000D02E</code>  在 IDA 中打开此文件，IDA 会直接帮我们定位到 DLLMain 函数，想来是因为此函数具备特征。</li>\n<li><code>.idata:100163CC</code></li>\n<li>把光标放到 gethostbyname 所在的地址处，按下  <code>x</code>  使用交叉引用，介意发现观察到：</li>\n</ol>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>在整个恶意代码中 gethostbyname 被 5 个函数调用 9 次。</p>\n<ol start=\"4\">\n<li>:</li>\n</ol>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.text:1000174E                 mov     eax, off_10019040 ; eax 指向了一个地址 这里面存储着指向 &#39;[This is RDO] pics.praticalmalwareanalysis.com&#39;,0 的首地址</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>.text:10001753                 add     eax, 0Dh        ; eax + 0xD</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>.text:10001753                                         ; 此时的 eax 跳过了 [This is RDO] 指向了 pics.praticalmalwareanalysis.com 的首地址</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>.text:10001756                 push    eax             ; 压栈 压入指向 pics.praticalmalwareanalysis.com 的地址</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>.text:10001757                 call    ds:gethostbyname</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>off_10019040    dd offset aThisIsRdoPicsP</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>aThisIsRdoPicsP db &#39;[This is RDO] pics.praticalmalwareanalysis.com&#39;,0</pre></td></tr></table></figure><ol start=\"5\">\n<li>: 24 个局部变量</li>\n</ol>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.text:10001656 ; DWORD __stdcall sub_10001656(LPVOID lpThreadParameter)</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>.text:10001656 sub_10001656    proc near               ; DATA XREF: DllMain(x,x,x)+C8↓o</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>.text:10001656</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>.text:10001656 var_675         &#x3D; byte ptr -675h</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>.text:10001656 var_674         &#x3D; dword ptr -674h</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>.text:10001656 hModule         &#x3D; dword ptr -670h</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>.text:10001656 timeout         &#x3D; timeval ptr -66Ch</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>.text:10001656 name            &#x3D; sockaddr ptr -664h</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>.text:10001656 var_654         &#x3D; word ptr -654h</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>.text:10001656 in              &#x3D; in_addr ptr -650h</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>.text:10001656 Str1            &#x3D; byte ptr -644h</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>.text:10001656 var_640         &#x3D; byte ptr -640h</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>.text:10001656 CommandLine     &#x3D; byte ptr -63Fh</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>.text:10001656 Str             &#x3D; byte ptr -63Dh</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>.text:10001656 var_638         &#x3D; byte ptr -638h</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>.text:10001656 var_637         &#x3D; byte ptr -637h</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>.text:10001656 var_544         &#x3D; byte ptr -544h</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>.text:10001656 var_50C         &#x3D; dword ptr -50Ch</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>.text:10001656 var_500         &#x3D; byte ptr -500h</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>.text:10001656 Buf2            &#x3D; byte ptr -4FCh</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>.text:10001656 readfds         &#x3D; fd_set ptr -4BCh</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>.text:10001656 buf             &#x3D; byte ptr -3B8h</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>.text:10001656 var_3B0         &#x3D; dword ptr -3B0h</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>.text:10001656 var_1A4         &#x3D; dword ptr -1A4h</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>.text:10001656 var_194         &#x3D; dword ptr -194h</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>.text:10001656 WSAData         &#x3D; WSAData ptr -190h</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>.text:10001656 lpThreadParameter&#x3D; dword ptr  4</pre></td></tr></table></figure><ol start=\"6\">\n<li>\n<p>1 个参数</p>\n</li>\n<li>\n<p><code>10095B34 aCmdExeC        db '\\cmd.exe /c ',0</code></p>\n</li>\n<li>\n<p>把这串字符串拼接到了临时变量 Destination 的后面，Destination 中之前存储的是系统目录，在后续操作中 将此变量作为参数 调用了 CreateProcessA 函数，既打开了 Shell 会话。</p>\n</li>\n<li>\n<p>整个恶意代码中对 dword_1008E5C4  变量涉及写操作的代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.text:10001673                 call    ProbeSystemVersion ; 这个函数被我重命名了</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>.text:10001678                 mov     dword_1008E5C4, eax ; 把返回值赋给全局变量 是一个布尔类型的值</pre></td></tr></table></figure><p>调用了一个函数后把 eax 也就是函数的返回值赋给了这个全局变量，看一看这个函数做了什么：</p>\n<figure class=\"highlight raw\"><figcaption data-lang=\"\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.text:10003695 ProbeSystemVersion proc near            ; CODE XREF: sub_10001656+1D↑p</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>.text:10003695                                         ; sub_10003B75+7↓p ...</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>.text:10003695</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>.text:10003695 VersionInformation&#x3D; _OSVERSIONINFOA ptr -94h</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>.text:10003695</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>.text:10003695                 push    ebp</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>.text:10003696                 mov     ebp, esp</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>.text:10003698                 sub     esp, 94h</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>.text:1000369E                 lea     eax, [ebp+VersionInformation]</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>.text:100036A4                 mov     [ebp+VersionInformation.dwOSVersionInfoSize], 94h</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>.text:100036AE                 push    eax             ; lpVersionInformation</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>.text:100036AF                 call    ds:GetVersionExA</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>.text:100036B5                 xor     eax, eax</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>.text:100036B7                 cmp     [ebp+VersionInformation.dwPlatformId], 2 ; 2 表示操作系统是</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>.text:100036B7                                         ; Windows 7、Windows Server 2008、</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>.text:100036B7                                         ; Windows Vista、Windows Server 2003、</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>.text:100036B7                                         ; Windows XP 或 Windows 2000。</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>.text:100036BE                 setz    al              ; 把 ZF 标志位赋值给 al</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>.text:100036C1                 leave</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>.text:100036C2                 retn</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>.text:100036C2 ProbeSystemVersion endp</pre></td></tr></table></figure><p>可以发现此函数就是判断操作系统是否是 Windows 7、Windows Server 2008、Windows Vista、Windows Server 2003、Windows XP 或 Windows 2000。如果是的话返回值就是 1 不是的话返回值就是 0  然后根据这个结果判断 Shell 会话是 cmd.exe 还是 command.exe ，后面会调用 CreateProcessA 来创建一个 Shell 会话，另外根据上下代码的一些字符串可以知道，此函数主要是为了开启远程 Shell 会话。</p>\n<ol start=\"11\">\n<li></li>\n</ol>\n",
            "tags": [
                "逆向",
                "IDA学习"
            ]
        },
        {
            "id": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC03%E7%AB%A0/",
            "url": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC03%E7%AB%A0/",
            "title": "恶意代码分析实战-第03章动态分析技术基础",
            "date_published": "2021-11-30T12:26:59.000Z",
            "content_html": "<h1 id=\"动态分析技术基础\"><a class=\"anchor\" href=\"#动态分析技术基础\">#</a> 动态分析技术基础</h1>\n<p>动态分析就是运行恶意代码之后进行检查的过程。</p>\n<p>动态分析是恶意代码分析流程的第二步，一般在静态分析进入死胡同时进行，比如恶意代码进行了混淆，或者分析师已经穷尽了可用的静态分析技术。动态分析技术包括在恶意代码运行时时刻进行监控，以及在恶意代码运行之后来检查系统情况。</p>\n<p>与静态分析技术不同，动态分析技术能让你观察到恶意代码的真实功能，<strong>一个行为存在于二进制程序中，并不意味着它就会被执行。</strong></p>\n<p>动态分析也是一种识别恶意代码功能的有效方法。例如你要分析的恶意代码是键盘记录程序，动态分析技术能让你在系统上找到键盘记录的日志文件，发现它的各种记录，追踪它将技术发送到哪里了，等等。这种深刻的洞察力是静态分析基础技术很那获得的。</p>\n<p>虽然动态分析技术非常强大，<strong>但它会让你的网络和系统处于危险之中</strong>。</p>\n<p>动态分析技术也有着它们的局限性，一个恶意代码在执行时不是所有代码都会被执行到的。例如，在一个需要参数命令行的恶意代码，每一个参数都会执行不同的程序功能，如果你不知道所有的命令行选项，你就不能动态分析出所有程序功能。这时就要利用更为高级的动态分析技术或者静态分析技术了。</p>\n<h2 id=\"沙箱简便但粗糙的方法\"><a class=\"anchor\" href=\"#沙箱简便但粗糙的方法\">#</a> 沙箱：简便但粗糙的方法</h2>\n<p>沙箱包括一个虚拟环境，通过某种方式模拟网络服务，以确保被测试的软件或恶意代码能正常执行。</p>\n",
            "tags": [
                "动态分析技术基础"
            ]
        },
        {
            "id": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC01%E7%AB%A0/",
            "url": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC01%E7%AB%A0/",
            "title": "恶意代码分析实战-第01章静态分析技术基础",
            "date_published": "2021-11-30T12:26:50.000Z",
            "content_html": "<h1 id=\"静态分析基础技术\"><a class=\"anchor\" href=\"#静态分析基础技术\">#</a> 静态分析基础技术</h1>\n<p>本章将讨论从可执行文件提取有用的信息的多种方法，包括以下技术：</p>\n<ul>\n<li>使用反病毒软件来确认程序样本的恶意性；</li>\n<li>使用哈希来识别恶意代码；</li>\n<li>从文件的字符串列表、函数和文件头信息中发掘有用的信息。</li>\n</ul>\n<p>每种技术都可以提供不同的信息，使用哪种技术则取决于你的目标。在大多数情况下，你需要使用多种技术，来尽可能多的搜集信息。</p>\n<ol>\n<li>\n<p>反病毒引擎扫描： 实用的第一步</p>\n</li>\n<li>\n<p>哈希值：恶意代码的指纹</p>\n</li>\n<li>\n<p>查找字符串</p>\n</li>\n<li>\n<p>加壳与混淆恶意代码</p>\n</li>\n<li>\n<p>文件加壳</p>\n</li>\n</ol>\n<p>5.1 使用 PEID 检测加壳</p>\n<ol start=\"6\">\n<li>\n<p>PE 文件格式</p>\n</li>\n<li>\n<p>链接库与函数</p>\n</li>\n</ol>\n<p>7.1 静态链接、运行时链接与动态链接</p>\n<p>7.2 使用 Dependency Walker 工具探索动态链接函数</p>\n<p>7.3 导入函数</p>\n<ol start=\"8\">\n<li>导出函数</li>\n</ol>\n<h1 id=\"静态分析技术实践\"><a class=\"anchor\" href=\"#静态分析技术实践\">#</a> 静态分析技术实践</h1>\n<p>课后作业</p>\n<h1 id=\"lab-1-1\"><a class=\"anchor\" href=\"#lab-1-1\">#</a> Lab 1-1</h1>\n<p>这个实验使用 Lab01-01.exe 和 Lab01-01.dll 文件，使用本章描述的工具和技术来获取关于这些文件的信息。</p>\n<p>问题<br />\n 1. 将文件上传至 http://www.VirusTotal.com/ 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？<br />\n2. 这些文件是什么时候编译的？<br />\n3. 这两个文件中是否存在迹象说明它们是否被加壳或混淆了？如果是，这些迹象在哪里？<br />\n4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？<br />\n5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染系统上查找？<br />\n6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码？<br />\n7. 你猜这些文件的目的是什么？</p>\n<h2 id=\"操作环境\"><a class=\"anchor\" href=\"#操作环境\">#</a> 操作环境</h2>\n<p>实验场景: Windows Xp sp3</p>\n<p>实验工具： PEid  Strings PETools <span class=\"exturl\" data-url=\"aHR0cDovL1ZpclNDQU4ub3Jn\">VirSCAN.org</span>（云分析网站）VirusTotal</p>\n<p>实验文件： Lab01-01.exe Lab01-01.dll</p>\n<p>实验思路：</p>\n<ol>\n<li>利用网络扫描工具对目标文件进行扫描。</li>\n<li>利用本地静态分析工具分析目标程序。</li>\n<li>对上述结果进行分析。</li>\n</ol>\n",
            "tags": [
                "静态分析基础"
            ]
        },
        {
            "id": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC0%E7%AB%A0/",
            "url": "https://or0kit.github.io/Bin/MalwareAnalysis/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC0%E7%AB%A0/",
            "title": "恶意代码分析实战-第0章",
            "date_published": "2021-11-30T12:26:19.000Z",
            "content_html": "<h1 id=\"恶意代码分析技术入门\"><a class=\"anchor\" href=\"#恶意代码分析技术入门\">#</a> 恶意代码分析技术入门</h1>\n<h2 id=\"恶意代码分析目标\"><a class=\"anchor\" href=\"#恶意代码分析目标\">#</a> 恶意代码分析目标</h2>\n<h2 id=\"恶意代码分析技术\"><a class=\"anchor\" href=\"#恶意代码分析技术\">#</a> 恶意代码分析技术</h2>\n<h3 id=\"静态分析基础技术\"><a class=\"anchor\" href=\"#静态分析基础技术\">#</a> 静态分析基础技术</h3>\n<h3 id=\"动态分析基础技术\"><a class=\"anchor\" href=\"#动态分析基础技术\">#</a> 动态分析基础技术</h3>\n<h3 id=\"静态分析高级技术\"><a class=\"anchor\" href=\"#静态分析高级技术\">#</a> 静态分析高级技术</h3>\n<h3 id=\"动态分析高级技术\"><a class=\"anchor\" href=\"#动态分析高级技术\">#</a> 动态分析高级技术</h3>\n<h2 id=\"恶意代码类型\"><a class=\"anchor\" href=\"#恶意代码类型\">#</a> 恶意代码类型</h2>\n<h2 id=\"恶意代码分析通用规则\"><a class=\"anchor\" href=\"#恶意代码分析通用规则\">#</a> 恶意代码分析通用规则</h2>\n",
            "tags": [
                "恶意代码分析实战入门"
            ]
        }
    ]
}