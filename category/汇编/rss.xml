<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Or0kit • Posts by &#34;汇编&#34; category</title>
        <link>https://Or0kit.github.io</link>
        <description>临渊羡鱼，不如退而结网</description>
        <language>zh-CN</language>
        <pubDate>Mon, 11 Apr 2022 10:24:20 +0800</pubDate>
        <lastBuildDate>Mon, 11 Apr 2022 10:24:20 +0800</lastBuildDate>
        <category>Algolia</category>
        <category>同义词替换</category>
        <category>Drozer</category>
        <category>xpath</category>
        <category>win32api</category>
        <category>WOW64</category>
        <category>windows消息机制</category>
        <category>虚拟内存</category>
        <category>jsDelivr</category>
        <category>First blog</category>
        <category>markdown 学习</category>
        <category>Android</category>
        <category>数论基础</category>
        <category>替换密钥</category>
        <category>ADB</category>
        <category>雷电模拟器</category>
        <category>Hadoop</category>
        <category>IDA</category>
        <category>Windows逆向</category>
        <category>SSH隧道</category>
        <category>url</category>
        <category>http</category>
        <category>Linux</category>
        <category>Nginx</category>
        <category>CentOS7配置vsftp</category>
        <category>Psad</category>
        <category>fwsnort</category>
        <category>应急响应</category>
        <category>x86汇编指令</category>
        <category>PE课后作业</category>
        <category>MFC</category>
        <category>PE查看器</category>
        <category>PE结构</category>
        <category>DOS头属性说明</category>
        <category>标准PE头属性说明</category>
        <category>扩展PE头属性说明</category>
        <category>节表属性说明</category>
        <category>空白区添加代码</category>
        <category>RVA与FOA</category>
        <category>合并节</category>
        <category>注入</category>
        <category>导入表注入</category>
        <category>导出表</category>
        <category>导入表</category>
        <category>扩大节</category>
        <category>新增节</category>
        <category>移动NT头</category>
        <category>移动导出表</category>
        <category>移动重定位表</category>
        <category>重定位表</category>
        <category>静态链接库</category>
        <category>动态链接库</category>
        <category>句柄</category>
        <category>逆向</category>
        <category>IDA学习</category>
        <category>静态分析基础</category>
        <category>动态分析技术基础</category>
        <category>恶意代码分析实战入门</category>
        <category>加壳</category>
        <category>脱壳</category>
        <category>C++壳</category>
        <category>ESP寻址</category>
        <category>定位Win32窗口回调函数</category>
        <category>HOOK攻防</category>
        <category>瞬时HOOK过检测</category>
        <category>INLINE-HOOK</category>
        <category>IAT HOOK</category>
        <category>INLINE HOOK</category>
        <category>进程监控</category>
        <category>模块隐藏</category>
        <category>进程通信</category>
        <category>tlhelp32.h</category>
        <category>进程遍历</category>
        <category>模块遍历</category>
        <category>外挂原理</category>
        <category>DLL注入之进程间通信</category>
        <category>TEB</category>
        <category>PEB</category>
        <category>R3层断链</category>
        <category>Win临界区</category>
        <category>Win事件</category>
        <category>线程同步</category>
        <category>Win互斥体</category>
        <category>内存映射文件</category>
        <category>内存映射共享</category>
        <category>写拷贝</category>
        <category>Win子窗口控件</category>
        <category>win32文件函数</category>
        <category>代码注入</category>
        <category>窗口程序</category>
        <category>消息机制</category>
        <category>消息类型</category>
        <category>私有内存</category>
        <category>共享内存</category>
        <category>设备对象</category>
        <category>DC设备上下文</category>
        <category>图形对象</category>
        <category>创建线程</category>
        <category>线程控制</category>
        <category>线程相关API</category>
        <category>线程上下文</category>
        <category>CONTEXT结构体</category>
        <category>物理内存</category>
        <category>Windows进程</category>
        <category>句柄表</category>
        <category>远程线程函数</category>
        <category>远程线程</category>
        <category>DLL注入</category>
        <category>DLL注入相关函数</category>
        <category>WinMain函数</category>
        <category>调用约定</category>
        <category>我的GetProcAddress</category>
        <category>资源文件</category>
        <category>消息断点</category>
        <category>通用控件</category>
        <category>WM_NOTIFY消息类型</category>
        <category>CobaltStrike</category>
        <category>Apeache</category>
        <category>Nmap</category>
        <category>php</category>
        <category>guestbook</category>
        <category>SQLmap</category>
        <category>apache</category>
        <category>log</category>
        <category>mysql主键</category>
        <category>CSRF</category>
        <category>SSRF</category>
        <category>业务逻辑漏洞</category>
        <category>xss</category>
        <category>webshell流量特征</category>
        <category>虚拟网卡</category>
        <category>RedTeam</category>
        <category>python</category>
        <category>SSH</category>
        <category>python文件读取</category>
        <category>数据分析</category>
        <category>socket</category>
        <category>数据库编程</category>
        <category>python内置属性</category>
        <category>scrapy</category>
        <category>测试</category>
        <category>BHP</category>
        <category>Python的import功能</category>
        <category>木马</category>
        <category>button</category>
        <category>multiprocessing</category>
        <category>threading</category>
        <category>单选框</category>
        <category>复选框件</category>
        <category>Edit</category>
        <category>Combo Box</category>
        <category>Tab</category>
        <category>ListCtrl</category>
        <category>MFC的本质</category>
        <category>MFC的层次结构图</category>
        <category>手动创建一个MFC程序</category>
        <category>MFC的初始化过程</category>
        <category>MFC运行时类型识别</category>
        <category>关键字static</category>
        <category>关键字const</category>
        <category>MFC动态创建</category>
        <category>MFC消息映射</category>
        <category>结构体AFX_MSGMAP_ENTRY</category>
        <category>结构体AFX_MSGM</category>
        <category>MFC的三大类消息</category>
        <category>数据传输</category>
        <category>ini文件的读写</category>
        <category>非可变序列算法</category>
        <category>可变序列算法</category>
        <category>排序算法</category>
        <category>迭代器</category>
        <category>使用自定义对象</category>
        <category>0环与3环的通信（常规方法）</category>
        <category>内核空间</category>
        <category>内核模块</category>
        <category>遍历内核模块</category>
        <category>定位未导出函数PspTiminateProcess</category>
        <category>内核编程基础</category>
        <category>ANSI_STRING</category>
        <category>UNICODE_STRING</category>
        <category>内核内存</category>
        <category>上下文环境</category>
        <category>中断请求级别</category>
        <category>链表</category>
        <category>自旋锁</category>
        <category>注册表</category>
        <category>地址空间</category>
        <category>文件操作</category>
        <category>线程与事件</category>
        <category>内核重载</category>
        <category>配置VS2019+WDK10</category>
        <category>第一个驱动程序</category>
        <category>驱动调试</category>
        <category>调试驱动程序</category>
        <category>OpenSCManager</category>
        <category>CreateService</category>
        <category>APC的本质</category>
        <category>APC的备用队列</category>
        <category>线性地址的管理</category>
        <category>VAD树</category>
        <category>_MMVAD</category>
        <category>_MMVAD_FLAGS</category>
        <category>VirtualAlloc</category>
        <category>MEM_COMMIT与MEM_RESERVE</category>
        <category>malloc</category>
        <category>堆内存</category>
        <category>栈内存</category>
        <category>全局区内存</category>
        <category>共享物理页</category>
        <category>共享文件</category>
        <category>LoadLibrary的本质</category>
        <category>MmAddPhysicalMemoryEx</category>
        <category>缺页异常</category>
        <category>消息队列</category>
        <category>PsConvertToGuiThread</category>
        <category>win32k.sys</category>
        <category>GUI线程</category>
        <category>窗口程序的创建</category>
        <category>消息循环</category>
        <category>临界区</category>
        <category>KPCR结构体</category>
        <category>模拟线程切换</category>
        <category>模拟挂起与恢复函数</category>
        <category>等待链表</category>
        <category>调度链表</category>
        <category>ETHREAD</category>
        <category>KTHREAD</category>
        <category>进程的创建</category>
        <category>获取当前进程</category>
        <category>EPROCESS</category>
        <category>KPROCESS</category>
        <category>2-9-9-12分页</category>
        <category>PAE</category>
        <category>PDPTE</category>
        <category>PDE</category>
        <category>PTE</category>
        <category>XD标志位</category>
        <category>逆向分析MmIsAddressValid函数(2-9-9-12)</category>
        <category>PWT</category>
        <category>PDT</category>
        <category>TLB</category>
        <category>CPU缓存</category>
        <category>INVLPG指令</category>
        <category>全局页</category>
        <category>ShadowWalker</category>
        <category>中断</category>
        <category>异常</category>
        <category>CLI指令</category>
        <category>STI指令</category>
        <category>INT2</category>
        <category>INT8</category>
        <category>中断门描述符</category>
        <category>IDT</category>
        <category>提权</category>
        <category>跨段跳转流程</category>
        <category>JMP FAR指令</category>
        <category>TSS</category>
        <category>任务门</category>
        <category>LDT段描述符</category>
        <category>LDT</category>
        <category>CR0</category>
        <category>CR2</category>
        <category>CR4</category>
        <category>段寄存器结构</category>
        <category>段描述符</category>
        <category>段选择子</category>
        <category>GDT表</category>
        <category>CRL</category>
        <category>DPL</category>
        <category>RPL</category>
        <category>调用门</category>
        <category>调用门描述符</category>
        <category>逆向分析MmIsAddressValid函数</category>
        <category>CALL与CALL FAR</category>
        <category>error C2143</category>
        <category>error C2275</category>
        <category>陷阱门描述符</category>
        <category>页目录表基址</category>
        <category>页表的基址</category>
        <category>0地址执行ShellCode</category>
        <category>10-10-12分页</category>
        <category>PDE_PTE</category>
        <category>物理页</category>
        <category>SSDT HOOK</category>
        <category>OpenProcess</category>
        <category>系统服务表</category>
        <category>SSDT</category>
        <category>SSDT HOOK隐藏</category>
        <category>API进出内核</category>
        <category>系统调用阶段总结</category>
        <category>网络安全法</category>
        <category>ASCII</category>
        <category>GBK</category>
        <category>ANSI</category>
        <category>Unicode</category>
        <category>UTF-8</category>
        <category>URL 编码/解码</category>
        <category>十进制</category>
        <category>二进制</category>
        <category>十六进制</category>
        <category>内存</category>
        <category>编写ShellCode实现IAT HOOK</category>
        <category>ShellCode原则</category>
        <category>加载图标</category>
        <category>提取图标</category>
        <category>资源表</category>
        <category>傀儡进程加密壳</category>
        <category>ZwUnmapViewOfSection函数</category>
        <category>HTML</category>
        <category>文件包含</category>
        <category>sql注入</category>
        <category>MFC命令传递</category>
        <category>远控界面编写</category>
        <category>STL</category>
        <category>Vector容器</category>
        <category>Deque容器</category>
        <category>List容器</category>
        <category>Set容器</category>
        <category>Multiset容器</category>
        <category>Map容器</category>
        <category>Multimap容器</category>
        <category>Stack容器</category>
        <category>Queue容器</category>
        <category>priority_queue容器</category>
        <category>经典定长指令</category>
        <category>经典变长指令</category>
        <category>指令前缀</category>
        <category>KAPC</category>
        <category>QueueUserAPC</category>
        <category>NtQueueApcThread</category>
        <category>KeInitializeApc</category>
        <category>KeInsertQueueApc</category>
        <category>KiInsertQueueApc</category>
        <category>进程句柄表</category>
        <category>全局句柄表</category>
        <category>消息队列与线程</category>
        <category>Windows线程切换</category>
        <category>KiSwapContext</category>
        <category>SwapContext</category>
        <category>时钟中断</category>
        <category>时间片管理</category>
        <category>线程切换与TSS</category>
        <category>线程切换与FS</category>
        <category>线程切换与线程优先级</category>
        <category>快速调用</category>
        <category>中断调用</category>
        <category>分析ReadProcessMemory</category>
        <category>KiFastSystemCall</category>
        <category>KiIntSystemCall</category>
        <category>重写3环</category>
        <category>文件上传</category>
        <category>隐藏驱动</category>
        <category>IopLoadDriver</category>
        <category>延迟过程调用</category>
        <category>进程挂靠</category>
        <category>跨进程读写内存</category>
        <category>APC</category>
        <category>逆向分析NtReadVirtualMemory</category>
        <category>逆向分析NtWriteVIrtualMemory</category>
        <category>payload</category>
        <category>AD-Attack-Defense</category>
        <category>sysenter指令</category>
        <category>KiFastCallEntry函数</category>
        <category>KiSystemService函数</category>
        <category>Trap_Frame</category>
        <category>web安全</category>
        <category>Pentest</category>
        <item>
            <guid isPermalink="true">https://or0kit.github.io/Bin/Assembly/HardCode/%E7%A1%AC%E7%BC%96%E7%A0%81-Intel%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%BB%93%E6%9E%84/</guid>
            <title>硬编码-Intel指令编码结构</title>
            <link>https://or0kit.github.io/Bin/Assembly/HardCode/%E7%A1%AC%E7%BC%96%E7%A0%81-Intel%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%BB%93%E6%9E%84/</link>
            <category>经典定长指令</category>
            <category>经典变长指令</category>
            <category>指令前缀</category>
            <pubDate>Mon, 11 Apr 2022 10:24:20 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;楔子&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#楔子&#34;&gt;#&lt;/a&gt; 楔子&lt;/h1&gt;
&lt;p&gt;之前看过，不过并没有总结，今天总结一下，以后有时间了，写一个反汇编引擎。&lt;br /&gt;
学习 Intel 的硬编码指令格式主要就是查表了，记住那几张表就好了。&lt;/p&gt;
&lt;h1 id=&#34;什么是硬编码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是硬编码&#34;&gt;#&lt;/a&gt; 什么是硬编码&lt;/h1&gt;
&lt;p&gt;&lt;img data-src=&#34;image001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在计算机上程序不过是一堆二进制数字，其想要运行起来，即被 CPU 当成指令执行，是要遵循 Intel 的指令格式。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image002.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;每一条指令，最短 1 字节，最长 15 字节&lt;/p&gt;
&lt;p&gt;1、Intel 对指令参数的设计了一种表示方式，格式是 Zz 一个大写字母加上一个小写字母。&lt;/p&gt;
&lt;p&gt;2、大写字母表示寻找方式编码（寄存器，ModR/M，跳转相对地址，16:32 地址格式等等），从 A-Z 共 26 种.&lt;/p&gt;
&lt;p&gt;3、小写字母表示操作数的类型（byte，word，dword，fword 等等不定，根据 cpu 模式或改写指令决定）&lt;br /&gt;
z 有大约十几种表示方式。&lt;/p&gt;
&lt;p&gt;4、他们的组合再加上纯寄存器表示了 intel 的所有操作对象。&lt;/p&gt;
&lt;p&gt;具体参见 Intel 开发手卷第 2 卷的 1467 页。有详细的介绍。&lt;/p&gt;
&lt;h1 id=&#34;经典定长指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#经典定长指令&#34;&gt;#&lt;/a&gt; 经典定长指令&lt;/h1&gt;
&lt;h2 id=&#34;会修改寄存器的定长指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#会修改寄存器的定长指令&#34;&gt;#&lt;/a&gt; 会修改寄存器的定长指令。&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;PUSH/POP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0x50 	PUSH EAX&lt;br /&gt;
0x51 	PUSH ECX&lt;br /&gt;
0x52 	PUSH EDX&lt;br /&gt;
0x53 	PUSH EBX&lt;br /&gt;
0x54 	PUSH ESP&lt;br /&gt;
0x55 	PUSH EBP&lt;br /&gt;
0x56 	PUSH ESI&lt;br /&gt;
0x57 	PUSH EDI&lt;/p&gt;
&lt;p&gt;0x58	POP EAX&lt;br /&gt;
0x59	POP ECX&lt;br /&gt;
0x5A	POP EDX&lt;br /&gt;
0x5B 	POP EBX&lt;br /&gt;
0x5C 	POP ESP&lt;br /&gt;
0x5D 	POP EBP&lt;br /&gt;
0x5E	POP ESI&lt;br /&gt;
0x5F 	POP EDI&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;INC/DEC：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0x40 - 0x47		INC ERX&lt;br /&gt;
0x48 - 0x4F		DEC ERX&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image004.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;MOV Rb, Ib&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0xb0 - 0xb7		MOV Rb, Ib&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;MOV ERX, Id&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0xb8 - 0xbF		MOV ERX, Id&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image006.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;XCHG EAX, ERX&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0x90 - 0x97		XCHG EAX, ERX&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image005.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;以下的这些知识在 Intel 白皮书上都有，在此做个总结。&lt;/p&gt;
&lt;h3 id=&#34;特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h3&gt;
&lt;p&gt;1、记住 32 位、16、8 位的通用寄存器，按照顺序记住.&lt;/p&gt;
&lt;p&gt;EAX ECX EDX EBX ESP EBP ESI EDI&lt;br /&gt;
AX CX DX BX SP BP SI DI&lt;br /&gt;
AL CL DL BL&lt;br /&gt;
AH CH DH BH&lt;/p&gt;
&lt;p&gt;SP BP SI DI 的低 8 位是不能用的，但在 64 位中可以使用分割出的 spl bpl sil dil。&lt;/p&gt;
&lt;p&gt;2、将操作数编码到指令当中&lt;/p&gt;
&lt;h3 id=&#34;读表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#读表&#34;&gt;#&lt;/a&gt; 读表&lt;/h3&gt;
&lt;p&gt;1、i64/o64/d64&lt;/p&gt;
&lt;p&gt;i64：64 位无效&lt;/p&gt;
&lt;p&gt;o64：只 64 位有效&lt;/p&gt;
&lt;p&gt;d64：64 位模式下，操作数宽度默认为 64 位&lt;/p&gt;
&lt;p&gt;2、关于寄存器&lt;/p&gt;
&lt;p&gt;(1) 当操作码需要使用寄存器做为操作数时，寄存器的名字说明其宽度是 64、32、16、8 位.&lt;/p&gt;
&lt;p&gt;(2) eXX 比如 eAX 可以表示 AX EAX&lt;/p&gt;
&lt;p&gt;(3) rXX 比如 rAX 可以表示 AX EAX RAX&lt;/p&gt;
&lt;h2 id=&#34;会修改eip的定长指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#会修改eip的定长指令&#34;&gt;#&lt;/a&gt; 会修改 EIP 的定长指令&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;0x70 - 0x7F&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;条件跳转，后跟一个字节立即数的偏移 (有符号)，共两个字节。&lt;/p&gt;
&lt;p&gt;如果条件成立，跳转到 当前指令地址 + 当前指令长度 + Ib&lt;/p&gt;
&lt;p&gt;最大值：向前跳 7f，向后跳 80&lt;/p&gt;
&lt;p&gt;0x70  JO&lt;br /&gt;
0x71	JNO&lt;br /&gt;
0x72	JB/JNAE/JC&lt;br /&gt;
0x73	JNB/JAE/JNC&lt;br /&gt;
0x74	JZ/JE&lt;br /&gt;
0x75	JNZ/JNE&lt;br /&gt;
0x76	JBE/JNA&lt;br /&gt;
0x77	JNBE/JA&lt;br /&gt;
0x78	JS&lt;br /&gt;
0x79	JNS&lt;br /&gt;
0x7A	JP/JPE&lt;br /&gt;
0x7B	JNP/JPO&lt;br /&gt;
0x7C	JL/JNGE&lt;br /&gt;
0x7D	JNL/JGE&lt;br /&gt;
0x7E	JLE/JNG&lt;br /&gt;
0x7F	JNLE/JG&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;0x0F 0x80 - 0x0F 0x8F&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;条件跳转，后跟四个字节立即数的偏移 (有符号)，共五个字节。&lt;/p&gt;
&lt;p&gt;如果条件成立，跳转到 当前指令地址 + 当前指令长度 + Id&lt;/p&gt;
&lt;p&gt;最大值：向前跳 7FFFFFFFF，向后跳 80000000&lt;/p&gt;
&lt;p&gt;0x0F 0x80  	JO&lt;br /&gt;
0x0F 0x81		JNO&lt;br /&gt;
0x0F 0x82		JB/JNAE/JC&lt;br /&gt;
0x0F 0x83		JNB/JAE/JNC&lt;br /&gt;
0x0F 0x84		JZ/JE&lt;br /&gt;
0x0F 0x85		JNZ/JNE&lt;br /&gt;
0x0F 0x86		JBE/JNA&lt;br /&gt;
0x0F 0x87		JNBE/JA&lt;br /&gt;
0x0F 0x88		JS&lt;br /&gt;
0x0F 0x89		JNS&lt;br /&gt;
0x0F 0x8A		JP/JPE&lt;br /&gt;
0x0F 0x8B		JNP/JPO&lt;br /&gt;
0x0F 0x8C		JL/JNGE&lt;br /&gt;
0x0F 0x8D		JNL/JGE&lt;br /&gt;
0x0F 0x8E		JLE/JNG&lt;br /&gt;
0x0F 0x8F		JNLE/JG&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;其他指令&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0xE0  	LOOPNE/LOOPNZ Ib (Jb)			共 2 字节&lt;br /&gt;
 ECX = ECX - 1  当 ZF = 0 &amp;amp;&amp;amp; ECX!=0 时跳转到 当前指令地址 + 当前指令长度 + Ib&lt;/p&gt;
&lt;p&gt;0XE1     	LOOPE/LOOPZ Ib (Jb)			共 2 字节&lt;br /&gt;
 ECX = ECX - 1  当 ZF = 1 &amp;amp;&amp;amp; ECX != 0 时跳转到 当前指令地址 + 当前指令长度 + Ib&lt;/p&gt;
&lt;p&gt;0XE2	LOOP Ib (Jb)			共 2 字节&lt;br /&gt;
 ECX = ECX - 1  当 ECX!=0 时跳转到 当前指令地址 + 当前指令长度 + Ib&lt;/p&gt;
&lt;p&gt;0XE3	JrCXZ Ib (Jb) (在 32 位模式中，rCX 为 ECX)					共 2 字节&lt;br /&gt;
当 ECX = 0 时跳转到 当前指令地址 + 当前指令长度 + Ib&lt;br /&gt;
 (自己控制步长)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image009.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;0xE8	CALL Id (Jd)  		共 5 字节&lt;br /&gt;
 CALL 指令的下一条指令地址入栈后，跳转到 当前指令地址 + 当前指令长度 + Id&lt;/p&gt;
&lt;p&gt;0xE9	JMP Id (Jd)		共 5 字节&lt;br /&gt;
跳转到 当前指令地址 + 当前指令长度 + Id&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8 个段寄存器： ES CS SS DS FS GS LDTR TR (顺序固定)(段寄存器实际是个结构体，共 96 位，其中仅 16 位是汇编指令可以访问到的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0xEA	JMP Ap （Ap：六字节长度的直接地址）				共 7 字节&lt;br /&gt;
 JMP CS:Id  将 Ap 中的高 2 位赋值给 CS，低 4 位直接赋值给 EIP， 即跳转&lt;/p&gt;
&lt;p&gt;EA 12345678 1B00     JMP FAR 001B:78563412&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;0xEB	JMP Ib (Jb) （短跳）&lt;br /&gt;
跳转到 当前指令地址 + 当前指令长度 + Ib&lt;/p&gt;
&lt;p&gt;0xC3 	RET	共 1 字节&lt;br /&gt;
 EIP 出栈&lt;/p&gt;
&lt;p&gt;0xC2	RET Iw	共 3 字节&lt;br /&gt;
 EIP 出栈后，ESP = ESP + Iw&lt;/p&gt;
&lt;p&gt;0XCB	RETF （return far） 共 1 字节&lt;br /&gt;
出栈 8 个字节，低 4 个字节赋值给 EIP, 高 4 个字节中低 2 位赋值给 CS&lt;/p&gt;
&lt;p&gt;0xCA	RETF Iw	共 3 字节&lt;br /&gt;
出栈 8 个字节，低 4 个字节赋值给 EIP, 高 4 个字节中低 2 位赋值给 CS 后，ESP = ESP + Iw&lt;/p&gt;
&lt;p&gt;ret  -&amp;gt; pop eip&lt;br /&gt;
retf -&amp;gt; pop eip, pop cs&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image011.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;经典变长指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#经典变长指令&#34;&gt;#&lt;/a&gt; 经典变长指令&lt;/h1&gt;
&lt;h2 id=&#34;经典变长指令之modrm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#经典变长指令之modrm&#34;&gt;#&lt;/a&gt; 经典变长指令之 ModR/M&lt;/h2&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0x88  MOV Eb, Gb			G：通用寄存器&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0x89	MOV Ev, Gv			E：寄存器 &amp;#x2F; 内存&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0x8A	MOV Gb, Eb			b：字节&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0x8B	MOV Gv, Ev			v：Word, doubleword or quadword&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当指令中出现内存操作对象的时候，就需要在操作码后面附加一个字节来进行补充说明，这个字节被称为 ModR/M。			&lt;br /&gt;
该字节的 8 个比特位被分成了三部分：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;7-6&lt;/th&gt;
&lt;th&gt;5-3&lt;/th&gt;
&lt;th&gt;2-0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mod&lt;/td&gt;
&lt;td&gt;Reg/Opcode&lt;/td&gt;
&lt;td&gt;R/M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;其中，Reg/Opcode (第 3、4、5 位，共 3 个字节) 描述指令中的 G 部分，即寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器宽度&lt;/th&gt;
&lt;th&gt;000&lt;/th&gt;
&lt;th&gt;001&lt;/th&gt;
&lt;th&gt;010&lt;/th&gt;
&lt;th&gt;011&lt;/th&gt;
&lt;th&gt;100&lt;/th&gt;
&lt;th&gt;101&lt;/th&gt;
&lt;th&gt;110&lt;/th&gt;
&lt;th&gt;111&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;EAX&lt;/td&gt;
&lt;td&gt;ECX&lt;/td&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;td&gt;EBX&lt;/td&gt;
&lt;td&gt;ESP&lt;/td&gt;
&lt;td&gt;EBP&lt;/td&gt;
&lt;td&gt;ESI&lt;/td&gt;
&lt;td&gt;EDI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;AL&lt;/td&gt;
&lt;td&gt;CL&lt;/td&gt;
&lt;td&gt;DL&lt;/td&gt;
&lt;td&gt;BL&lt;/td&gt;
&lt;td&gt;AH&lt;/td&gt;
&lt;td&gt;CH&lt;/td&gt;
&lt;td&gt;DH&lt;/td&gt;
&lt;td&gt;BH&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Mod (第 6、7 位) 和 R/M (第 0、1、2 位) 共同描述指令中的 E 部分，即寄存器 / 内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，这 8 个位具体是如何工作的呢，Inter 操作手册给出了一张表&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image012.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;以下内容就是解释这个表。&lt;/p&gt;
&lt;p&gt;前面我们已经讨论了 Reg/Opcode 部分 (即 3、4、5 位) 是怎样描述寄存器的		&lt;br /&gt;
接下来我们重点说一下 Mod 和 R/M 是怎样合作描述寄存器 / 内存的&lt;/p&gt;
&lt;h3 id=&#34;mod-00&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mod-00&#34;&gt;#&lt;/a&gt; Mod = 00&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当 Mod = 00 时，ModR/M 字节通过寄存器直接进行内存寻址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如当操作指令为 88 01 时，其对应的汇编为 MOV BYTE PTR DS:[ECX], AL&lt;/p&gt;
&lt;p&gt;88 是操作指令，其后跟随的 01 为 ModR/M&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image014.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;0x88 描述了操作数宽度为 b (byte)，且操作数的顺序为 Eb Gb，所以这条汇编指令为 MOV BYTE PTR DS:[ECX], AL&lt;/p&gt;
&lt;p&gt;同理可以分析出如下操作指令对应的汇编指令&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8801 | mov byte ptr ds:[ecx],al&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8901 | mov dword ptr ds:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8A01 | mov al,byte ptr ds:[ecx]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8B01 | mov eax,dword ptr ds:[ecx]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;需要注意的：&lt;br /&gt;
&lt;strong&gt;ESP 指向栈顶，是浮动的，不确定的，Inter 将这个编码废弃，由另外的格式来说明。&lt;/strong&gt;	&lt;br /&gt;
&lt;strong&gt;EBP 指向栈底，而 [EBP] 通常存储上一个 EBP，所以 [EBP] 无数据操作意义，Inter 将这个编码废弃，改为立即数寻址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如 88 05 12 34 56 78 的汇编指令为 MOV BYTE PTR DS:[78563412], AL&lt;/p&gt;
&lt;p&gt;在 Intel 白皮书中 2-2 的表中可以看到对其有解释当 ModR/M 为 05 0D 15 1D 25 2D 35 3D…… 时，这个指令的后面还会接着取 4 个字节。&lt;/p&gt;
&lt;p&gt;例如：&lt;br /&gt;
882578563412 -&amp;gt; mov byte ptr ds:[0x12345678],ah&lt;br /&gt;
892578563412 -&amp;gt; mov dword ptr ds:[0x12345678],esp&lt;/p&gt;
&lt;h3 id=&#34;mod-01&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mod-01&#34;&gt;#&lt;/a&gt; Mod = 01&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当 Mod = 01 时，ModR/M 字节通过寄存器 + I8 进行内存寻址 (I 为立即数，即 8 位立即数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如当操作指令为 88 41 12 时，其对应的汇编为 MOV BYTE PTR DS:[ECX+12],AL&lt;br /&gt;
88 是操作指令，其后跟随的 41 为 ModR/M&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image015.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以这条汇编指令为 MOV BYTE PTR DS:[ECX+12],AL&lt;/p&gt;
&lt;p&gt;同理可以分析出如下操作指令对应的汇编指令&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8841 12 | mov byte ptr ds:[ecx+12],al  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8941 12 | mov dword ptr ds:[ecx+12],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8A41 12 | mov al,byte ptr ds:[ecx+12]  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8B41 12 | mov eax,dword ptr ds:[ecx+12]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当 R/M = 100 时 (即 ESP)，该指令编码废弃，修改为其他含义，既 SIB，后面再一起总结。&lt;/p&gt;
&lt;h3 id=&#34;mod-10&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mod-10&#34;&gt;#&lt;/a&gt; Mod = 10&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当 Mod = 10 时，ModR/M 字节通过寄存器 + I32 进行内存寻址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如当操作指令为 88 81 12 34 56 78 时，其对应的汇编为 MOV BYTE PTR DS:[ECX+78563412],AL&lt;/p&gt;
&lt;p&gt;88 是操作指令，其后跟随的 81 为 ModR/M&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image016.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以这条汇编指令为 MOV BYTE PTR DS:[ECX+78563412],AL&lt;/p&gt;
&lt;p&gt;同理可以分析出如下操作指令对应的汇编指令&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8881 78563412 | mov byte ptr ds:[ecx+12345678],al  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8981 78563412 | mov dword ptr ds:[ecx+12345678],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8A81 78563412 | mov al,byte ptr ds:[ecx+12345678]  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8B81 78563412 | mov eax,dword ptr ds:[ecx+12345678]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当 R/M = 100 时 (即 ESP)，该指令编码废弃，修改为其他含义，既 SIB，后面再一起总结。&lt;/p&gt;
&lt;h3 id=&#34;mod-11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mod-11&#34;&gt;#&lt;/a&gt; Mod = 11&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当 Mod = 11 时，ModR/M 字节直接操作两个寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如当操作指令为 88 C1 时，其对应的汇编为 MOV CL,AL&lt;/p&gt;
&lt;p&gt;88 是操作指令，其后跟随的 C1 为 ModR/M&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image017.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以这条汇编指令为 MOV CL,AL&lt;/p&gt;
&lt;p&gt;同理可以分析出如下操作指令对应的汇编指令&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;88C1 | mov cl,al   &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;89C1 | mov ecx,eax &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8AC1 | mov al,cl   &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8BC1 | mov eax,ecx&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;经典变长指令-regopcode&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#经典变长指令-regopcode&#34;&gt;#&lt;/a&gt; 经典变长指令 Reg/Opcode&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;7-6&lt;/th&gt;
&lt;th&gt;5—3&lt;/th&gt;
&lt;th&gt;2-0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mod&lt;/td&gt;
&lt;td&gt;Reg/Opcode&lt;/td&gt;
&lt;td&gt;R/M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在上面，3-5 位用来标识寄存器，Mod 字段 与 R/M 字段共同用来标识寄存器与内存&lt;/p&gt;
&lt;p&gt;但 3-5 字段，并不仅仅用来标识寄存器，有些时候，用来标识 Opcode&lt;/p&gt;
&lt;p&gt;参见 Table A-2 中 ：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image018.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;80 81 82 83 这几个编码并没有给出具体的操作码。&lt;/p&gt;
&lt;p&gt;这里要注意：&lt;strong&gt;凡是出现 Grp 的，均参见 TableA-6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image019.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;举例说明：&lt;/p&gt;
&lt;p&gt;80 65 08 FF&lt;/p&gt;
&lt;p&gt;查表步骤：&lt;/p&gt;
&lt;p&gt;1、第一个字节为 80 查 Table-2 表，得到对应结构：Eb,Ib&lt;/p&gt;
&lt;p&gt;2、第二个字节为 ModR/M 字段，所以查分 65:&lt;/p&gt;
&lt;p&gt;01 100 101&lt;/p&gt;
&lt;p&gt;Mod 与 R/M 字段 查 Table2-2 得到对应的结构：[EBP+DIS8]&lt;/p&gt;
&lt;p&gt;3、100 字段 查表 TableA-6 得到对应操作码为：AND&lt;/p&gt;
&lt;p&gt;4、最终的指令格式：&lt;/p&gt;
&lt;p&gt;AND [ebp+dis8],Ib&lt;/p&gt;
&lt;p&gt;AND BYTE PTR SS:[EBP+08],0xFF&lt;/p&gt;
&lt;h2 id=&#34;经典变长指令之sib字段&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#经典变长指令之sib字段&#34;&gt;#&lt;/a&gt; 经典变长指令之 SIB 字段&lt;/h2&gt;
&lt;p&gt;ModR/M 字段是用来进行内存寻址的，可当地址形如 DS:[EAX + ECX*2 + 12345678] 时，仅仅靠 ModR/M 字段，是描述不出来的。								&lt;br /&gt;
这时就在 ModR/M 后面增加一个 SIB 字节，与 ModR/M 字段共同描述。&lt;/p&gt;
&lt;p&gt;下图是前面没有涉及到的三种情况。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Address&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Mod&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;R/M&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[--][--]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;00&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[--][--]+disp8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;01&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[--][--]+disp32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这三种情况表示，在 ModR/M 字节后，还紧跟着一个 SIB 字节。SIB 字节的 8 个位被分成了三部分：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;7—6&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;5-3&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;2-0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Scale&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Index&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Base&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在例子 DS:[EAX + ECX*2 + 12345678] 中， Scale 描述 21， Index 描述 ECX, Base 描述 EAX，而 12345678 由 ModR/M 字段决定。										&lt;br /&gt;
所以 SIB 字段描述的方式为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Base + Index*2^Scale&lt;/code&gt;  (Scale 描述 2Scale，所以只能为 *1 *2 *4 *8)&lt;/p&gt;
&lt;h3 id=&#34;例子分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#例子分析&#34;&gt;#&lt;/a&gt; 例子分析&lt;/h3&gt;
&lt;p&gt;下面我们通过分析指令，来看看 SIB 是怎么工作的&lt;/p&gt;
&lt;p&gt;MOV BYTE PTR DS:[EAX+ECX*2+78563412],AL&lt;/p&gt;
&lt;p&gt;操作码&lt;/p&gt;
&lt;p&gt;这条指令的原型为 MOV Eb Gb, 所以操作码为 0x88。且操作数中有 Eb，所以必然存在 ModR/M 字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ModR/M 字节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、Gb 为 AL，所以 Reg/Opcode 部分为 000&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Mod&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Reg/Opcode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;R/M&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 0 0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;2、内存地址为 寄存器 + I32 的格式，所以 Mod 部分为 10，偏移为 78563412&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Mod&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Reg/Opcode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;R/M&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;000&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3、内存地址中寄存器部分多个寄存器，即在 ModR/M 字节后，还跟着一个 SIB 字节，所以 R/M 部分为 100&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Mod&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Reg/Opcode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;R/M&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;000&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由此，ModR/M 字节为 0x84&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIB 字节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、DS:[EAX+ECX*2+78563412] 中，Base 对应着 EAX，所以 Base 部分为 000&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scale&lt;/th&gt;
&lt;th&gt;Index&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Base&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;2、Index 对应着 ECX，所以 Index 部分为 001&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scale&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Index&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Base&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 0 1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3、Scale 对应着 21，所以 Scale 部分为 01&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Scale&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Index&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Base&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 1 0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 0 1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由此，SIB 字节为 0x48&lt;/p&gt;
&lt;p&gt;以上总结为：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image020.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;由上，可得出指令编码为 88 84 48， 再加上偏移 12345678，完整的指令编码为 88 84 48 12 34 56 78&lt;/p&gt;
&lt;p&gt;在 xdbg 中查看：&lt;/p&gt;
&lt;p&gt;888448 12345678 | mov byte ptr ds:[eax+ecx*2+78563412],al&lt;/p&gt;
&lt;p&gt;无误！&lt;/p&gt;
&lt;p&gt;SIB 字段的图表如下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image013.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;1、当 Index = 100b 时，Index 被 0 替代，此时只有 Base 有效&lt;/p&gt;
&lt;p&gt;2、当 Base = 101b 时，Base 被 0 替代，此时只用 Index 有效&lt;/p&gt;
&lt;p&gt;作业：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;89 2C 15&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;89 mov Ev, Gv&lt;/p&gt;
&lt;p&gt;2C --&amp;gt; 00 101 100&lt;/p&gt;
&lt;p&gt;Mod 0 Reg/Opcode 5 R/M 4&lt;/p&gt;
&lt;p&gt;Reg/Opcode 5 --&amp;gt;  mov Ev, ebp&lt;/p&gt;
&lt;p&gt;Mod 0 R/M 4 --&amp;gt; SIB --&amp;gt;  mov [-][-],ebp&lt;/p&gt;
&lt;p&gt;15 --&amp;gt; 00 010 101&lt;/p&gt;
&lt;p&gt;Scale 0 Index 2 Base 5&lt;/p&gt;
&lt;p&gt;Base 5 Mod 0 --&amp;gt; [Scale Index]+ dip32&lt;/p&gt;
&lt;p&gt;[Scale Index] --&amp;gt; Scale 0 Index 2  --&amp;gt; [edx]&lt;/p&gt;
&lt;p&gt;mov [edx+dip32],ebp&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;89AC15&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;89 mov Ev, Gv&lt;/p&gt;
&lt;p&gt;AC --&amp;gt; 10 101 100&lt;/p&gt;
&lt;p&gt;Mod 2 Reg/Opcode 5 R/M 4&lt;/p&gt;
&lt;p&gt;Reg/Opcode 5 --&amp;gt;  mov Ev, ebp&lt;/p&gt;
&lt;p&gt;Mod 0 R/M 4 --&amp;gt; SIB --&amp;gt;  mov [-][-],ebp&lt;/p&gt;
&lt;p&gt;15 --&amp;gt; 00 010 101&lt;/p&gt;
&lt;p&gt;Scale 0 Index 2 Base 5&lt;/p&gt;
&lt;p&gt;Base 5 Mod 2 --&amp;gt; [Scale Index] + dip32 + [EBP]&lt;/p&gt;
&lt;p&gt;[Scale Index] --&amp;gt; Scale 0 Index 2  --&amp;gt; [edx]&lt;/p&gt;
&lt;p&gt;mov [edx+ebp+dip32],ebp&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;898461&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;89 mov Ev,Gv&lt;/p&gt;
&lt;p&gt;84 --&amp;gt; 10 000 100&lt;/p&gt;
&lt;p&gt;Mod 2 Reg/Opcode 0 R/M 4&lt;/p&gt;
&lt;p&gt;Reg/Opcode 0 --&amp;gt; mov Ev,eax&lt;/p&gt;
&lt;p&gt;Mod 2 R/M 4 --&amp;gt; SIB --&amp;gt; mov SIB+dip32 ,eax&lt;/p&gt;
&lt;p&gt;SIB 的描述为：  &lt;code&gt;Base + Index*2^Scale&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;61 --&amp;gt; 01 100 001&lt;/p&gt;
&lt;p&gt;Scale 1 Index 4 Base 1&lt;/p&gt;
&lt;p&gt;Base 1 --&amp;gt; ecx&lt;/p&gt;
&lt;p&gt;Scale 1 Index 4 --&amp;gt; none&lt;/p&gt;
&lt;p&gt;所以 SIB 为 ecx&lt;/p&gt;
&lt;p&gt;mov [ecx+dip32],eax&lt;/p&gt;
&lt;h1 id=&#34;指令前缀&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令前缀&#34;&gt;#&lt;/a&gt; 指令前缀&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;段前缀：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;段寄存器的作用：早期 8086cpu 寻址范围小，Inter 便通过段寄存器来拓展内存。即通过段寄存器基址 + 偏移的方式来寻址。&lt;/p&gt;
&lt;p&gt;[] 中的地址为有效地址 (Effect Address)，有效地址 + 段寄存器基址才是实际地址 LA (线性地址 Line Address)。&lt;/p&gt;
&lt;p&gt;线性地址 = 段基址 + 有效地址&lt;/p&gt;
&lt;p&gt;在后来的 80386 时，cpu 的寻址范围大大提升，这些段寄存器便被用作了其他用途。但是 DS:[] 类似&lt;/p&gt;
&lt;p&gt;这种寻址格式却被保留了下来。&lt;/p&gt;
&lt;p&gt;实际上操作码已经决定了寻址时使用哪个段寄存器作为基址，不需要其他字节描述。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、如果没有特别说明，[] 前为 DS，即 DS:[]	&lt;br /&gt;
2、PUSH POP 指令，以及在 [] 中使用 ESP/EBP 的，使用 SS 段	&lt;br /&gt;
3、在 [Base + Index*2Scale + I] 中，以 Base 为判断条件，没有特别说明，用 DS。如果 Base 为 ESP/EBP，则用 SS 段.	&lt;br /&gt;
4、串操作指令一般使用 ES。MOV ES:[EDI] DS:[ESI] 中，目标 EDI 使用 ES 段，其他使用 DS 段.	&lt;br /&gt;
5、EIP 指向当前指令，EIP 取指令时使用的是 CS 段.	&lt;br /&gt;
6、如果指令加段寄存器前缀，则该条指令一律用这个段，如果加多个段寄存器前缀，默认只看 op 前的那个.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;26 - es&lt;br /&gt;
2e - cs&lt;br /&gt;
36 - ss&lt;br /&gt;
3e - ds&lt;br /&gt;
64 - fs&lt;br /&gt;
65 - gs&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 898461 00000000    | mov dword ptr ds:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 26:898461 00000000 | mov dword ptr es:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 2E:898461 00000000 | mov dword ptr cs:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 36:898461 00000000 | mov dword ptr ss:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 3E:898461 00000000 | mov dword ptr ds:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 64:898461 00000000 | mov dword ptr fs:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;| 65:898461 00000000 | mov dword ptr gs:[ecx],eax&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;操作指令前缀&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0x66 	将操作数改为 16 字节。&lt;/p&gt;
&lt;p&gt;例子 50 为 PUSH EAX, 而 66 50 则为 PUSH AX&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;50    PUSH EAX	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;66:50 PUSH AX&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;操作指令前缀：修改默认寻址方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0x67 	将操作数改为 16 字节。&lt;/p&gt;
&lt;p&gt;例子 50 为 PUSH EAX, 而 66 50 则为 PUSH AX&lt;/p&gt;
&lt;figure class=&#34;highlight raw&#34;&gt;&lt;figcaption data-lang=&#34;&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;8801          MOV BYTE PTR DS:[ECX],AL	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;67:8801       MOV BYTE PTR DS:[BX+DI],AL&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;指令前缀更多信息参见 Intel 白皮书第 2 卷的 2.1.1&lt;/p&gt;
&lt;h1 id=&#34;硬编码总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬编码总结&#34;&gt;#&lt;/a&gt; 硬编码总结&lt;/h1&gt;
&lt;p&gt;1、操作码决定后面有没有 ModR/M 字段和立即数&lt;/p&gt;
&lt;p&gt;2、ModR/M 决定后面有没有 SIB 字节和偏移&lt;/p&gt;
&lt;p&gt;3、操作指令中只要包含 Ev/Eb，则指令中一定有 ModR/M 字节&lt;/p&gt;
&lt;p&gt;4、只需要把操作码确定下来，那么后面有什么字段，就都能确定了。即一切由操作码决定。&lt;/p&gt;
&lt;p&gt;5、操作码长度，需要查的对应的表。&lt;/p&gt;
&lt;p&gt;一个字节：00 - FF (TableA-2   0F 除外)&lt;/p&gt;
&lt;p&gt;两个字节：0F 00 - 0F FF (TableA-3)&lt;/p&gt;
&lt;p&gt;三个字节：0F 38 / 0F 3A (TableA-3 TableA-4 TableA-5)&lt;/p&gt;
&lt;p&gt;有一些硬编码不同，但他们实现的汇编指令一样。&lt;/p&gt;
&lt;p&gt;例如：&lt;br /&gt;
8901 与 898461 00000000 都代表着 mov [ecx],eax;&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#reference&#34;&gt;#&lt;/a&gt; Reference&lt;/h1&gt;
&lt;p&gt;滴水硬编码课件&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://or0kit.github.io/Bin/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</guid>
            <title>汇编学习</title>
            <link>https://or0kit.github.io/Bin/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</link>
            <category>x86汇编指令</category>
            <pubDate>Wed, 24 Mar 2021 20:19:17 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;之前学的，因为一些事情就耽搁了，转而学其他的了，现在有时间了，打算接着学。&lt;/p&gt;
&lt;h1 id=&#34;内存格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存格式&#34;&gt;#&lt;/a&gt; 内存格式&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;每个内存单元宽度为 8&lt;/li&gt;
&lt;li&gt;【0x 编号】称为内存地址&lt;/li&gt;
&lt;li&gt;内存是存储数据的，内存地址是对存储数据的一个标识，指向数据却不是数据，通过内存地址的指引，可以访问到内存当中指向的数据.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内存最小的单位是一个字节 ==&amp;gt;&amp;gt; 8 个二进制数  ==&amp;gt;&amp;gt; 两位的十六进制数&lt;/p&gt;
&lt;p&gt;一个内存单元能存一个两位的十六进制数，而这就是内存数据&lt;/p&gt;
&lt;h1 id=&#34;简单指令intel汇编语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简单指令intel汇编语法&#34;&gt;#&lt;/a&gt; 简单指令 (intel 汇编语法)&lt;/h1&gt;
&lt;h2 id=&#34;mov&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mov&#34;&gt;#&lt;/a&gt; mov&lt;/h2&gt;
&lt;p&gt;格式：  &lt;code&gt;mov destination, source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov eax, ebx&lt;/code&gt;   // 将 EBX 中的内容复制到 EAX 寄存器中&lt;br /&gt;
 &lt;code&gt;mov eax, 0x42&lt;/code&gt;  // 将立即数 0x42 复制到 EAX 寄存器中&lt;br /&gt;
 &lt;code&gt;mov eax, [0x443212C4]&lt;/code&gt;  // 将内存地址 0x443212C4 的四个字节复制到 EAX 寄存器&lt;br /&gt;
 &lt;code&gt;mov eax, [ebx+esi*4]&lt;/code&gt;   // 将 ebx+esi*4 等式结果只想的内存地址处 4 个字节复制至 EAX&lt;/p&gt;
&lt;h2 id=&#34;lea&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lea&#34;&gt;#&lt;/a&gt; lea&lt;/h2&gt;
&lt;p&gt;格式：  &lt;code&gt;lea destination, source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;lea 指令用来将一个内存地址赋给目的操作数。&lt;br /&gt;
例如，  &lt;code&gt;lea eax, [ebx+8]&lt;/code&gt;  就是将 EBX+8 的值给 EAX。&lt;br /&gt;
相反的， &lt;code&gt;mov eax, [ebx+8]&lt;/code&gt;  则加载内存中地址为 EBX+8 处的数据。&lt;/p&gt;
&lt;h2 id=&#34;加减运算sub-add-inc-dec&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加减运算sub-add-inc-dec&#34;&gt;#&lt;/a&gt; 加减运算：sub add inc dec&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;label&#34;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指令&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sub eax,0x10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX 寄存器值减去 0x10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add eax,ebx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将 EBX 值加入 EAX 并将结果保存至 EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;inc edx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX 值递增 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dec ecx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ECX 值递减 1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;乘除运算mul-div&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#乘除运算mul-div&#34;&gt;#&lt;/a&gt; 乘除运算:mul div&lt;/h2&gt;
&lt;p&gt;乘法和除法都使用了一个预先规定的寄存器。因此其运算就是指令码加上寄存器要去乘除的值。&lt;br /&gt;
 &lt;code&gt;mul&lt;/code&gt;  和 &lt;code&gt;div&lt;/code&gt;  指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。&lt;br /&gt;
 &lt;code&gt;mul value&lt;/code&gt;  指令总是将 &lt;code&gt;eax&lt;/code&gt;  乘上 &lt;code&gt;value&lt;/code&gt; 。因此， &lt;code&gt;EAX&lt;/code&gt;  寄存器必须在乘法指令出现前就赋值好。&lt;/p&gt;
&lt;p&gt;乘法的结果以 64 位的形式分开存储在两个寄存器中： &lt;code&gt;EDX&lt;/code&gt;  和 &lt;code&gt;EAX&lt;/code&gt; 。其中 EDX 存储了高的 32 位，EAX 存储低的 32 位。&lt;/p&gt;
&lt;p&gt;32 位模式下，MUL（无符号数乘法）指令有三种类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一种执行 8 位操作数与 AL 寄存器的乘法；
第二种执行 16 位操作数与 AX 寄存器的乘法；
第三种执行 32 位操作数与 EAX 寄存器的乘法。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MUL reg/mem8
MUL reg/meml6
MUL reg/mem32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被乘数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;乘数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AL&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DX:AX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX:EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。&lt;/p&gt;
&lt;p&gt;有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。&lt;/p&gt;
&lt;p&gt;32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DIV reg/mem8
DIV reg/meml6
DIV reg/mem32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下表给出了被除数、除数、商和余数之间的关系：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被除数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;除数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;商&lt;/td&gt;
&lt;td&gt;余数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AL&lt;/td&gt;
&lt;td&gt;AH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DX:AX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AX&lt;/td&gt;
&lt;td&gt;DX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EDX:EAX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reg/mem32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EAX&lt;/td&gt;
&lt;td&gt;EDX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数，商存放到 RAX，余数存放在 RDX 中。&lt;/p&gt;
&lt;h2 id=&#34;否操作指令not&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#否操作指令not&#34;&gt;#&lt;/a&gt; 否操作指令 NOT&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;NOT OPRD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把 OPRD 取反，再回送给 OPRD&lt;/p&gt;
&lt;p&gt;对标志位没有影响&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image003.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;与操作指令and与&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#与操作指令and与&#34;&gt;#&lt;/a&gt; 与操作指令 AND [与]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AND OPRD1，OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;OPRD1 和 OPRD2 执行与操作，结果送到 OPRD1&lt;/p&gt;
&lt;p&gt;执行后，CF＝OF＝0，标志 PF，ZF，SF 反映运算结果，AF 未定义&lt;/p&gt;
&lt;p&gt;某个操作数自身与，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;label&#34;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov al, 00001111b&lt;/code&gt; &lt;br /&gt;
 &lt;code&gt;and al, 11110101b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后 &lt;code&gt;al&lt;/code&gt;  的结果就是 &lt;code&gt;00000101b&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;或操作指令 OR [或]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;OR OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标志位同与运算指令&lt;/p&gt;
&lt;p&gt;某个操作数自身或，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image002.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;异或操作指令xor异或&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异或操作指令xor异或&#34;&gt;#&lt;/a&gt; 异或操作指令 XOR [异或]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XOR OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标志位同与运算指令&lt;/p&gt;
&lt;p&gt;某个操作数自身异或，值不变，可使进位标志 CF＝0&lt;/p&gt;
&lt;p&gt;与 0 异或，不变，与 1 异或，取反。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image004.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;测试指令test&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#测试指令test&#34;&gt;#&lt;/a&gt; 测试指令 TEST&lt;/h2&gt;
&lt;p&gt;指令格式：TEST  R/M,R/M/IMM&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEST OPRD1 OPRD2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指令与 AND 类似，但结果不回送&lt;/p&gt;
&lt;p&gt;指令执行后，ZF，PF，SF 反映运算结果，CF＝OF＝0&lt;/p&gt;
&lt;p&gt;该指令在一定程序上和 CMP 指令时类似的，两个数值进行与操作，结果不保存，但是会改变相应标志位.&lt;/p&gt;
&lt;p&gt;与的操作表项如下：&lt;/p&gt;
&lt;p&gt;1 and 1 = 1	&lt;br /&gt;
1 and 0 = 0&lt;br /&gt;
0 and 1 = 0&lt;br /&gt;
0 and 0 = 0&lt;/p&gt;
&lt;p&gt;常见用法：用这个指令，可以确定某寄存器是否等于 0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEST EAX,EAX&lt;/code&gt; 			观察 Z 位&lt;/p&gt;
&lt;p&gt;但是如果 EAX 的二进制某些位为 1 的话，那么运算的结果就不为零。&lt;/p&gt;
&lt;h2 id=&#34;cmp指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cmp指令&#34;&gt;#&lt;/a&gt; CMP 指令&lt;/h2&gt;
&lt;p&gt;指令格式：CMP  R/M,R/M/IMM&lt;/p&gt;
&lt;p&gt;该指令是比较两个操作数，实际上，它相当于 SUB 指令，但是相减的结构并不保存到第一个操作数中。&lt;/p&gt;
&lt;p&gt;只是根据相减的结果来改变零标志位的，当两个操作数相等的时候，零标志位置 1。&lt;/p&gt;
&lt;h2 id=&#34;移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#移位指令&#34;&gt;#&lt;/a&gt; 移位指令&lt;/h2&gt;
&lt;p&gt;移位指令分为算术移位和逻辑移位。&lt;/p&gt;
&lt;p&gt;移动操作数的位有两种方法。第一种是逻辑移位 (logic shift)，空出来的位用 0 填充。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。注意，位 7 被填充为 0：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image005.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下图所示为二进制数 1100 1111 逻辑右移一位，得到 0110 0111。最低位移入进位标志位：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image006.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;另一种移位的方法是算术移位 (arithmetic shift)，空出来的位用原数据的符号位填充：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;例如，二进制数 1100 1111，符号位为 1。算术右移一位后，得到 1110 0111：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image008.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;逻辑移位:   &lt;code&gt;SHL&lt;/code&gt; 、 &lt;code&gt;SHR&lt;/code&gt; &lt;br /&gt;
 算术移位:   &lt;code&gt;CAL&lt;/code&gt; 、 &lt;code&gt;CAR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无符号数的乘法和除法可以用逻辑移位；&lt;br /&gt;
 有符号数的乘法和除法可以用算术移位；&lt;/p&gt;
&lt;h3 id=&#34;逻辑移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#逻辑移位指令&#34;&gt;#&lt;/a&gt; 逻辑移位指令&lt;/h3&gt;
&lt;p&gt;SHL（左移）指令使目的操作数逻辑左移一位，最低位用 0 填充。最高位移入进位标志位，而进位标志位中原来的数值被丢弃&lt;br /&gt;
 SHR（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。最低位复制到进位标志位，而进位标志位中原来的数值被丢弃&lt;/p&gt;
&lt;p&gt;SHL/SHR 的第一个操作数是目的操作数，第二个操作数是移位次数：&lt;br /&gt;
SHL/SHR destination,count&lt;/p&gt;
&lt;p&gt;该指令可用的操作数类型如下所示：&lt;br /&gt;
SHL/SHR reg, imm8&lt;br /&gt;
SHL/SHR mem, imm8&lt;br /&gt;
SHL/SHR reg, CL&lt;br /&gt;
SHL/SHR mem, CL&lt;/p&gt;
&lt;p&gt;x86 处理器允许 imm8 为 0〜255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和 RCL 指令。&lt;/p&gt;
&lt;h3 id=&#34;算术移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#算术移位指令&#34;&gt;#&lt;/a&gt; 算术移位指令&lt;/h3&gt;
&lt;p&gt;算数移位指令分为：算数左移 SAL (Shift Algebraic Left) 和算数右移 SAR (Shift Algebraic Right);&lt;br /&gt;
 指令格式:  &lt;code&gt;SAL/SAR reg/mem,CL/imm&lt;/code&gt; &lt;br /&gt;
 受影响的标志位：CF,OF,PF,SF,ZF; 对 AF 的影响无定义；&lt;/p&gt;
&lt;h3 id=&#34;循环移位指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#循环移位指令&#34;&gt;#&lt;/a&gt; 循环移位指令&lt;/h3&gt;
&lt;p&gt;循环移位指令 ror 和 rol 与移位指令类似，但移出的那一位会被填到另一端空出来的位置上，即右循环指令（ror）会将最低位循环一到最高位；左循环移位（rol）则相反。&lt;/p&gt;
&lt;h2 id=&#34;nop指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nop指令&#34;&gt;#&lt;/a&gt; NOP 指令&lt;/h2&gt;
&lt;p&gt;nop 指令什么也不做。当它出现时，直接执行下一条指令。&lt;br /&gt;
nop 指令实际上是 xchg eax,eax 的一个谓名字&lt;/p&gt;
&lt;h2 id=&#34;push-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#push-指令&#34;&gt;#&lt;/a&gt; push 指令&lt;/h2&gt;
&lt;h2 id=&#34;pop-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pop-指令&#34;&gt;#&lt;/a&gt; pop 指令&lt;/h2&gt;
&lt;h1 id=&#34;rep-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rep-指令&#34;&gt;#&lt;/a&gt; rep 指令&lt;/h1&gt;
&lt;p&gt;按计数寄存器 ecx 中指定的次数重复执行字符串指令&lt;/p&gt;
&lt;p&gt;rep movsd&lt;/p&gt;
&lt;p&gt;取 esi 的值 到 edi 指向的地址&lt;/p&gt;
&lt;h1 id=&#34;pause指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pause指令&#34;&gt;#&lt;/a&gt; pause 指令&lt;/h1&gt;
&lt;p&gt;提高自旋等待循环的性能。当执行 “自旋 - 等待循环” 时，Pentium 4 或 Intel Xeon 处理器在退出循环时会遭受严重的性能损失，因为它检测到可能的内存顺序冲突。PAUSE 指令向处理器提示代码序列是一个自旋 - 等待循环。在大多数情况下，处理器使用这个提示来避免内存顺序冲突，这大大提高了处理器性能。因此，建议在所有自旋 - 等待循环中放置 PAUSE 指令。&lt;/p&gt;
&lt;p&gt;PAUSE 指令的另一个功能是降低 Pentium 4 处理器在执行旋转循环时的功耗。Pentium 4 处理器可以非常快地执行一个自旋 - 等待循环，导致处理器在等待其所旋转的资源变得可用时消耗大量电力。在自旋 - 等待循环中插入暂停指令可以大大降低处理器的功耗。&lt;/p&gt;
&lt;p&gt;这个指令被引入到奔腾 4 处理器中，但它向后兼容所有的 IA-32 处理器。在早期的 IA-32 处理器中，PAUSE 指令就像 NOP 指令一样工作。奔腾 4 和英特尔 Xeon 处理器将 PAUSE 指令实现为预定义延迟。延迟是有限的，对于某些处理器可以是零。该指令不会改变处理器的体系结构状态 (也就是说，它实际上执行了一个延迟的无操作操作)。&lt;/p&gt;
&lt;p&gt;该指令的操作在非 64 位模式和 64 位模式下是相同的。&lt;/p&gt;
&lt;h1 id=&#34;lock指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lock指令&#34;&gt;#&lt;/a&gt; LOCK 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;在伴随指令执行期间断言处理器的 LOCK# 信号 (将指令转换为原子指令)。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;在多处理器环境中，LOCK# 信号确保处理器在断言信号时独占任何共享内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意，在后来的 Intel 64 和 IA-32 处理器 (包括 Pentium 4, Intel Xeon 和 P6 系列处理器) 中，锁可能会在没有 LOCK# 信号的情况下发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCK 前缀只能放在以下指令的前面，并且只能放在目的操作数为内存操作数的指令的前面：ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD 和 XCHG。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 LOCK 前缀与这些指令中的一个一起使用，并且源操作数是内存操作数，则可能会生成一个未定义的操作码异常 (#UD)。&lt;br /&gt;
如果 LOCK 前缀与任何不在上面列表中的指令一起使用，也会生成一个未定义的操作码异常。&lt;br /&gt;
XCHG 指令总是对 LOCK# 信号进行断言，而不管 LOCK 前缀是否存在。&lt;br /&gt;
LOCK 前缀通常与 BTS 指令一起使用，在共享内存环境中的内存位置上执行 read-modifywrite 操作。&lt;br /&gt;
LOCK 前缀的完整性不受内存字段对齐的影响。&lt;br /&gt;
内存锁定在任意错位的字段中被观察到。&lt;br /&gt;
该指令的操作在非 64 位模式和 64 位模式下是相同的&lt;/p&gt;
&lt;h2 id=&#34;protected-mode-exceptions&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#protected-mode-exceptions&#34;&gt;#&lt;/a&gt; Protected Mode Exceptions&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#UD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 LOCK 前缀与以下未列出的指令一起使用: ADD,ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC,NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG，就会产生异常。&lt;/p&gt;
&lt;p&gt;其他异常可以由该指令在应用 LOCK 前缀时生成。&lt;/p&gt;
&lt;h1 id=&#34;xadd-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#xadd-指令&#34;&gt;#&lt;/a&gt; xadd 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;将第一个操作数 (目标操作数) 与第二个操作数 (源操作数) 交换，然后将两个值的和加载到目标操作数中。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;目标操作数可以是寄存器或内存位置； 源操作数是一个寄存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 64 位模式下，指令的默认操作大小是 32 位。&lt;/p&gt;
&lt;p&gt;以 REX 的形式使用 REX 前缀。R 允许访问附加寄存器 (R8-R15)。以 REX 的形式使用 REX 前缀。W 将操作提升到 64 位。有关编码数据和限制，请参阅本节开头的汇总图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;bts指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bts指令&#34;&gt;#&lt;/a&gt; bts 指令&lt;/h1&gt;
&lt;p&gt;例子：  &lt;code&gt;lock bts dword ptr [esi], 0 ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BTS 指令的作用：&lt;br /&gt;
两件事:&lt;br /&gt;
 一、&lt;br /&gt;
&lt;strong&gt;取 esi 比特位的第 0 位存在 CF 标志位中。&lt;/strong&gt;&lt;br /&gt;
二、&lt;br /&gt;
 &lt;code&gt;lock bts dword ptr [esi],0&lt;/code&gt; &lt;br /&gt;
&lt;strong&gt; 将 dword ptr [esi] 指向的内存地址的第 0 位置 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;cmpxchg8b-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cmpxchg8b-指令&#34;&gt;#&lt;/a&gt; cmpxchg8b 指令&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;CMPXCHG8B m64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比较 EDX:EAX 中的 64 位值 (或 RDX:RAX 中的 128 位值，如果操作数是 128 位) 和操作数 (目的操作数)。&lt;br /&gt;
如果两个值相等，则目标操作数中存储 ECX:EBX 中的 64 位值 (或 RCX:RBX 中的 128 位值)。&lt;br /&gt;
否则，目标操作数中的值被加载到 EDX:EAX (或 RDX:RAX) 中。&lt;br /&gt;
目标操作数是一个 8 字节内存位置 (如果操作数大小为 128 位，则为 16 字节内存位置)。&lt;br /&gt;
对于 EDX:EAX 和 ECX:EBX 寄存器对，EDX 和 ECX 包含高阶 32 位，EAX 和 EBX 包含 64 位值的低阶 32 位。&lt;br /&gt;
对于 RDX:RAX 和 RCX:RBX 寄存器对，RDX 和 RCX 为高 64 位，RAX 和 RBX 为 128 位的低 64 位。&lt;br /&gt;
该指令可以与 LOCK 前缀一起使用，以允许该指令以原子方式执行。&lt;/p&gt;
&lt;h2 id=&#34;operation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#operation&#34;&gt;#&lt;/a&gt; Operation&lt;/h2&gt;
&lt;p&gt;IF (64-Bit Mode and OperandSize = 64)&lt;br /&gt;
THEN&lt;br /&gt;
TEMP128 ← DEST&lt;br /&gt;
IF (RDX:RAX = TEMP128)&lt;br /&gt;
THEN&lt;br /&gt;
ZF ← 1;&lt;br /&gt;
DEST ← RCX:RBX;&lt;br /&gt;
ELSE&lt;br /&gt;
ZF ← 0;&lt;br /&gt;
RDX:RAX ← TEMP128;&lt;br /&gt;
DEST ← TEMP128;&lt;br /&gt;
FI;&lt;br /&gt;
FI&lt;br /&gt;
ELSE&lt;br /&gt;
TEMP64 ← DEST;&lt;br /&gt;
IF (EDX:EAX = TEMP64)&lt;br /&gt;
THEN&lt;br /&gt;
ZF ← 1;&lt;br /&gt;
DEST ← ECX:EBX;&lt;br /&gt;
ELSE&lt;br /&gt;
ZF ← 0;&lt;br /&gt;
EDX:EAX ← TEMP64;&lt;br /&gt;
DEST ← TEMP64;&lt;br /&gt;
FI;&lt;br /&gt;
FI;&lt;br /&gt;
FI;&lt;/p&gt;
&lt;h1 id=&#34;renference&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#renference&#34;&gt;#&lt;/a&gt; Renference&lt;/h1&gt;
&lt;p&gt;Intel 白皮书第二卷&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjI3MjM1L2FydGljbGUvZGV0YWlscy84MDM2ODI1NA==&#34;&gt; https://blog.csdn.net/qq_41627235/article/details/80368254&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy81MThkM2U4NWRmMzZhMzJkNzM3NWE0MTc4NjZmYjg0YWU0NWNjMzg2Lmh0bWw=&#34;&gt;https://wenku.baidu.com/view/518d3e85df36a32d7375a417866fb84ae45cc386.html&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWhlamlhbzE1MTYvYXJ0aWNsZS9kZXRhaWxzLzEwMDg3NTEwNQ==&#34;&gt;https://blog.csdn.net/chuhejiao1516/article/details/100875105&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzM1ODkuaHRtbA==&#34;&gt;http://c.biancheng.net/view/3589.html&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
