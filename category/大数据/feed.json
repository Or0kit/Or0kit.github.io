{
    "version": "https://jsonfeed.org/version/1",
    "title": "Or0kit • All posts by \"大数据\" category",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Or0kit.github.io",
    "items": [
        {
            "id": "https://or0kit.github.io/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/",
            "url": "https://or0kit.github.io/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/",
            "title": "大数据学习",
            "date_published": "2020-12-19T12:27:20.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<blockquote>\n<p>复习大数据 ing！！老师不靠谱，只能自己来了。踩坑 ing</p>\n</blockquote>\n<h1 id=\"防火墙\"><a class=\"anchor\" href=\"#防火墙\">#</a> 防火墙</h1>\n<p>参考自博客园的一位前辈。要搭建四台集群 Linux 虚拟机，下载的 Linux 版本为 centos 7 系列，装完才知道相比于 centos 6 做了很大的改动，很多命令都不一样了，例如：系统服务都用 systemctl 命令来开启 service，它是 CentOS7 的服务管理中主要的工具，融合了之前 service 和 chkconfig 的功能，据说，systemctl 与以往启动系统服务使用 /etc/init.d 脚本的方式相比，大幅提高了系统服务的执行效率。由于在配置集群时，很多问题都是因为防火墙导致，需要经常配置，所以特别把防火墙的操作命令记录下来。</p>\n<h2 id=\"一-防火墙的开启-关闭-禁用命令\"><a class=\"anchor\" href=\"#一-防火墙的开启-关闭-禁用命令\">#</a> 一、防火墙的开启、关闭、禁用命令</h2>\n<p>（1）设置开机启用防火墙：systemctl enable firewalld.service</p>\n<p>（2）设置开机禁用防火墙：systemctl disable firewalld.service</p>\n<p>（3）启动防火墙：systemctl start firewalld</p>\n<p>（4）关闭防火墙：systemctl stop firewalld</p>\n<p>（5）检查防火墙状态：systemctl status firewalld</p>\n<h2 id=\"二-使用firewall-cmd配置端口\"><a class=\"anchor\" href=\"#二-使用firewall-cmd配置端口\">#</a> 二、使用 firewall-cmd 配置端口</h2>\n<p>（1）查看防火墙状态：firewall-cmd --state</p>\n<p>（2）重新加载配置：firewall-cmd --reload</p>\n<p>（3）查看开放的端口：firewall-cmd --list-ports</p>\n<p>（4）开启防火墙端口：firewall-cmd --zone=public --add-port=9200/tcp --permanent</p>\n<p>命令含义：</p>\n<p>–zone #作用域</p>\n<p>–add-port=9200/tcp #添加端口，格式为：端口 / 通讯协议</p>\n<p>–permanent #永久生效，没有此参数重启后失效</p>\n<p>注意：添加端口后，必须用命令 firewall-cmd --reload 重新加载一遍才会生效</p>\n<p>（5）关闭防火墙端口：firewall-cmd --zone=public --remove-port=9200/tcp --permanent</p>\n<p>参考自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWFyc28vYXJjaGl2ZS8yMDE4LzAxLzA2LzgyMTQ5MjcuaHRtbA==\"> https://www.cnblogs.com/marso/archive/2018/01/06/8214927.html</span></p>\n<h1 id=\"ssh公钥登陆\"><a class=\"anchor\" href=\"#ssh公钥登陆\">#</a> SSH 公钥登陆</h1>\n<p>Hadoop 集群之间的交互是不用密码的，否则如果每次都必须输入密码会非常麻烦。SSH 还提供了公钥登陆，可以省去输入密码的步骤。</p>\n<p>所谓 “公钥登陆”，原理很简单，就是用户将自己的公钥存储在远程主机上。登陆的时候，远程主机会向用户发送一段水机字符串，用户用自己的私钥加密后，再发回去。远程主机用事先储存的公钥进行解密，如果成功就证明用户是可信的，直接允许登陆 shell，不再要求密码。</p>\n<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用 ssh-keygen 生成一个。建议直接用创建的 Hadoop 用户进行设置，因为设置只对当前用户用户，一般 Hadoop 主程序是那个用户，就对那个用户进行 SSH 设置。</p>\n<p>参考自 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xhc3R5aG0vYXJ0aWNsZS9kZXRhaWxzLzEwOTcwMjg2Mw==\">hadoop 集群配置 ssh 免密登录的方法</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2hpcmVlbmxlZTR0ZXN0aW5nL3AvMTAzNjYwNjEuaHRtbA==\"> Hadoop 集群配置免密 SSH 登录方法</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWt1YW43My9hcnRpY2xlL2RldGFpbHMvNzgwOTAyNDQ=\"> ssh-copy-id 命令详解 &amp; 使用 ssh-keygen 和 ssh-copy-id 三步实现 SSH 无密码登录</span></p>\n<h2 id=\"hadoop集群配置免密ssh登录方法\"><a class=\"anchor\" href=\"#hadoop集群配置免密ssh登录方法\">#</a> Hadoop 集群配置免密 SSH 登录方法</h2>\n<p>Hadoop 集群包含 1 个主节点和 3 个从节点，需要实现各节点之间的免密码登录，下面介绍具体的实现方法。</p>\n<h3 id=\"hadoop集群环境\"><a class=\"anchor\" href=\"#hadoop集群环境\">#</a> Hadoop 集群环境</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">节点名称</th>\n<th style=\"text-align:right\">节点 IP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">node</td>\n<td style=\"text-align:right\">192.168.10.100</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">node1</td>\n<td style=\"text-align:right\">192.168.10.101</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">node2</td>\n<td style=\"text-align:right\">192.168.10.102</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">node3</td>\n<td style=\"text-align:right\">192.168.10.103</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"免密登录原理\"><a class=\"anchor\" href=\"#免密登录原理\">#</a> 免密登录原理</h3>\n<p>每台主机 authorized_keys 文件里面包含的主机（ssh 密钥），该主机都能无密码登录，所以只要每台主机的 authorized_keys 文件里面都放入其他主机（需要无密码登录的主机）的 ssh 密钥就行了</p>\n<h3 id=\"实现方法\"><a class=\"anchor\" href=\"#实现方法\">#</a> 实现方法</h3>\n<ol>\n<li>配置每个节点的 hosts 文件。在 hosts 文件里新增以下内容。</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#vi /etc/hosts</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">192.168</span>.10.100 node</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">192.168</span>.10.101 node1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">192.168</span>.10.102 node2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">192.168</span>.10.103 node3</pre></td></tr></table></figure><ol start=\"2\">\n<li>每个节点生成 ssh 密钥。这里以 node 主机举例。</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-keygen -t rsa</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Generating public/private rsa key pair.</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Enter <span class=\"token function\">file</span> <span class=\"token keyword\">in</span> <span class=\"token function\">which</span> to save the key <span class=\"token punctuation\">(</span>/root/.ssh/id_rsa<span class=\"token punctuation\">)</span>: </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Created directory <span class=\"token string\">'/root/.ssh'</span><span class=\"token builtin class-name\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Enter passphrase <span class=\"token punctuation\">(</span>empty <span class=\"token keyword\">for</span> no passphrase<span class=\"token punctuation\">)</span>: </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Enter same passphrase again: </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Your identification has been saved <span class=\"token keyword\">in</span> /root/.ssh/id_rsa.</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>Your public key has been saved <span class=\"token keyword\">in</span> /root/.ssh/id_rsa.pub.</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">[</span>root@node .ssh<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>id_rsa  id_rsa.pub</pre></td></tr></table></figure><p>执行命令后会在～目录下生成.ssh 文件夹，里面包含 id_rsa 和 id_rsa.pub 两个文件。</p>\n<p><em><strong>注：使用 ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa 命令可避免上述交互式操作。</strong></em><br />\n<font color=\"red\">用完这个命令后我是出现了点小问题，什么让输入密钥以解锁私钥。输入什么都不行</font></p>\n<ol start=\"3\">\n<li>将公钥拷贝到要免密登录的目标机器上</li>\n</ol>\n<p><em><strong>此例是在节点 node 上</strong></em></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node .ssh<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-copy-id node1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>/usr/bin/ssh-copy-id: INFO: attempting to log <span class=\"token keyword\">in</span> with the new key<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>, to filter out any that are already installed</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>/usr/bin/ssh-copy-id: INFO: <span class=\"token number\">1</span> key<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> remain to be installed -- <span class=\"token keyword\">if</span> you are prompted now it is to <span class=\"token function\">install</span> the new keys</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>root@node<span class=\"token punctuation\">\\</span>'s password: </pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Number of key<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> added: <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>Now try logging into the machine, with:   <span class=\"token string\">\"ssh 'node'\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>and check to <span class=\"token function\">make</span> sure that only the key<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> you wanted were added.</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">[</span>root@node .ssh<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span></pre></td></tr></table></figure><p>然后再依次执行以下命令</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node .ssh<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-copy-id node2</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@node .ssh<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-copy-id node3</span></pre></td></tr></table></figure><p>此时节点 node 可以无密码登陆 node1、node2、node3 了。<br />\n但 node1、node2、node3 还不能无密码登陆 node 与其他节点，还需要在 node1、node2、node3 上依次执行步骤 2~3<br />\n 这里以 node1 为例。只写命令了。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node1 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-keygen -t rsa</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@node1 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-copy-id node</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@node1 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-copy-id node2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@node1 ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ssh-copy-id node3</span></pre></td></tr></table></figure><p>其他两个节点配置命令类似。</p>\n<ol start=\"4\">\n<li>.ssh 文件夹下（~/.ssh）的文件功能解释<br />\n known_hosts 记录 ssh 访问过计算机的公钥 (public key)<br />\n id_rsa 生成的私钥<br />\n id_rsa.pub 生成的公钥<br />\n authorized_keys 存放授权过的无密登录服务器公钥</li>\n</ol>\n<h1 id=\"hadoop的启动和测试\"><a class=\"anchor\" href=\"#hadoop的启动和测试\">#</a> Hadoop 的启动和测试</h1>\n<h2 id=\"格式化文件系统\"><a class=\"anchor\" href=\"#格式化文件系统\">#</a> 格式化文件系统</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node bin<span class=\"token punctuation\">]</span><span class=\"token comment\"># hdfs namenode -format</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>./hdfs:行201: /usr/local/jdk1.8//bin/java: 没有那个文件或目录</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@node bin<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span></pre></td></tr></table></figure><p>离谱呀，吐了呀！！<br />\n跟着这破书没有一步不报错！！</p>\n<p>SHUTDOWN_MSG: Shutting down NameNode at node/192.168.10.100</p>\n<p>node3: /root/hadoop/hadoop-2.2.0/bin/hdfs: 行 201: /usr/local/jdk1.8//bin/java: 没有那个文件或目录<br />\n node1: /root/hadoop/hadoop-2.2.0/bin/hdfs: 行 201: /usr/local/jdk1.8//bin/java: 没有那个文件或目录<br />\n node2: /root/hadoop/hadoop-2.2.0/bin/hdfs: 行 201: /usr/local/jdk1.8//bin/java: 没有那个文件或目录</p>\n<p>经历了大量的错误！！一个接一个的那种。<br />\n搞了一下午。<br />\n一个晚上。不知道哪里错了，NameNode 就是不启动。</p>\n<p>踏遍百度～<br />\n 搞到 10 点总算好了</p>\n<p>一直没法访问 <code>http://node:8088</code> ，有个好心的网友把他的 Hadoop 给我发了过来，我又看了看 yarn-site-xml 文件里的配置信息，才发现原来是多打了一个 s <span class=\"spoiler\" title=\"你知道得太多了\">我 GIAO</span>!</p>\n<h2 id=\"管理jobhistory-server\"><a class=\"anchor\" href=\"#管理jobhistory-server\">#</a> 管理 JobHistory Server</h2>\n<p>启动 JobHistory Server， 通过 Web 控制台查看集群计算的任务信息，执行如下命令：<br />\n <code>mr-jobhistory-daemon.sh  start historyserver</code> <br />\n 访问 <code>http://node:19888/</code>  可以查看任务执行历史消息。</p>\n<p>JobHistory Server 是个后台进程，不使用的情况下可以关闭以节约资源，终止 JobHistory Server 执行如下命令： <code>mr-jobhistory-daemon.sh  stop historyserver</code></p>\n<h2 id=\"集群验证\"><a class=\"anchor\" href=\"#集群验证\">#</a> 集群验证</h2>\n<p>使用 Hadoop 自带的 WordCount 例子进行集群验证。这个例子为 <code>/share/Hadoop/mapreduce.hadoop-mapreduce-examples-2.2.0.jar</code> , 下面的命令都会在本书后面章节讲到，可以先不用理会具体意思。</p>\n<p>首先在 HDFS 上创建目录，执行命令：</p>\n<pre><code class=\"language-hadoop\">hdfs dfs -mkdir -p /data/wordcount\nhdfs dfs -mkdir -p /output/\n</code></pre>\n<p>目录 /data/wordcount 用来存储 Hadoop 自带的 WordCount 例子的数据文件运行这个 MapReduce 任务的结果输出到 /output/wordcount 目录中。</p>\n<p>将本地文件上传到 HDFS 中（这里上传一个配置文件），执行如下命令：<br />\n <code>[root@node ~]# hdfs dfs -put /root/hadoop/hadoop-2.2.0/etc/hadoop/core-site.xml  /data/wordcount/</code> <br />\n 可以查看上传后的文件情况，执行如下命令：<br />\n <code>hdfs dfs -ls /data/wordcount</code> <br />\n 下面运行 WordCount 案例，执行如下命令：<br />\n <code> </code></p>\n",
            "tags": [
                "Hadoop"
            ]
        }
    ]
}